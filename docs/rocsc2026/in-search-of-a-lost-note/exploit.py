#!/usr/bin/env python3
"""
in_search CTF challenge solver
Recovers the flag from an Android secure notes app backup.

Steps:
1. Extract pepper from native library (XOR 0x5A on embedded bytes)
2. Parse security.xml for PBKDF2 params (salt, iterations, key length)
3. Extract the uncommitted flag entry from the SQLite WAL file
4. Brute-force the 8-digit PIN via PBKDF2-HMAC-SHA256
5. Decrypt with AES-256-GCM using nonce derived from timestamp
"""

import hashlib
import base64
import struct
import zipfile
import os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import msgpack

def extract_pepper(apk_path):
    with zipfile.ZipFile(apk_path) as zf:
        so_data = zf.read("lib/x86_64/libnative.so")
    raw = so_data[0x13020:0x13020 + 23]
    return bytes(b ^ 0x5A for b in raw).decode()


def parse_security_xml(case_zip_path):
    import xml.etree.ElementTree as ET
    with zipfile.ZipFile(case_zip_path) as zf:
        xml_data = zf.read("shared_prefs/security.xml")
    root = ET.fromstring(xml_data)
    params = {}
    for child in root:
        name = child.attrib["name"]
        if child.tag == "int":
            params[name] = int(child.attrib["value"])
        elif child.tag == "string":
            params[name] = child.text
        elif child.tag == "boolean":
            params[name] = child.attrib["value"] == "true"
    return params


def read_varint(data, pos):
    val = 0
    for i in range(8):
        b = data[pos]; pos += 1
        val = (val << 7) | (b & 0x7F)
        if b < 0x80:
            return val, pos
    b = data[pos]; pos += 1
    val = (val << 8) | b
    return val, pos


def extract_flag_entry(case_zip_path):
    with zipfile.ZipFile(case_zip_path) as zf:
        wal = zf.read("databases/notes.db-wal")

    page_size = struct.unpack(">I", wal[8:12])[0]
    header_size = 32
    fh_size = 24  # frame header size

    total_frames = (len(wal) - header_size) // (fh_size + page_size)
    last_offset = header_size + (total_frames - 1) * (fh_size + page_size)

    commit_size = struct.unpack(">I", wal[last_offset + 4 : last_offset + 8])[0]
    assert commit_size == 0, "Last frame should be uncommitted"

    page_data = wal[last_offset + fh_size : last_offset + fh_size + page_size]
    num_cells = struct.unpack(">H", page_data[3:5])[0]

    cell_ptr = struct.unpack(">H", page_data[8 + (num_cells - 1) * 2 : 10 + (num_cells - 1) * 2])[0]
    pos = cell_ptr

    payload_len, pos = read_varint(page_data, pos)
    rowid, pos = read_varint(page_data, pos)

    rec_start = pos
    rec_hdr_len, pos = read_varint(page_data, pos)
    col_types = []
    while pos < rec_start + rec_hdr_len:
        ct, pos = read_varint(page_data, pos)
        col_types.append(ct)

    ts = int.from_bytes(page_data[pos:pos + 6], "big", signed=True)
    pos += 6
    # Read blob
    blob_len = (col_types[2] - 12) // 2
    ciphertext = page_data[pos : pos + blob_len]

    return ts, ciphertext


def derive_key(pin, pepper, salt, iterations, dk_len):
    password = f"{pin}:{pepper}".encode()
    return hashlib.pbkdf2_hmac("sha256", password, salt, iterations, dklen=dk_len)


def nonce_from_ts(ts):
    ts_bytes = bytearray(16)
    v = ts
    for i in range(8):
        ts_bytes[i] = v & 0xFF
        v >>= 8
    return hashlib.sha256(b"no" + bytes(ts_bytes)).digest()[:12]


def decrypt_aes_gcm(key, ts, ciphertext):
    nonce = nonce_from_ts(ts)
    return AESGCM(key).decrypt(nonce, ciphertext, None)


def main():
    base = os.path.dirname(os.path.abspath(__file__))
    apk_path = os.path.join(base, "app.apk")
    case_path = os.path.join(base, "case.zip")

    pepper = extract_pepper(apk_path)

    params = parse_security_xml(case_path)
    salt = base64.b64decode(params["salt_b64"])
    iterations = params["pbkdf2_iter"]
    dk_len = params["dk_len"]
    pin_len = params["pin_length"]

    flag_ts, flag_ct = extract_flag_entry(case_path)

    common = [
        "12345678", "00000000", "87654321", "11111111", "00001234",
        "01234567", "98765432", "12341234", "11223344", "99999999",
    ]
    print("Brute-forcing PIN...")
    for pin in common:
        key = derive_key(pin, pepper, salt, iterations, dk_len)
        try:
            plaintext = decrypt_aes_gcm(key, flag_ts, flag_ct)
            data = msgpack.unpackb(plaintext)
            print(f"PIN found: {pin}")
            print(f"FLAG: {data['body']}")
            return
        except Exception:
            continue

    for pin_int in range(10**pin_len):
        pin = f"{pin_int:0{pin_len}d}"
        if pin in common:
            continue
        key = derive_key(pin, pepper, salt, iterations, dk_len)
        try:
            plaintext = decrypt_aes_gcm(key, flag_ts, flag_ct)
            data = msgpack.unpackb(plaintext)
            print(f"PIN found: {pin}")
            print(f"FLAG: {data['body']}")
            return
        except Exception:
            continue

    print("[-] PIN not found")


if __name__ == "__main__":
    main()
