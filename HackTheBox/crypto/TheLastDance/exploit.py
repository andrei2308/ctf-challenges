#!/usr/bin/env python3
"""
ChaCha20 Nonce Reuse Attack
Exploits the vulnerability where the same key+nonce is used for multiple encryptions
"""

def xor_bytes(a, b):
    """XOR two byte arrays"""
    return bytes(x ^ y for x, y in zip(a, b))

def attack_chacha20_nonce_reuse():
    """
    Exploit ChaCha20 nonce reuse vulnerability

    The vulnerability:
    - Same key+nonce used for encrypting both message and flag
    - This means same keystream is generated for both

    Attack:
    - C1 = M1 ⊕ keystream (encrypted_message)
    - C2 = M2 ⊕ keystream (encrypted_flag)
    - C1 ⊕ C2 = M1 ⊕ M2
    - Therefore: M2 = M1 ⊕ C1 ⊕ C2
    """

    print("=== ChaCha20 Nonce Reuse Attack ===")

    # Known plaintext message
    known_message = b"Our counter agencies have intercepted your messages and a lot "
    known_message += b"of your agent's identities have been exposed. In a matter of "
    known_message += b"days all of them will be captured"

    print(f"Known message length: {len(known_message)} bytes")
    print(f"Known message: {known_message}")

    try:
        # Read the output file
        with open("out.txt", "r") as f:
            lines = f.read().strip().split('\n')

        if len(lines) != 3:
            print(f"Error: Expected 3 lines in out.txt, got {len(lines)}")
            return

        iv_hex = lines[0]
        encrypted_message_hex = lines[1]
        encrypted_flag_hex = lines[2]

        print(f"\nIV: {iv_hex}")
        print(f"Encrypted message: {encrypted_message_hex}")
        print(f"Encrypted flag: {encrypted_flag_hex}")

        # Convert from hex to bytes
        iv = bytes.fromhex(iv_hex)
        encrypted_message = bytes.fromhex(encrypted_message_hex)
        encrypted_flag = bytes.fromhex(encrypted_flag_hex)

        print(f"\nEncrypted message length: {len(encrypted_message)} bytes")
        print(f"Encrypted flag length: {len(encrypted_flag)} bytes")
        print(f"Known message length: {len(known_message)} bytes")

        # Verify message length matches
        if len(encrypted_message) != len(known_message):
            print(f"Warning: Length mismatch! encrypted_message={len(encrypted_message)}, known_message={len(known_message)}")

        # Method 1: Direct keystream recovery
        print(f"\n=== Method 1: Keystream Recovery ===")

        # Extract keystream from known message
        min_len = min(len(encrypted_message), len(known_message))
        keystream = xor_bytes(encrypted_message[:min_len], known_message[:min_len])

        print(f"Extracted keystream length: {len(keystream)} bytes")
        print(f"Keystream (first 32 bytes): {keystream[:32].hex()}")

        # Decrypt the flag using the keystream
        if len(encrypted_flag) <= len(keystream):
            decrypted_flag = xor_bytes(encrypted_flag, keystream[:len(encrypted_flag)])
            print(f"\nDECRYPTED FLAG: {decrypted_flag}")

            # Try to decode as text
            try:
                flag_text = decrypted_flag.decode('utf-8')
                print(f"FLAG (UTF-8): {flag_text}")
            except UnicodeDecodeError:
                print("Flag contains non-UTF-8 bytes")
        else:
            print(f"Error: Flag is longer than available keystream ({len(encrypted_flag)} > {len(keystream)})")

        # Method 2: Direct XOR approach
        print(f"\n=== Method 2: Direct XOR ===")

        # XOR the two ciphertexts to get M1 ⊕ M2
        min_len = min(len(encrypted_message), len(encrypted_flag))
        xor_result = xor_bytes(encrypted_message[:min_len], encrypted_flag[:min_len])

        # XOR with known message to get flag
        flag_len = min(len(xor_result), len(known_message))
        flag_candidate = xor_bytes(xor_result[:flag_len], known_message[:flag_len])

        print(f"Flag candidate (Method 2): {flag_candidate}")

        try:
            flag_text2 = flag_candidate.decode('utf-8')
            print(f"FLAG (Method 2): {flag_text2}")
        except UnicodeDecodeError:
            print("Flag candidate contains non-UTF-8 bytes")

        # If flag is longer than the message, try partial recovery
        if len(encrypted_flag) > len(known_message):
            print(f"\n=== Partial Flag Recovery ===")
            print(f"Flag is {len(encrypted_flag)} bytes, message is {len(known_message)} bytes")
            print(f"Can decrypt first {len(known_message)} bytes of flag")

            partial_flag = xor_bytes(encrypted_flag[:len(known_message)], keystream[:len(known_message)])
            print(f"Partial flag: {partial_flag}")

            try:
                partial_text = partial_flag.decode('utf-8')
                print(f"PARTIAL FLAG: {partial_text}")
            except UnicodeDecodeError:
                print("Partial flag contains non-UTF-8 bytes")

    except FileNotFoundError:
        print("Error: out.txt file not found!")
        print("Make sure you have the output file from the ChaCha20 encryption")
    except Exception as e:
        print(f"Error: {e}")

def main():
    attack_chacha20_nonce_reuse()

if __name__ == "__main__":
    main()