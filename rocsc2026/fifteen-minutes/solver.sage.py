

# This file was *autogenerated* from the file solver.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_2000 = Integer(2000); _sage_const_0 = Integer(0); _sage_const_30351 = Integer(30351); _sage_const_5 = Integer(5); _sage_const_15 = Integer(15); _sage_const_3 = Integer(3); _sage_const_1000 = Integer(1000); _sage_const_64 = Integer(64); _sage_const_63 = Integer(63); _sage_const_61 = Integer(61); _sage_const_45 = Integer(45); _sage_const_10 = Integer(10); _sage_const_8 = Integer(8); _sage_const_4 = Integer(4); _sage_const_10000 = Integer(10000)
from pwn import remote
import re
import itertools
from sage.all import *

def solve_orthogonal_lattice(Y, dim_hidden):
    N = len(Y)
    num_rels = N - dim_hidden

    M = Matrix(ZZ, N, N + _sage_const_1 )
    penalty = max(Y) * (_sage_const_2 **_sage_const_2000 )

    for i in range(N):
        M[i, i] = _sage_const_1 
        M[i, N] = Y[i] * penalty

    L = M.LLL()

    relations = [list(row[:N]) for row in L if row[N] == _sage_const_0 ]
    relations.sort(key=lambda row: sum(x**_sage_const_2  for x in row))

    S = Matrix(ZZ, relations[:num_rels])
    U = Matrix(ZZ, S.right_kernel().basis()).LLL()

    U_list = list(U)
    U_list.sort(key=lambda v: sum(x**_sage_const_2  for x in v))
    return U_list

def exploit():
    # Adjust IP and port as needed
    io = remote("35.234.109.37", _sage_const_30351 )

    # === TYP 1: Signatures ===
    for round_idx in range(_sage_const_5 ):
        print(f"\n[*] Typ 1 - Round {round_idx + _sage_const_1 }")
        
        # [OPTIMIZATION 1] Pipeline Network I/O
        io.send(b"A\n" * _sage_const_15  + b"E\n")
        Y = []
        for _ in range(_sage_const_15 ):
            res_line = io.recvline().decode()
            res = int(re.search(r"res=(\d+)", res_line).group(_sage_const_1 ))
            Y.append(res**_sage_const_3 )

        U_list = solve_orthogonal_lattice(Y, dim_hidden=_sage_const_3 )

        U_QQ = Matrix(QQ, U_list)
        Y_QQ = vector(QQ, Y)
        c = U_QQ.solve_left(Y_QQ)
        n = abs(c[-_sage_const_1 ].numerator())
        for p in primes(_sage_const_2 , _sage_const_1000 ):
            while n > _sage_const_1  and n % p == _sage_const_0 : n //= p

        print(f"[+] Recovered n = {n}")
        io.sendafter(b"n=", str(n).encode() + b"\n")

    # === TYP 2: Encryption ===
    
    # Precompute cubic residues mod 64, 63, 61 for hyper-fast loop filtering
    valid_64 = [False]*_sage_const_64 ; valid_63 = [False]*_sage_const_63 ; valid_61 = [False]*_sage_const_61 
    for x in range(_sage_const_64 ): valid_64[(x**_sage_const_3 ) % _sage_const_64 ] = True
    for x in range(_sage_const_63 ): valid_63[(x**_sage_const_3 ) % _sage_const_63 ] = True
    for x in range(_sage_const_61 ): valid_61[(x**_sage_const_3 ) % _sage_const_61 ] = True

    for round_idx in range(_sage_const_5 ):
        print(f"\n[*] Typ 2 - Round {round_idx + _sage_const_1 }")
        
        # [OPTIMIZATION 1] Pipeline Network I/O
        io.send(b"A\n" * _sage_const_45  + b"E\n")
        Y = []
        for _ in range(_sage_const_45 ):
            res_line = io.recvline().decode()
            res = int(re.search(r"res=(\d+)", res_line).group(_sage_const_1 ))
            Y.append(res)

        print("[*] Computing Orthogonal Lattice (5D Subspace)...")
        U_list = solve_orthogonal_lattice(Y, dim_hidden=_sage_const_5 )

        print("[*] Algebraic Tensor Recovery (Bypassing Flatness Skew)...")
        Q_rows = []
        for i in range(_sage_const_45 ):
            row = []
            for j in range(_sage_const_5 ):
                for k in range(j, _sage_const_5 ):
                    row.append(U_list[j][i] * U_list[k][i])
            Q_rows.append(row)
            
        Q = Matrix(ZZ, Q_rows)
        K_basis = Q.right_kernel().basis()
        
        def vec_to_sym_mat(v):
            M = Matrix(QQ, _sage_const_5 , _sage_const_5 )
            idx = _sage_const_0 
            for j in range(_sage_const_5 ):
                for k in range(j, _sage_const_5 ):
                    if j == k: M[j, k] = v[idx]
                    else: M[j, k] = v[idx] / _sage_const_2 ; M[k, j] = v[idx] / _sage_const_2 
                    idx += _sage_const_1 
            return M
            
        M1 = vec_to_sym_mat(K_basis[_sage_const_0 ])
        M2 = vec_to_sym_mat(K_basis[_sage_const_1 ])
        M3 = vec_to_sym_mat(K_basis[_sage_const_2 ])
        
        Stack = Matrix(QQ, _sage_const_15 , _sage_const_5 )
        for i in range(_sage_const_5 ):
            for j in range(_sage_const_5 ):
                Stack[i, j] = M1[i, j]
                Stack[i+_sage_const_5 , j] = M2[i, j]
                Stack[i+_sage_const_10 , j] = M3[i, j]
                
        v_K_QQ = Stack.right_kernel().basis()[_sage_const_0 ]
        denom = lcm([x.denominator() for x in v_K_QQ])
        v_K_ZZ = vector(ZZ, [x * denom for x in v_K_QQ])
        g = gcd(list(v_K_ZZ))
        v_K = [int(x // g) for x in v_K_ZZ]

        print("[*] Computing Exact Integer Quotient Lattice (Zero Distortion)...")
        P_T = Matrix(ZZ, [v_K]).right_kernel_matrix() 
        U_mat = Matrix(ZZ, U_list)
        
        W_mat = P_T * U_mat
        L = W_mat.LLL()
        
        print("[*] Brute-forcing pristine 4D lattice (Scanning ~83K combinations)...")
        found_vectors = []
        W0 = L[_sage_const_0 ]; W1 = L[_sage_const_1 ]; W2 = L[_sage_const_2 ]; W3 = L[_sage_const_3 ]
        
        # [OPTIMIZATION 2] Extremely tight bounds for the pristine lattice
        bound = _sage_const_8  
        
        for c0, c1, c2, c3 in itertools.product(range(-bound, bound+_sage_const_1 ), repeat=int(_sage_const_4 )):
            if c0 == c1 == c2 == c3 == _sage_const_0 : continue
            
            v0 = int(c0*W0[_sage_const_0 ] + c1*W1[_sage_const_0 ] + c2*W2[_sage_const_0 ] + c3*W3[_sage_const_0 ])
            if v0 <= _sage_const_0 : continue
            if not valid_64[v0 & _sage_const_63 ]: continue
            if not valid_63[v0 % _sage_const_63 ]: continue
            if not valid_61[v0 % _sage_const_61 ]: continue
            
            r0, exact = ZZ(v0).nth_root(_sage_const_3 , truncate_mode=True)
            if not exact: continue

            v1 = int(c0*W0[_sage_const_1 ] + c1*W1[_sage_const_1 ] + c2*W2[_sage_const_1 ] + c3*W3[_sage_const_1 ])
            if v1 <= _sage_const_0 : continue
            if not valid_64[v1 & _sage_const_63 ]: continue
            if not valid_63[v1 % _sage_const_63 ]: continue
            if not valid_61[v1 % _sage_const_61 ]: continue
            
            r1, exact = ZZ(v1).nth_root(_sage_const_3 , truncate_mode=True)
            if not exact: continue
            
            is_cube = True
            roots = [int(r0), int(r1)]
            for i in range(_sage_const_2 , _sage_const_45 ):
                val = int(c0*W0[i] + c1*W1[i] + c2*W2[i] + c3*W3[i])
                if val <= _sage_const_0 :
                    is_cube = False; break
                r, exact = ZZ(val).nth_root(_sage_const_3 , truncate_mode=True)
                if not exact:
                    is_cube = False; break
                roots.append(int(r))

            if is_cube:
                is_indep = True
                for prev in found_vectors:
                    if roots[_sage_const_0 ] * prev[_sage_const_1 ] == roots[_sage_const_1 ] * prev[_sage_const_0 ]:
                        is_indep = False; break
                if is_indep:
                    found_vectors.append(roots)
                    if len(found_vectors) >= _sage_const_2 : break

        if len(found_vectors) < _sage_const_2 :
            print("[-] Failed to find independent cube vectors!")
            return

        print("[*] Independent cube vectors found! Resolving n using Resultants...")
        
        valid_pair = None
        for a, b in itertools.permutations(found_vectors, int(_sage_const_2 )):
            PR = PolynomialRing(ZZ, 'x')
            x = PR.gen()
            f0 = (a[_sage_const_0 ]*x + b[_sage_const_0 ])**_sage_const_3  - Y[_sage_const_0 ]
            f1 = (a[_sage_const_1 ]*x + b[_sage_const_1 ])**_sage_const_3  - Y[_sage_const_1 ]
            f2 = (a[_sage_const_2 ]*x + b[_sage_const_2 ])**_sage_const_3  - Y[_sage_const_2 ]
            f3 = (a[_sage_const_3 ]*x + b[_sage_const_3 ])**_sage_const_3  - Y[_sage_const_3 ]

            R01 = f0.resultant(f1)
            R02 = f0.resultant(f2)
            n_cand = gcd(R01, R02)

            if n_cand > _sage_const_2 **_sage_const_1000 :
                R03 = f0.resultant(f3)
                n = abs(gcd(gcd(R01, R02), R03))
                valid_pair = (a, b)
                break
                
        if not valid_pair:
            print("[-] Found cubes, but Resultants failed to converge on a valid n.")
            return
            
        a, b = valid_pair
        
        for p in primes(_sage_const_2 , _sage_const_10000 ):
            while n > _sage_const_1  and n % p == _sage_const_0 :
                n //= p

        print(f"[+] Recovered n = {n}")

        print("[*] Extracting m using exact Polynomial GCD...")
        PR_n = PolynomialRing(Zmod(n), 'xn')
        xn = PR_n.gen()
        f0_n = (a[_sage_const_0 ]*xn + b[_sage_const_0 ])**_sage_const_3  - Y[_sage_const_0 ]
        f1_n = (a[_sage_const_1 ]*xn + b[_sage_const_1 ])**_sage_const_3  - Y[_sage_const_1 ]

        poly_f = f0_n.monic()
        poly_g = f1_n.monic()
        while poly_g != _sage_const_0 :
            rem = poly_f % poly_g
            poly_f = poly_g
            if rem == _sage_const_0 : break
            poly_g = rem.monic()

        m_found = int(-poly_f[_sage_const_0 ])
        print(f"[+] Recovered m = {m_found}")

        io.sendafter(b"n=", str(n).encode() + b"\n")
        io.sendafter(b"m=", str(m_found).encode() + b"\n")

    print("\n[!] FLAG INCOMING:\n")
    print(io.recvall(timeout=_sage_const_5 ).decode())

if __name__ == "__main__":
    exploit()

